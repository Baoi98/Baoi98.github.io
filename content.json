{"meta":{"title":"Yellow","subtitle":null,"description":null,"author":"Yellow","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2019-06-22T12:11:10.000Z","updated":"2019-08-30T04:36:43.953Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Yellow 一名即将成为程序员的软件工程学生 即将面临苦逼的程序员生活 只为记录个人的学习过程"},{"title":"categories","date":"2019-06-22T12:12:22.000Z","updated":"2019-08-27T09:16:51.762Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"gallery","date":"2019-08-27T09:17:57.000Z","updated":"2019-08-27T09:18:16.257Z","comments":true,"path":"gallery/index.html","permalink":"http://yoursite.com/gallery/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-22T12:12:13.000Z","updated":"2019-08-27T09:17:09.616Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"说说CountDownLatch与CyclicBarrier区别","slug":"说说CountDownLatch与CyclicBarrier区别","date":"2019-09-22T08:15:04.924Z","updated":"2019-09-22T08:17:17.068Z","comments":true,"path":"2019/09/22/说说CountDownLatch与CyclicBarrier区别/","link":"","permalink":"http://yoursite.com/2019/09/22/说说CountDownLatch与CyclicBarrier区别/","excerpt":"","text":"说说CountDownLatch与CyclicBarrier区别 CountDownLatch 的作用是允许1或n个线程等待其他线程完成执行；而 CyclicBarrier 是允许n个线程相互等待； CountDownLatch 的计数器无法被重置，CyclicBarrier 的及数据可以被重置后重新使用，因为它被称为可以循环的barrier。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"},{"name":"JUC","slug":"JUC","permalink":"http://yoursite.com/tags/JUC/"}]},{"title":"说说Exchanger原理","slug":"说说Exchanger原理","date":"2019-09-22T07:48:54.499Z","updated":"2019-09-22T08:14:41.903Z","comments":true,"path":"2019/09/22/说说Exchanger原理/","link":"","permalink":"http://yoursite.com/2019/09/22/说说Exchanger原理/","excerpt":"","text":"说说Exchanger原理 当一个线程到达 exchanger 调用点时，如果它的伙伴线程此前已经调用过该方法，那么它的伙伴会被调度唤醒并与之进行对象交换，然后各自返回。如果它的伙伴还没到达交换点，那么当前线程将会被挂起，直至伙伴线程到达—-完成交换正常返回；或者当前线程被中断—-抛出中断异常；或者是等待超时—-抛出超时异常。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"},{"name":"JUC","slug":"JUC","permalink":"http://yoursite.com/tags/JUC/"}]},{"title":"说说Semaphore原理","slug":"说说Semaphore原理","date":"2019-09-22T07:45:28.348Z","updated":"2019-09-22T07:50:30.127Z","comments":true,"path":"2019/09/22/说说Semaphore原理/","link":"","permalink":"http://yoursite.com/2019/09/22/说说Semaphore原理/","excerpt":"","text":"说说Semaphore原理 Semaphore 直译为信号，实际上 Semaphore 可以看作是一个信号的集合。不同的线程能够从 Semaphore 中获取若干个信号量。当 Semaphore 对象持有的信号量不足时，尝试从 Semaphore 中获取信号的线程就会被阻塞，直到其他线程将信号量释放后，阻塞的线程会被唤醒，重新尝试获取信息量。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"},{"name":"JUC","slug":"JUC","permalink":"http://yoursite.com/tags/JUC/"}]},{"title":"说说CyclicBarrier原理","slug":"说说CyclicBarrier原理","date":"2019-09-22T03:36:48.759Z","updated":"2019-09-22T07:44:12.513Z","comments":true,"path":"2019/09/22/说说CyclicBarrier原理/","link":"","permalink":"http://yoursite.com/2019/09/22/说说CyclicBarrier原理/","excerpt":"","text":"说说CyclicBarrier原理 CyclicBarrier 是一个同步辅助类，允许一组线程相互等待，直到达到某个公共屏障点（Common Barrier Point）。因为该barrier在释放等待线程后可以重用，所以称它为循环的barrier。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"},{"name":"JUC","slug":"JUC","permalink":"http://yoursite.com/tags/JUC/"}]},{"title":"说说CountDownLatch原理","slug":"说说CountDownLatch原理","date":"2019-09-22T03:36:11.242Z","updated":"2019-09-22T07:37:39.079Z","comments":true,"path":"2019/09/22/说说CountDownLatch原理/","link":"","permalink":"http://yoursite.com/2019/09/22/说说CountDownLatch原理/","excerpt":"","text":"说说CountDownLatch原理 CountDownLatch 内部维护了一个整数n，n（要大于等于0）在当前线程初始化 CountDownLatch 方法指定。当前线程调用 CountDownLatch 的 await() 方法阻塞当前线程，等待其他调用 CountDownLatch 对象的 CountDown() 方法的线程执行完毕。其他线程调用 CountDownLatch 的 CountDown() 方法，该方法会把n-1，直到所有线程执行完成，n等于0，当前线程就恢复执行。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"},{"name":"JUC","slug":"JUC","permalink":"http://yoursite.com/tags/JUC/"}]},{"title":"sleep()、wait()、join()、yield()有什么区别","slug":"sleep()、wait()、join()、yield()有什么区别","date":"2019-09-22T03:14:46.376Z","updated":"2019-09-22T03:51:59.153Z","comments":true,"path":"2019/09/22/sleep()、wait()、join()、yield()有什么区别/","link":"","permalink":"http://yoursite.com/2019/09/22/sleep()、wait()、join()、yield()有什么区别/","excerpt":"","text":"sleep()、wait()、join()、yield()有什么区别 sleep()sleep()方法需要指定等待时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是sleep()方法不会释放“锁标志”，也就是说如果有synchronized同步块，其他线程仍然不能访问共享数据。 wait()wait()方法需要和notify()及notifyAll()两个方法一起介绍，这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized语句块内使用，也就是说，调用wait(),notify()和notifyAll()的任务在调用这些方法前必须拥有对象的锁。注意，它们都是Object类的方法，而不是Thread类的方法。 wait()方法与sleep()方法不同之处在于，wait()方法会释放对象的“锁标志”。当调用了某一对象的wait()方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了notify()方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权，当调用了某个对象的notifyAll()方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。 除了使用notify()和notifyAll()方法，还可以使用带毫秒参数的wait(long timeout)方法，效果是在延迟timeout毫秒后，被暂停的线程将被恢复到锁标志等待池。 此外，wait(),notify()及notifyAll()只能在synchronized语句中使用，但是如果使用的是ReenTrantLock实现同步，该如何达到这三个方法的效果？解决方法是使用ReentrantLock.newCondition()获取一个Condition类对象，然后Condition的await(),signal()以及signalAll()分别对应上面的三个方法。 join()join()方法会使当前线程等待调用join()方法的线程结束后才能继续执行。 yield()yield()方法和sleep()方法类似，也不会释放”锁标志“，区别在于，它没有参数，即yield()方法只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行，另外yield()方法只能使同优先级或者高优先级的线程得到执行机会，这也和sleep()方法不同。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"}]},{"title":"创建线程的方式及实现","slug":"创建线程的方式及实现","date":"2019-09-22T02:41:21.186Z","updated":"2019-09-22T03:09:23.510Z","comments":true,"path":"2019/09/22/创建线程的方式及实现/","link":"","permalink":"http://yoursite.com/2019/09/22/创建线程的方式及实现/","excerpt":"","text":"创建线程的方式及实现 继承Thread类创建线程类 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务，因此把run()方法称为执行体。 创建Thread子类的实例，即创建了线程对象。 调用线程对象的start()方法来启动该线程。 实现Runnable接口创建线程类 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 创建Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 调用线程对象的start()方法来启动线程。 通过Callable和Future创建线程 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。 使用FutureTask对象作为Thread对象的target创建并启动新线程。 调用FutureTask对象的get()方法来获取子线程执行结束后返回的值。 采用实现Runnable、Callable接口的方式创建多线程时： 优势：线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好的体现面向对象的思想。 劣势：编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。 使用继承Thread类的方式创建多线程时： 优势：编写简单，如果需要访问当前多线程，则无需使用Thead.currentThread()方法，直接使用this即可获得当前线程。 劣势：线程类已经继承了Thread类，所以不能再继承其他父类。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"}]},{"title":"Math类的三种取整方法","slug":"Math类的三种取整方法","date":"2019-09-20T02:11:43.013Z","updated":"2019-09-20T02:19:20.565Z","comments":true,"path":"2019/09/20/Math类的三种取整方法/","link":"","permalink":"http://yoursite.com/2019/09/20/Math类的三种取整方法/","excerpt":"","text":"Math类的三种取整方法 Math类中提供了三个与取整有关的方法：ceil、floor、round，这些方法的作用与它们的英文名称的含义相对应，例如，ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil(11.3)的结果为12,Math.ceil(-11.3)的结果是-11；floor的英文意义是地板，该方法就表示向下取整，Math.floor(11.6)的结果为11,Math.floor(-11.6)的结果是-12；最难掌握的是round方法，它表示“四舍五入”，算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"Java关键字及作用","slug":"Java关键字及作用","date":"2019-09-19T12:21:43.265Z","updated":"2019-09-19T14:37:28.610Z","comments":true,"path":"2019/09/19/Java关键字及作用/","link":"","permalink":"http://yoursite.com/2019/09/19/Java关键字及作用/","excerpt":"","text":"Java关键字及作用 关键字 作用 abstract 表明类或者成员方法具有抽象属性 assert 用来进行程序调试 boolean 基本数据类型之一，布尔类型 break 提前跳出一个块 byte 基本数据类型之一，字节类型 case 用在switch语句中，表示其中的一个分支 catch 用在异常处理中，用来捕捉异常 char 基本数据类型之一，字符类型 class 类 continue 回到一个块的开始处 default 默认，例如，用在switch语句中，表明一个默认的分支 do 用在do-while循环结构中 double 基本数据类型之一，双精度浮点数类型 else 用在条件语句中，表明当条件不成立时的分支 enum 枚举 extends 表明一个类型是另一个类型的子类型，这里常见的类型有类和接口 final 用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变 finally 用于处理异常情况，声明一个肯定会被执行到的语句块 float 基本数据类型之一，单精度浮点数类型 for 一种循环结构的引导词 goto 保留关键字，没有具体含义 if 条件语句的引导词 implements 表明一个类实现了给定的接口 import 表明要访问指定的类或包 instanceof 用来测试一个对象是否是指定类型的实例对象 int 基本数据类型之一，整数类型 interface 接口 long 基本数据类型之一，长整数类型 native 用来声明一个方法是由与计算机相关的语言实现的 new 用来创建新实例对象 package 包 private 一种访问控制方式：私用 protected 一种访问控制方式：保护 public 一种访问控制方式：公开 return 从成员方法中返回数据 short 基本数据类型之一，短整数类型 static 表明具有静态属性 stricfp 用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范 super 表明当前对象的父类型的引用或者父类型的构造方法 switch 分支语句结构的引导词 synchronized 表明一段代码需要同步执行 this 指向当前实例对象的引用 throw 抛出一个异常 throws 声明在当前定义的成员方法中所有需要抛出的异常 transient 声明不用序列化的成员域 try 尝试一个可能抛出异常的程序块 void 声明当前成员方法没有返回值 volatile 表明两个或多个变量必须同步的发生变化 while 用在循环结构中 const 保留关键字，没有具体含义","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"HashMap的工作原理","slug":"HashMap的工作原理","date":"2019-09-19T12:13:06.596Z","updated":"2019-09-20T01:11:41.909Z","comments":true,"path":"2019/09/19/HashMap的工作原理/","link":"","permalink":"http://yoursite.com/2019/09/19/HashMap的工作原理/","excerpt":"","text":"HashMap的工作原理 HashMap基于hashing原理，我们通过put()和get()方法存储和获取对象。当我们将键值对传递给put()方法时，它调用键对象的哈市Code()方法计算hashCode，然后找到bucket位置来存储值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞时，对象将会存储在链表的下一个节点中。HashMap在每一个链表节点中存储键值对对象。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"集合","slug":"集合","permalink":"http://yoursite.com/tags/集合/"}]},{"title":"HashSet和HashMap区别","slug":"HashSet和HashMap区别","date":"2019-09-19T12:03:32.952Z","updated":"2019-09-20T01:11:47.481Z","comments":true,"path":"2019/09/19/HashSet和HashMap区别/","link":"","permalink":"http://yoursite.com/2019/09/19/HashSet和HashMap区别/","excerpt":"","text":"HashSet和HashMap区别 HashMap HashSet HashMap实现了Map接口 HashSet实现了Set接口 HashMap存储键值对 HashSet仅存储对象 HashMap使用put()方法将元素放入map中 HashSet使用add()方法将元素放入set中 HashMap中使用键对象来计算hashCode值 HashSet使用成员对象来计算hashCode值，对于两个对象来说，hashCode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，返回false HashMap比较快，因为是使用唯一的键获取对象 HashSet较HashMap来说比较慢","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"集合","slug":"集合","permalink":"http://yoursite.com/tags/集合/"}]},{"title":"HashMap和HashTable的区别","slug":"HashMap和HashTable的区别","date":"2019-09-19T08:58:20.888Z","updated":"2019-09-20T01:11:52.672Z","comments":true,"path":"2019/09/19/HashMap和HashTable的区别/","link":"","permalink":"http://yoursite.com/2019/09/19/HashMap和HashTable的区别/","excerpt":"","text":"HashMap和HashTable的区别 HashMap 几乎可以等价于 HashTable，除了 HashMap 是非 synchronized的，并可以接受null（HashMap可以接受为null的键值（key）和值（value），而 HashTable 则不行）。 HashMap 是非 synchronized，而 HashTable 是 synchronized，这意味着 HashTable 是线程安全的，多个线程是不能共享 HashMap 的。Java5提供了 ConcurrentHashMap,它是用来替代 HashTable，比HashTable 的扩展性更好。 另一个区别是 HashMap 的迭代器（Iterator）是fail-fast迭代器，而HashTable的enumerator迭代器不是fail-fast的。所以当有其他线程改变了HashMap结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。 由于HashTable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果不需要同步，只需要单一线程，那么使用HashMap性能要好过HashTable。 HashMap不能保证随时间的推移，Map中的元素次序是不变的。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"集合","slug":"集合","permalink":"http://yoursite.com/tags/集合/"}]},{"title":"ArrayList与Vector区别","slug":"ArrayList与Vector区别","date":"2019-09-19T07:29:13.672Z","updated":"2019-09-20T01:11:03.481Z","comments":true,"path":"2019/09/19/ArrayList与Vector区别/","link":"","permalink":"http://yoursite.com/2019/09/19/ArrayList与Vector区别/","excerpt":"","text":"ArrayList与Vector区别 同步性：Vector 是线程安全的，也就是说它是同步的，而 ArrayList 是线程不安全的，不是同步的。 数据增长：当需要增长时，Vector 默认增长为原来的一倍，而 ArrayList 却是原来的50%，这样 ArrayList 就有利于节约内存空间。 说明：如果涉及到堆栈、队列等操作，应该考虑使用 Vector，如果需要快速随机访问元素，应该使用 ArrayList。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"集合","slug":"集合","permalink":"http://yoursite.com/tags/集合/"}]},{"title":"ArrayList与LinkedList区别","slug":"ArrayList与LinkedList区别","date":"2019-09-17T14:10:36.234Z","updated":"2019-09-20T01:10:57.061Z","comments":true,"path":"2019/09/17/ArrayList与LinkedList区别/","link":"","permalink":"http://yoursite.com/2019/09/17/ArrayList与LinkedList区别/","excerpt":"","text":"ArrayList与LinkedList区别 因为Array是基于索引（index）的数据结构，它使用索引在数组中搜索和读取数据是很快的。Array获取数据的时间复杂度是O(1)，但是要删除数据却是开销很大的，因为这需要重排数组中的所有数据。 相对于ArrayList，LinkedList插入是更快的，因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这个ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。ArrayList在插入数据时还需要更新索引（除了插入数组的尾部）。 类似于插入数据，删除数据时，LinkedList也优于ArrayList。 LinkedList需要更多的内存，因为ArrayList的每个索引位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。 LinkedList中访问元素时，必须从第一个元素开始顺序索引导第n个元素，然后读取数据。 LinkedList在插入和删除元素时不涉及重排数据，速度比ArrayList快。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"集合","slug":"集合","permalink":"http://yoursite.com/tags/集合/"}]},{"title":"List和Map区别","slug":"List和Map区别","date":"2019-09-17T13:40:48.490Z","updated":"2019-09-20T01:11:24.466Z","comments":true,"path":"2019/09/17/List和Map区别/","link":"","permalink":"http://yoursite.com/2019/09/17/List和Map区别/","excerpt":"","text":"List和Map区别 List 特点：元素有放入顺序，元素可以重复。 Map 特点：元素案件值对存储，无放入顺序。 List 接口有三个实现类：LinkedList、ArrayList、Vector。 LinkedList：底层基于链表实现，链表内存是散乱的，每一个元素存储本身内存地址的同时还存储下一个元素的地址。链表增删快，查找慢。 Map 接口有三个实现类：HashMap、HashTable、LinkedHashMap。 Map 相当于和 Collection 一个级别，Map 集合存储键值对，且要求保持键的唯一性。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"集合","slug":"集合","permalink":"http://yoursite.com/tags/集合/"}]},{"title":"List和Set区别","slug":"List和Set区别","date":"2019-09-14T13:10:59.682Z","updated":"2019-09-20T01:11:32.174Z","comments":true,"path":"2019/09/14/List和Set区别/","link":"","permalink":"http://yoursite.com/2019/09/14/List和Set区别/","excerpt":"","text":"List和Set区别 List，Set 都是继承于 Collection 接口。 List 特点：元素有放入顺序，元素可以重复。 Set 特点：元素无放入顺序，元素不可以重复（元素虽然无放入顺序，但是元素在 Set 集合中的位置是由元素的 HashCode 决定的，其位置是固定的）。 List 接口有三个实现类：LinkedList、ArrayList、Vector。 Set 接口有两个实现类：HashSet（底层由 HashMap 实现）、LinkedHashSet。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"集合","slug":"集合","permalink":"http://yoursite.com/tags/集合/"}]},{"title":"equals与==的区别","slug":"equals与==的区别","date":"2019-09-13T13:38:08.002Z","updated":"2019-09-14T12:58:10.884Z","comments":true,"path":"2019/09/13/equals与==的区别/","link":"","permalink":"http://yoursite.com/2019/09/13/equals与==的区别/","excerpt":"","text":"equals与==的区别 ==比较的是变量（栈）内存中存放的对象（堆）的内存地址，用来判断两个对象的地址是否相同，即是否是指向同一个对象。比较的是真正意义上的指针操作。 equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自 java.lang.Object 类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。 总结 ==与equals的主要区别是：==常用于比较原生的类型，而equals()方法用于检查对象的相等性。 另一个不同的是：如果==和equals()用于比较对象，当两个引用地址相同，==返回true，而equals()返回 true 或者 false 主要取决于重现实现。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"MVC设计思想","slug":"MVC设计思想","date":"2019-09-12T11:28:33.701Z","updated":"2019-09-12T11:43:38.971Z","comments":true,"path":"2019/09/12/MVC设计思想/","link":"","permalink":"http://yoursite.com/2019/09/12/MVC设计思想/","excerpt":"","text":"MVC设计思想 MVC是三个单词的首字母缩写：Model（模型），View（视图），Controller（控制）。MVC认为，不管程序是简单还是复杂，从结构上看都可以分为三层： 最上面的是直接面对最终用户的视图层（View），它提供给用户的操作界面，是程序的外壳。 最下面的是核心的数据模型层（Model），是程序需要操作的数据或信息。 中间的是控制层（Controller），负责根据用户从视图层输入的指令，选取数据层中的数据，然后对其进行相应的操作，产生最终结果。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"JDBC流程","slug":"JDCB流程","date":"2019-09-12T11:21:02.438Z","updated":"2019-09-12T11:30:16.601Z","comments":true,"path":"2019/09/12/JDCB流程/","link":"","permalink":"http://yoursite.com/2019/09/12/JDCB流程/","excerpt":"","text":"JDBC流程 向 DriverManager 类注册驱动数据库的驱动程序。 调用 DriverManager.getConnection() 方法，通过 JDBC URL、用户名、密码获取数据库连接。 获取 Connection 后，创建 prepareStatement（预编译，推荐使用）或 Statement（不推荐）对象执行SQL语句。 有时候会得到查询结果，查询的结果存放在结果集（ResultSet）中。 关闭数据库语句（prepareStatement对象），关闭数据库连接。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"Session分布式处理","slug":"Session分布式处理","date":"2019-09-11T11:20:34.782Z","updated":"2019-09-11T11:40:37.178Z","comments":true,"path":"2019/09/11/Session分布式处理/","link":"","permalink":"http://yoursite.com/2019/09/11/Session分布式处理/","excerpt":"","text":"Session分布式处理 Session复制在支持session复制的web服务器上，通过修改web服务器的配置，可以实现将session同步到其他web服务器上，达到每个web服务器上都保存一致的session。 优点：代码上不需要做支持和修改。 缺点：需要依赖支持和web服务器，一旦更换成不支持的web服务器就不能使用，在数据量很大的情况下不仅占用网络资源，而且会导致延迟。 适用场景：只适用于web服务器比较少且session数据量少的情况。 可用方案：开源方案 tomcat-redis-session-manager，暂不支持Tomcat8. Session粘滞将用户的每次请求都通过某种方法强制分发到某个web服务器上，只要这个web服务器存储了对应的session数据，就可以实现会话跟踪。 优点：使用简单，没有额外开销。 缺点：一旦某个web服务器重启或宕机，相对应的session数据将会丢失，而且需要依赖负载均衡机制。 适用场景：对稳定性要求不是很高的业务情景。 Session集中管理在单独的服务器或服务器集群上使用缓存技术，如redis存储session数据，集中管理所有的session，所有的web服务器都从这个存储介质中存取对应的session，实现session共享。 优点：可靠性高，减少web服务器的资源开销。 缺点：实现上有些复杂，配置较多。 适用场景：web服务器较多、要求高可用性的情况。 可用方案：开源方案Spring Session，也可以自己实现，主要是重写HttpServletRequestWrapper中的getSession方法。 基于Cookie管理这种方式每次发起请求的时候都需要将session数据放到cookie中传递给服务端。 优点：不需要依赖额外外部存储，不需要额外配置。 缺点：不安全，容易被盗取或篡改；cookie数量和长度有限制，需要消耗更多网络带宽。 适用场景：数据不重要、不敏感且数据量小的情况。 总结这四种方式，相对来说，session集中管理更加可靠，使用也是最多的。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"Session与Cookie区别","slug":"Session与Cookie区别","date":"2019-09-10T07:16:43.385Z","updated":"2019-09-11T09:11:23.551Z","comments":true,"path":"2019/09/10/Session与Cookie区别/","link":"","permalink":"http://yoursite.com/2019/09/10/Session与Cookie区别/","excerpt":"","text":"Session与Cookie区别 cookie数据是存放在客户的浏览器上，session数据是存放在服务器上。 cookie不是很安全，可以通过分析存放在本地的cookie进行cookie欺骗，考虑安全应该使用session。 session会在服务器上保存一段时间，当访问变多，大量的session数据会占用服务器性能，考虑服务器性能方面该使用cookie。 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"HTTP请求的GET与POST方式的区别","slug":"HTTP请求的GET与POST方式的区别","date":"2019-09-10T01:42:42.769Z","updated":"2019-09-10T01:49:05.537Z","comments":true,"path":"2019/09/10/HTTP请求的GET与POST方式的区别/","link":"","permalink":"http://yoursite.com/2019/09/10/HTTP请求的GET与POST方式的区别/","excerpt":"","text":"HTTP请求的GET与POST方式的区别 根据HTTP规范，GET请求用于信息获取，而且应该是安全的、幂等的。 根据HTTP规范，POST表示可能修改服务器上资源的请求。 GET首先，GET方式提交的数据最多只能是1024字节，因为GET是通过URL提交数据，URL中会显示提交参数，GET可提交的数据量就跟URL的长度有直接关系。 其次，URL不存在参数上限问题，HTTP协议规范没有对URL长度进行限制。GET方式速度快，允许跨域，但是只能携带文本的请求。 POSTPOST方式没有长度的限制，HTTP协议规范也没有进行大小限制，速度比GET方式慢，并且不支持跨域请求，但是可以携带媒体数据，如：文件上传。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"自定义注解的场景及实现","slug":"自定义注解的场景及实现","date":"2019-09-10T01:31:50.224Z","updated":"2019-09-10T01:40:33.679Z","comments":true,"path":"2019/09/10/自定义注解的场景及实现/","link":"","permalink":"http://yoursite.com/2019/09/10/自定义注解的场景及实现/","excerpt":"","text":"自定义注解的场景及实现 登录、权限拦截、日志处理，以及各种的Java框架，如：Spring、MyBatis、JUnit等都用到了注解。提到注解就要说帆帆，Java自定义注解是在运行时依靠Java的反射机制获取注解。实际开发中，假如我们要获取某个方法的调用日志，可以通过AOP给方法添加切面，通过反射来获取方法中包含的注解，如果包含日志注解就进行日志记录。 反射的实现 在Java应用层面上讲，是通过对Class对象的操作实现的，Class对象为我们提供了一系列对类进行操作的方法。 在JVM，Class文件是一组以8位字节为基础的二进制流，各个数据项目按严格的顺序紧凑的排序在Class文件中，里面包含了类、方法、字段等等相关数据。通过对Class数据流的处理得到字段、方法等数据。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"反射的用途及实现","slug":"反射的用途及实现","date":"2019-09-09T13:41:36.270Z","updated":"2019-09-09T13:45:04.695Z","comments":true,"path":"2019/09/09/反射的用途及实现/","link":"","permalink":"http://yoursite.com/2019/09/09/反射的用途及实现/","excerpt":"","text":"反射的用途及实现 反射机制是Java语言中一个非常重要的特性，它允许程序在运行时进行自我检查，同时也允许对其内部成员进行操作。 反射机制提供的功能主要有： 得到一个对象所属的类； 获取一个类的所有成员变量和方法； 在运行时创建对象； 在运行时调用对象的方法。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"运行时异常和一般异常有何异同","slug":"运行时异常和一般异常有何异同","date":"2019-09-09T07:24:53.428Z","updated":"2019-09-07T05:18:54.000Z","comments":true,"path":"2019/09/09/运行时异常和一般异常有何异同/","link":"","permalink":"http://yoursite.com/2019/09/09/运行时异常和一般异常有何异同/","excerpt":"","text":"运行时异常和一般异常有何异同 相同点运行时异常（runtime exception）与一般异常（checked exception）同属于Exception的子类。 不同点 定义不同 运行时异常都是RuntimeException类及其子类异常，如：NullpointerException、indexOutOfBoundsException等等； 一般异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。 处理方法不同 运行时异常是不检查异常的，程序中可以选择捕获处理，也可以不处理； 一般异常，Java编译器强制要求用户必须对出现的这类异常进行try catch捕获处理，否则程序不能编译通过。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"抽象类和接口的区别","slug":"抽象类和接口的区别","date":"2019-09-06T05:22:10.477Z","updated":"2019-09-06T05:54:58.057Z","comments":true,"path":"2019/09/06/抽象类和接口的区别/","link":"","permalink":"http://yoursite.com/2019/09/06/抽象类和接口的区别/","excerpt":"","text":"抽象类和接口的区别 抽象类（abstract class）含有abstract修饰的类成为抽象类，抽象类不能被实例化，抽象类中的抽象方法只做方法声明，不包含实现，只能够作为父类被继承实现。含有抽象方法的类必须定义为抽象类，但是一个抽象类中可以没有抽象方法。 接口（interface）接口可以说成是抽象类的一种特例，接口中所有的方法都必须是抽象的。接口中的方法默认定义为public abstract类型，接口中的成员变量类型默认为public static final. 接口的成员包括方法、属性、索引器、事件，不能够包含常量、字段、构造函数、析构函数、静态成员。 总结 比较 抽象类 接口 默认的实现方法 可以有默认的方法实现 接口是完全抽象的，不存在方法的实现 实现 子类使用extends继承抽象类，如果子类不是抽象类，子类需要提供抽象类中所有声明的方法的实现 子类使用implement实现接口，需要提供接口中所有声明的方法的实现 构造器 抽象类可以有构造器 接口不能有构造器 与正常Java类的区别 除了不能实例化，抽象类和普通Java类没有任何区别 接口是完全不同的类型 访问修饰符 抽象方法可以有public、protected和default这些修饰符 接口方法默认修饰符是public，不可以使用其他修饰符 main方法 抽象类可以有main方法，可以运行 接口没有main方法，不能运行 多继承 抽象方法可以继承一个类和实现多个接口 接口只可以继承一个或多个其他接口 速度 抽象类速度比接口快 接口速度有点慢，它需要去寻找在类中实现的方法 添加新方法 往抽象类中添加新方法，可以提供默认的实现，不需要改变原本的代码 往接口中添加方法，需要改变实现该接口的类","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"重载和重写的区别","slug":"重载和重写的区别","date":"2019-09-06T05:09:24.171Z","updated":"2019-09-06T05:17:53.641Z","comments":true,"path":"2019/09/06/重载和重写的区别/","link":"","permalink":"http://yoursite.com/2019/09/06/重载和重写的区别/","excerpt":"","text":"重载和重写的区别 重写 Override（运行期的多态）从字面上看，重写就是重新写一遍，重写是存在于继承的祖父类关系当中，表示子类重写父类的方法，方法名称和参数完全相同。 子类重写父类方法时，只能够比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，子类不能比父类有更多的问题，子类方法的访问权限只能比父类更大，不能更小。 如果父类中的方法是private修饰的，子类可以继承但是无法访问和重写该方法。 重载 Overload（编译期的多态）重载表示同一个类中可以有多个名称相同的方法，但是这些方法的参数列表各不相同，即参数个数或者类型不同。 为什么说重写是运行期的多态，重载是编译期的多态？重载是存在于同一个类中，在Java程序编译成字节码后，Overload注解失效。 重写是存在于子父类当中，当Java程序运行时，需要通过Override注解去查找方法的重写关系。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"String、SpringBuffer、StringBuilder的区别","slug":"String、SpringBuffer、StringBuilder的区别","date":"2019-09-04T12:19:10.628Z","updated":"2019-09-05T12:16:50.423Z","comments":true,"path":"2019/09/04/String、SpringBuffer、StringBuilder的区别/","link":"","permalink":"http://yoursite.com/2019/09/04/String、SpringBuffer、StringBuilder的区别/","excerpt":"","text":"String、SpringBuffer、StringBuilder的区别 Java中提供了三种可以存储和操作字符串的类： String StringBuffer StringBuilder 从大体上看： String：字符串常量 StringBuffer：字符串变量，线程安全 StringBuilder：字符串变量，线程非安全（不能够同步访问） 三者执行的速度比较： StringBuilder &gt; StringBuffer &gt; String StringString 是不可变对象，被final关键字修饰，不能够被继承，String类的内容一旦声明，不可被修改，改变的只是其内存的指向。等同于创建了一个新的String对象，将指针指向了新的String对象。对于经常要改变内容的字符串最好不要使用String。 StringBufferStringBuffer是可变对象，当对它进行修改的时候不会像String那样重新创建对象，它只能够通过构造函数来创建对象。StringBuffer是线程安全的，但是执行的效率比较慢，它是通过内部的char数组实现动态的改变字符串。 StringBuilderStringBuilder是JDK1.5后发布的，它和StringBuffer本质上没有什么区别，只是去掉了保证线程安全的部分，减少开销。 总结 操作少量、不经常修改的数据，使用String 多线程操作字符串缓冲区下的大量数据，使用StringBuffer 单线程操作字符串缓冲区下的大量数据，使用StringBuilder","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"final,finally,finalize的区别","slug":"final,finally,finalize的区别","date":"2019-09-04T04:42:55.351Z","updated":"2019-09-05T12:12:35.374Z","comments":true,"path":"2019/09/04/final,finally,finalize的区别/","link":"","permalink":"http://yoursite.com/2019/09/04/final,finally,finalize的区别/","excerpt":"","text":"final,finally,finalize的区别 final用于声明属性、方法和类，分别表示属性不可变，方法不可被重写，类不可被继承 finally异常处理语句结构的一部分，用于表示不论有没有捕获到异常都要执行的代码段 finalizejava.lang.Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的该方法，可以重写此方法提供垃圾收集时的其他资源回收，例如关闭文件等等。JVM不保证此方法总是被调用。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"int和Integer的区别","slug":"int和Integer的区别","date":"2019-09-04T04:20:48.712Z","updated":"2019-09-05T11:49:54.336Z","comments":true,"path":"2019/09/04/int和Integer的区别/","link":"","permalink":"http://yoursite.com/2019/09/04/int和Integer的区别/","excerpt":"","text":"int和Integer的区别 Java提供了两种不同的类型： 引用类型 原始类型（基本数据类型） int是Java的原始数据类型，Integer是Java为int提供的封装类。int的默认值是0，Integer的默认值是null。Integer可以区分出未赋值和值为0的两种情况，int无法表达未赋值的情况，int和Integer不能够互用。 Java为每一个基本数据类型都提供了封装类: 基本数据类型 封装类（引用类型） boolean Boolean char Character byte Byte short Short int Integer long Long float Float double Double 引用类型和基本数据类型的行为完全不同，并且它们具有不同的语义。 引用类型和基本数据类型具有不同的特征和用法，当引用类型和基本数据类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为null，而基本数据类型实例变量的缺省值与它们的类型有关。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"String是最基本的数据类型？","slug":"String是最基本的数据类型？","date":"2019-09-04T04:10:34.572Z","updated":"2019-09-04T04:19:25.499Z","comments":true,"path":"2019/09/04/String是最基本的数据类型？/","link":"","permalink":"http://yoursite.com/2019/09/04/String是最基本的数据类型？/","excerpt":"","text":"String 是最基本的数据类型吗？ 基本数据类型 byte – 1字节 int – 4字节 char – 2字节 long – 8字节 float – 4字节 double – 8字节 boolean – 1字节 short – 2字节 java.lang.String类是final类型的，不能够继承这个类，也不能修改这个类，所以String不是最基本的数据类型。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"Spring Boot整合Spring Data Redis","slug":"SpringBoot整合Spring Data Redis","date":"2019-09-03T08:43:15.931Z","updated":"2019-09-03T08:46:11.430Z","comments":true,"path":"2019/09/03/SpringBoot整合Spring Data Redis/","link":"","permalink":"http://yoursite.com/2019/09/03/SpringBoot整合Spring Data Redis/","excerpt":"","text":"RedisRedis 遵守BSD协议，是一个高性能的key-value键值对的非关系型数据库。Redis运行在内存中，所有的操作都是原子性的，支持事务，读写速度每秒可执行上万次。 Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 Spring Data Redis官方文档： https://spring.io/projects/spring-data-redis pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.ronin&lt;/groupId&gt; &lt;artifactId&gt;redis_demo&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;redis_demo&lt;/name&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Data --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- MySql Connection --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Apacher Common --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml1234567891011121314151617181920server: port: 9004spring: application: name: redis-demo datasource: driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql://192.168.55.136:3306/article?characterEncoding=UTF8 username: root password: 123456 jpa: # 数据库类型 database: MySQL # 开启控制台打印sql语句 show-sql: true hibernate: ddl-auto: update# 192.168.55.136：6379 不写端口，默认是6379 redis: host: 192.168.55.136 Service12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Service@Transactionalpublic class ArticleService &#123; @Autowired private ArticleDao articleDao; //注入spring data redis提供的RedisTemplate模板 @Autowired private RedisTemplate redisTemplate; /** * 根据ID查询实体 * @param id * @return */ public Article findById(String id) &#123; //从缓存中提取 Article article = (Article) redisTemplate.opsForValue().get(\"article_\" + id); //如果缓存没有则到数据库查询并放入缓存,设置有效时间10秒 if(article == null)&#123; //从数据库中查询数据 article = articleDao.findById(id).get(); //将数据存放到redis缓存中 redisTemplate.opsForValue().set(\"article_\" + id,article,10, TimeUnit.SECONDS); &#125; return article; &#125; /** * 修改 * @param article */ public void update(Article article) &#123; redisTemplate.delete(\"article_\" + article.getId()); articleDao.save(article); &#125; /** * 删除 * @param id */ public void deleteById(String id) &#123; redisTemplate.delete(\"article_\" + id); articleDao.deleteById(id); &#125;&#125; 注解方式Spring Data Redis 不仅提供了使用 RedisTemplate 模板操作的方式，它还有提供使用注解操作 Redis 的方式。 使用注解方式开发，需要在 Application.java 启动类中添加 @EnableCaching 注解 1234567@SpringBootApplication@EnableCachingpublic class ArticleApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ArticleApplication.class, args); &#125;&#125; Service@Cacheable 用于增、查操作，需要提供两个属性：​ key： 存入 redis 缓存中的 key 值​ value：类似于区域名，在存入 redis 时会开启一块区域存放同一 value 的数据，之后的同 value 操作都会在该区域中查找 @CacheEvict 用于更新、删除操作，也需要提供 key、value 两个属性来匹配 123456789101112131415161718192021222324252627282930313233343536@Service@Transactionalpublic class ArticleService &#123; @Autowired private ArticleDao articleDao; /** * 根据ID查询实体 * @param id * @return */ @Cacheable(key = \"#id\",value = \"article\") public Article findById(String id) &#123; return articleDao.findById(id).get(); &#125; /** * 修改 * @param gathering */ @CacheEvict(key = \"#article.id\",value = \"article\") public void update(Article article) &#123; articleDao.save(article); &#125; /** * 删除 * @param id */ @CacheEvict(key = \"#id\",value = \"article\") public void deleteById(String id) &#123; articleDao.deleteById(id); &#125;&#125; 测试启动服务，通过 api 访问 第一次访问，控制台打印查询数据库的 sql 语句测试数据是否真的放入缓存，多访问几次方法，查看是否还会打印 sql 语句，如果没有打印，说明数据是从缓存中获取的！！！ Spring Data Redis 基本案例成功！","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"Java面向对象三大特性","slug":"Java面向对象三大特征","date":"2019-09-03T05:53:35.072Z","updated":"2019-09-04T04:57:28.571Z","comments":true,"path":"2019/09/03/Java面向对象三大特征/","link":"","permalink":"http://yoursite.com/2019/09/03/Java面向对象三大特征/","excerpt":"","text":"面向对象的三大特性 面向对象的三个基本特性是：封装、继承、多态 封装封装是面向对象的特性之一，是对象和类概念的主要特性。 封装就是把客观事物封装成抽象的类，将需要的信息放入类中，也可以成为一种信息隐藏技术，类可以把自己的属性和方法暴露出来给可信的类或者对象操作，也可以将信息隐藏。 继承继承是面向对象编程语言的主要功能，子类继承父类，子类可以获得除private权限以外的所有父类的属性和方法，并且可以在无需重新编写原来的类的情况下对某些功能进行扩展。Java中只支持单继承。 多态多态性是指允许将父对象设置成为和一个或多个的它的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同方式运行。 概述成一句话：相同的行为在不同的情况下表现出不同的效果。 实现多态的两种方式： 静态多态：重载（发生在编译期） ​ 在一个类中，方法名相同，入参列表不同 动态多态：重写 （发生在运行期） ​ 存在于子类与父类中，子类重写父类的方法，方法名和入参列表相同","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"Linux安装MySql","slug":"Linux安装MySql","date":"2019-08-31T10:11:20.046Z","updated":"2019-08-31T10:14:24.060Z","comments":true,"path":"2019/08/31/Linux安装MySql/","link":"","permalink":"http://yoursite.com/2019/08/31/Linux安装MySql/","excerpt":"","text":"简述本篇文章Linux系统使用的是Ubuntu 16.04版本，系统数据源修改可浏览https://blog.csdn.net/qq_36525300/article/details/89222477文章。 安装步骤 更新数据源 安装MySql 1apt-get install mysql-server 安装过程中会提示您输入 root 密码。您可以按 Y，然后 ENTER 接受所有后续问题的默认值，但是要询问您是否要更改 root 密码。 检查MySql状态 查看MySql版本 配置MySql远程访问一般情况下，我们尽量不会直接在虚拟机Ubuntu系统直接操作数据库，使用SQLyug等数据库操作工具直接通过ip地址连接虚拟机上的MySql操作，这就需要我们开启MySql的远程访问权限。 修改配置文件 1vi /etc/mysql/mysql.conf.d/mysqld.cnf 注释代码 保存退出，重启MySql 1service mysql restart 登陆MySql 1mysql -u root -p","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"MySql","slug":"MySql","permalink":"http://yoursite.com/tags/MySql/"}]},{"title":"Linux安装Tomcat","slug":"Linux安装Tomcat","date":"2019-08-31T10:06:09.678Z","updated":"2019-08-31T10:11:02.873Z","comments":true,"path":"2019/08/31/Linux安装Tomcat/","link":"","permalink":"http://yoursite.com/2019/08/31/Linux安装Tomcat/","excerpt":"","text":"简述本篇文章使用Linux系统为Ubuntu 16.04版本，Tomcat版本为8.5.32 Tomcat安装包Tomcat 8.5.32下载链接：https://pan.baidu.com/s/15kOUyqzaQajqWhaa7Pd5Vg提取码：6mc1 安装步骤 通过Xftp工具将下载的Tomcat压缩包上传到/usr/local/目录下（若没有Xftp工具，可浏览另一篇文章https://blog.csdn.net/qq_36525300/article/details/89216023下载） 1cd /usr/local 解压缩，删除压缩包 1tar -zxvf apache-tomcat-8.5.23.tar.gz 1rm -rf apache-tomcat-8.5.23.tar.gz 解压后，目录多了一个tomcat文件夹 进入tomcat文件夹的bin目录，启动tomcat容器 1cd /usr/local/apache-tomcat-8.5.23/bin 1./startup.sh 停止tomcat容器 1./shutdown.sh","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"}]},{"title":"Linux安装Java","slug":"Linux安装Java","date":"2019-08-31T08:12:47.529Z","updated":"2019-08-31T08:31:22.587Z","comments":true,"path":"2019/08/31/Linux安装Java/","link":"","permalink":"http://yoursite.com/2019/08/31/Linux安装Java/","excerpt":"","text":"简述本篇文章使用的Linux系统为Ubuntu 16.04，JDK为1.8.0_152。 JDK下载JDK 1.8.0_152下载链接：https://pan.baidu.com/s/1AgiZ5DHnJjCVxBKPzdCddw提取码：v1ud 安装步骤 在/usr/local/目录下创建文件夹，通过Xftp工具将下载好的JDK上传上去(若没有Xftp工具，可浏览另一篇文章https://blog.csdn.net/qq_36525300/article/details/89216023下载) 1cd /usr/local 1mkdir java 解压缩 1tar -zxvf jdk-8u152-linux-x64.tar.gz 设置所有者 1chown -R root:root /usr/local/java/ 配置系统环境变量，添加路径配置 1vi /etc/environment 1234PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games: /usr/local/games&quot;export JAVA_HOME=/usr/local/java/jdk1.8.0_152export JRE_HOME=/usr/local/java/jdk1.8.0_152/jreexport CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib 配置用户环境变量 1vi /etc/profile 1234567891011121314151617181920212223242526272829if [ &quot;$PS1&quot; ]; then if [ &quot;$BASH&quot; ] &amp;&amp; [ &quot;$BASH&quot; != &quot;/bin/sh&quot; ]; then # The file bash.bashrc already sets the default PS1. # PS1=&apos;\\h:\\w\\$ &apos; if [ -f /etc/bash.bashrc ]; then . /etc/bash.bashrc fi else if [ &quot;`id -u`&quot; -eq 0 ]; then PS1=&apos;# &apos; else PS1=&apos;$ &apos; fi fifiexport JAVA_HOME=/usr/local/java/jdk1.8.0_152export JRE_HOME=/usr/local/java/jdk1.8.0_152/jreexport CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/libexport PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH:$HOME/binif [ -d /etc/profile.d ]; then for i in /etc/profile.d/*.sh; do if [ -r $i ]; then . $i fi done unset ifi 使配置的环境变量生效 1source /etc/profile 测试是否配置成功 1234root@Ubuntu:/usr/local/java# java -versionjava version &quot;1.8.0_152&quot;Java(TM) SE Runtime Environment (build 1.8.0_152-b16)Java HotSpot(TM) 64-Bit Server VM (build 25.152-b16, mixed mode)","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux用户组与文件权限管理","slug":"Linux用户组与文件权限管理","date":"2019-08-31T07:14:08.732Z","updated":"2019-08-31T07:34:29.534Z","comments":true,"path":"2019/08/31/Linux用户组与文件权限管理/","link":"","permalink":"http://yoursite.com/2019/08/31/Linux用户组与文件权限管理/","excerpt":"","text":"Linux用户组在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、文件所在组、其它组的概念 所有者 文件所在组 其它组 所有者 一般为文件的创建者，谁创建了该文件，谁就是该文件的所有者 用ls ‐ahl命令可以看到文件的所有者 可以使用chown 用户名 文件名来修改文件的所有者 文件所在组 当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组 用ls ‐al命令可以看到文件的所有组 也可以使用chgrp 组名 文件名来修改文件所在的组 其它组 除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组 用户账户普通用户 普通用户在系统上的任务是进行普通操作 超级管理员（root） 超级管理员在系统上的任务是对普通用户和整个系统进行管理。对系统具有绝对的控制权，能够对系统进行一切操作。用 root 表示，root 用户在系统中拥有最高权限，默认下 Ubuntu 用户的 root 用户是不能登录的。 Linux文件全限管理使用 ls 不带参数只显示文件名称，通过 ls –al 可以显示文件或者目录的权限信息。 ls -l 文件名 显示信息包括：文件类型 (d 目录，- 普通文件，l 链接文件)，文件权限，文件的用户，文件的所属组，文件的大小，文件的创建时间，文件的名称 1-rw-r--r-- 1 ronin ronin 675 Apr 12 8:38 filename -：普通文件rw-：说明用户 ronin 有读写权限，没有运行权限r–：表示用户组 ronin 只有读权限，没有写和运行的权限r–：其他用户只有读权限，没有写权限和运行的权限 全限指令chown是change owner的意思，主要的作用是改变文件或者目录的所有者，所有者包含用户和用户组 12chown [-R] 用户名称 文件或目录chown [-R] 用户名称 用户组名称 文件或目录 chmod改变访问权限 1chmod [who] [+ | - | =] [mode] 文件名 数字设定法数字设定法中数字表示的含义 0 表示没有任何权限 1 表示有可执行权限 = x 2 表示有可写权限 = w 4 表示有可读权限 = r 若要 rwx 属性则 4+2+1=7 若要 rw- 属性则 4+2=6 若要 r-x 属性则 4+1=5","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux软件包管理","slug":"Linux软件包管理","date":"2019-08-31T07:11:46.680Z","updated":"2019-08-31T07:13:58.113Z","comments":true,"path":"2019/08/31/Linux软件包管理/","link":"","permalink":"http://yoursite.com/2019/08/31/Linux软件包管理/","excerpt":"","text":"Advanced Packaging Tool（APT）Advanced Packaging Tool（apt）是Linux下的一款安装包管理工具。最初只有.tar.gz的打包文件，用户必须编译每个他想在GNU/Linux上运行的软件。用户们普遍认为系统很有必要提供一种方法来管理这些安装在机器上的软件包，当Debian诞生时，这样一个管理工具也就应运而生，它被命名为dpkg。从而著名的“package”概念第一次出现在GNU/Linux系统中，稍后Red Hat才决定开发自己的“rpm”包管理系统。 很快一个新的问题难倒了GNU/Linux制作者，他们需要一个快速、实用、高效的方法来安装软件包，当软件包更新时，这个工具应该能自动管理关联文件和维护已有配置文件。Debian再次率先解决了这个问题，APT(Advanced Packaging Tool）作为dpkg的前端诞生了。APT后来还被Conectiva改造用来管理rpm，并被其它Linux发行版本采用为它们的软件包管理工具。 APT由几个名字以“apt-”打头的程序组成。apt-get、apt-cache 和apt-cdrom是处理软件包的命令行工具。Linux命令—apt，也是其它用户前台程序的后端，如dselect 和aptitude。作为操作的一部分，APT使用一个文件列出可获得软件包的镜像站点地址，这个源文件就是/etc/apt/sources.list 修改Linux系统数据源(本文以Ubuntu 16.04为例)由于国内网络环境问题要把Ubuntu的数据源修改成国内的数据源 打开数据源 1vi /etc/apt/sources.list 编辑，将所有内容替换成 1234deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse 更新数据源 1apt-get update 常用的APT命令安装软件包： 1apt-get install packagename 删除软件包： 1apt-get remove packagename 更新软件包列表： 1apt-get update 搜索包 1apt-cache search package 获取包信息 1apt-cache show package 删除包及配置文件 1apt-get remove package --purge 清理无用的包 1apt-get clean &amp;&amp; apt-get autoclean 检查是否有损坏的依赖 1apt-get check","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux文件上传工具-Xftp","slug":"Linux文件上传工具-Xftp","date":"2019-08-31T06:51:05.408Z","updated":"2019-08-31T07:09:05.437Z","comments":true,"path":"2019/08/31/Linux文件上传工具-Xftp/","link":"","permalink":"http://yoursite.com/2019/08/31/Linux文件上传工具-Xftp/","excerpt":"","text":"XtpXftp是一个功能强大的SFTP、FTP 文件传输软件。使用了 Xftp 以后，MS Windows 用户能安全地在 UNIX/Linux 和 Windows PC 之间传输文件。Xftp 能同时适应初级用户和高级用户的需要。它采用了标准的 Windows 风格的向导，它简单的界面能与其他Windows 应用程序紧密地协同工作，此外它还为高级用户提供了众多强劲的功能特性。 分享链接Xftp工具下载链接：https://pan.baidu.com/s/1SikGGcfs1XEiyBm9Gpg8dg 提取码：wdhq 使用Xftp 通过XShell界面打开Xftp工具 找到要上传的文件，右键传输（双击也可以直接传输）","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Xftp","slug":"Xftp","permalink":"http://yoursite.com/tags/Xftp/"}]},{"title":"Linux远程控制管理工具-XShell","slug":"Linux远程控制管理工具-XShell","date":"2019-08-31T06:16:09.746Z","updated":"2019-08-31T06:27:18.461Z","comments":true,"path":"2019/08/31/Linux远程控制管理工具-XShell/","link":"","permalink":"http://yoursite.com/2019/08/31/Linux远程控制管理工具-XShell/","excerpt":"","text":"XShellXshell是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。Xshell 通过互联网到远程主机的安全连接以及它创新性的设计和特色帮助用户在复杂的网络环境中享受他们的工作。 Xshell可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。除此之外，其还有丰富的外观配色方案以及样式选择。 xshell是一个远程工具，很多linux服务器部署结束后，都不会在机器上接显示器，所以很多操作都是通过远程软件进行操作的。但是在实际工作过程中并不一定要用xshell工具，类似的远程工具还有很多，像ssh，vnc，tv等工具。使用这些远程工具可以极大的简化我们操作Linux。 分享链接XShell工具下载链接：https://pan.baidu.com/s/1IeMxm6xBVnmCB8-caOZytg提取码：a98y 使用XShell 开启虚拟机，通过ifconfig命令查看本机ip地址 打开安装号的xshell，新建连接 连接成功，查看ip地址跟虚拟机上相同","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"XShell","slug":"XShell","permalink":"http://yoursite.com/tags/XShell/"}]},{"title":"Linux文件压缩","slug":"Linux文件压缩","date":"2019-08-31T06:11:32.170Z","updated":"2019-08-31T06:15:57.954Z","comments":true,"path":"2019/08/31/Linux文件压缩/","link":"","permalink":"http://yoursite.com/2019/08/31/Linux文件压缩/","excerpt":"","text":"tartar是在Linux中使用得非常广泛的文档打包格式。它的好处就是消耗非常少的CPU和时间去打包文件，它仅仅只是一个打包工具，并不负责压缩。 参数 说明 -c 建立一个归档文件 -x 解开一个文件 -z 是否使用gzip压缩 -j 是否使用bzip2压缩 -v 压缩的过程中显示文件 -f 使用档名，参数f后要街上档名 -tf 查看归档文件里面的文件 打包格式如下： 1tar -cvf name.tar directory 解包格式如下： 1tar -xvf name.tar 上面这个解包命令将会将文档解开在当前目录。也可以用下面的这个命令来解包到指定的路径： 1tar -xvf name.tar -C directory tag.gzip这种格式是我使用得最多的压缩格式。它在压缩时不会占用太多CPU的，而且可以得到一个非常理想的压缩率。 参数 说明 -d 解压缩 -l 对每个压缩文件，显示压缩文件的大小，未压缩文件的大小，压缩比，未压缩文件的名字 -v 对每一个压缩和解压的文件，显示文件名和压缩比 -num 用数字num调整压缩的速度，-1或–fast表示最快压缩方法（低压缩比），-9或–best表示最慢压缩方法（高压缩比）。系统缺省值为6 压缩方式文件或目录： 1tar -zcvf name.tar.gz filename/directory 解压缩方式：​ 1tar -zxvf name.tar.gz 上面这个解包命令将会将文档解包在当前目录下面。当然，你也可以用下面的这个命令来指定解包的路径： 1tar -zxvf name.tar.gz -C directory tar.bzip2这种压缩格式是我们提到的所有方式中压缩率最好的。当然它比前面的两种方式要占用更多的CPU与时间。| 参数 | 说明 || :–: | :———————————————————-: || -d | 解压缩 || -z | 压缩参数 || -num | 用数字num调整压缩的速度，-1或–fast表示最快压缩方法（低压缩比），-9或–best表示最慢压缩方法（高压缩比）。系统缺省值为6 | 压缩文件或目录: 1tar -jcvf name.tar.bz2 filename/directory 解压缩方式： 1tar -jxvf name.tar.bz2 上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用下面的这个命令来指定解包的路径： 1tar -jxvf name.tar.bz2 -C directory","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux","slug":"Linux","date":"2019-08-31T06:02:49.397Z","updated":"2019-08-31T06:09:15.710Z","comments":true,"path":"2019/08/31/Linux/","link":"","permalink":"http://yoursite.com/2019/08/31/Linux/","excerpt":"","text":"Linux简介Linux 是一种自由和开放源码的类 UNIX 操作系统，使用 Linux 内核。目前存在着许多不同的 Linux 发行版，可安装在各种各样的电脑硬件设备，从手机、平板电脑、路由器和影音游戏控制台，到桌上型电脑，大型电脑和超级电脑。 Linux 是一个领先的操作系统，世界上运算最快的 10 台超级电脑运行的都是 Linux 操作系统。 Linux操作系统诞生于1991 年10 月5 日（这是第一次正式向外公布时间）。Linux存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。 严格来讲，Linux这个词本身只表示Linux内核，但实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU 工程各种工具和数据库的操作系统。 目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、TurboLinux、BluePoint、RedFlag、Xterm、SlackWare等。 Linux与Window区别 windows和linux的本质区别是核心的不同，windows是从早期的dos经过比尔盖茨开发来的，而linux是由李纳斯最早从unix上开发出来的。现在苹果笔记本使用的ios也是unix的分支，这也是苹果的ios和windows的本质不同，不论他们在应用层做的多像，核心的不同决定了这两个系统对软件安装和运行方式的不同。 windows的操作方式更简单，更封闭。安装应用和软件的时候用户只需要下一步下一步就可以。linux更开放，更透明。安装应用的时候你需要确认依赖关系是否安装正确，需要了解整个的安装过程。windows的思想是把大的软件和工程变的简单化，不断的填选项按下一步就可以。而linux的思想是不断通过小的操作和软件来完成大的工程和环境的部署。 windows是微软公司的产品，版权在微软公司。而linux遵循GNU，是开放免费的软件，红帽linux之所以收费，他收取的并不是linux软件的钱，而是红帽将linux经过重新编译后，提供运维服务，收取的是服务费用。 windows目前主要的应用应该是PC机，或者说是家用的普通办公电脑。linux更多的用于企业的服务器或者网络设备等。linux以安全稳定对硬件资源要求低等的众多优势赢得了更多企业用户的青睐。windows在企业应用也并不少，windows操作简单管理方便技术门槛低。目前服务器的windows系统版本已经更新到windows server 2012R2了，红帽的企业linux版本应该已经发布了RHEL7.0了 操作习惯的不同，windows主要是通过图形界面的方式和用户交互的，而使用linux的用户企业用户大部分时候是远程操作，用命令行的时候比较多，图形界面会占用比较多的资源不是和远程操作。现在windows也有命令行了，但是好像用的不多。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux目录结构和常用命令","slug":"Linux目录结构和常用命令","date":"2019-08-31T05:54:57.618Z","updated":"2019-08-31T06:11:28.689Z","comments":true,"path":"2019/08/31/Linux目录结构和常用命令/","link":"","permalink":"http://yoursite.com/2019/08/31/Linux目录结构和常用命令/","excerpt":"","text":"Linux目录结构 目录 说明 bin 存放二进制可执行文件(ls,cat,mkdir等) boot 存放用于系统引导时使用的各种文件 dev 用于存放设备文件 etc 存放系统配置文件 home 存放所有用户文件的根目录 lib 存放跟文件系统中的程序运行所需要的共享库及内核模块 mnt 系统管理员安装临时文件系统的安装点 opt 额外安装的可选应用程序包所放置的位置 proc 虚拟文件系统，存放当前内存的映射 root 超级用户的目录 sbin 存放二进制可执行文件，只有root才能访问到 tmp 用于存放各种临时文件 usr 用于存放系统应用程序 var 用于存放运行时需要改变数据的文件 最重要的三个目录： etc 目录 user 目录 var 目录 Linux常用命令 命令 说明 ll 管理员权限下查看所有文件 ls 普通用户权限查看文件 mkdir 创建目录，-p参数 多级目录生成 touch 生成一个空文件 echo 生成一个带内容的文件 cat 显示文本文件的内容 cp 复制文件或目录 rm 删除文件或目录 mv 移动文件或目录 find 在文件系统中查找指定文件 grep 在指定的文本文件中查找指定的字符串 tree 以树状图列出目录的内容 pwd 显示当前工作目录 ln 建立软链接（类似于快捷方式） more 分页显示文本文件的内容 head 显示文件的开头内容 tail 显示文件结尾的内容 Linux系统管理命令 命令 说明 stat 显示指定文件的相关信息，比ls命令显示内容更多 who 显示在线登陆的用户信息 hostname 显示主机名称 uname 显示系统信息 top 显示当前系统中消耗资源最多的进程 ps 显示瞬间的进程状态 du 显示指定的文件（目录）已使用的磁盘空间的总量 df 显示文件系统磁盘空间的使用情况 free 显示当前内存和交换空间的使用情况 ifconfig 显示网络接口信息 ping 测试网络的连通性 netstat 显示网络状态信息 clear 清屏 kill 杀死一个进程 Linux开关机命令shutdown 命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。 关机命令1shutdown -h now 重启命令1reboot 1shutdown -r now","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Spring Boot整合tk.MyBatis","slug":"SpringBoot整合tk.MyBatis","date":"2019-08-28T04:15:15.316Z","updated":"2019-09-03T06:27:21.518Z","comments":true,"path":"2019/08/28/SpringBoot整合tk.MyBatis/","link":"","permalink":"http://yoursite.com/2019/08/28/SpringBoot整合tk.MyBatis/","excerpt":"","text":"tk.mybaits 是基于Mybatis框架开发的一个工具，相较于 mybatis，tk.mybaits 可以不用书写 sql 语句，通过调用它提供的方法实现对单表的数据操作，极大地提高了项目开发效率。 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;com.ronin&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-tk-mybatis&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-tk-mybatis&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- tk.mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;javax.persistence-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- lombok插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml12345678910111213# server portserver: port: 8888# mybatismybatis: type-aliases-package: com.ronin.springboottkmybatis.entity mapper-locations: classpath:mapper/*.xmlspring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;&amp;characterEncoding=utf-8 username: root password: 123456 自定义Mapper接口使用 tk.mybaits 需要自定义一个 Mapper 接口，这个接口不能够被 SpringBootApplication 扫描到，否则会报错，需要创建一个平级的包存放。结构如下： 123456789101112package tk.mybatis.mapper;import tk.mybatis.mapper.common.Mapper;import tk.mybatis.mapper.common.MySqlMapper;/** * 该接口不能被扫描到，否则会出错 * @author 98 * @date 2019/8/26 15:24 */public interface MyMapper&lt;T&gt; extends Mapper&lt;T&gt;, MySqlMapper&lt;T&gt; &#123;&#125; Mapper和Mapper.xmlmapper 只需要继承我们自定义的接口就可以了，不需要写什么方法，tk.mybatis 默认提供了许多方法满足大部分开发需求 1234567891011121314package com.ronin.springboottkmybatis.mapper;import com.ronin.springboottkmybatis.entity.User;import org.springframework.stereotype.Repository;import tk.mybatis.mapper.MyMapper;/** * @author 98 * @date 2019/8/26 15:24 */@Repositorypublic interface UserMapper extends MyMapper&lt;User&gt; &#123;&#125; mapper.xml 也不需要写任何sql语句 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.ronin.springboottkmybatis.mapper.UserMapper\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.ronin.springboottkmybatis.entity.User\"&gt; &lt;result column=\"id\" jdbcType=\"INTEGER\" property=\"id\" /&gt; &lt;result column=\"userName\" jdbcType=\"VARCHAR\" property=\"username\" /&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 测试Resultful API 测试 123456789101112131415161718192021222324252627package com.ronin.springboottkmybatis.controller;import com.ronin.springboottkmybatis.entity.User;import com.ronin.springboottkmybatis.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;/** * @author 98 * @date 2019/8/26 15:24 */@RestControllerpublic class UserController &#123; @Autowired private UserService userService; @GetMapping(\"users\") public String getUsers()&#123; List&lt;User&gt; userList = userService.selectUsers(); return userList.toString(); &#125;&#125; 成功返回数据","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"Spring Boot整合MyBatis","slug":"SpringBoot整合MyBatis","date":"2019-08-27T01:42:36.667Z","updated":"2019-09-03T06:27:34.045Z","comments":true,"path":"2019/08/27/SpringBoot整合MyBatis/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringBoot整合MyBatis/","excerpt":"","text":"SpringBoot 提供了整合 MyBatis 的功能，通过简单的配置就能完成。 pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.ronin&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-mybatis&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-mybatis&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;javax.persistence-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置文件1234567891011121314151617181920server: port: 8080spring: datasource: username: root password: 123456 url: jdbc:mysql://localhost:3306/user?useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Drivermybatis: mapper-locations: classpath:mapper/*Mapper.xml type-aliases-package: com.ronin.springbootmybatis.entity#showSqllogging: level: com: example: mapper : debug 实体类123456789101112131415161718192021222324package com.ronin.springbootmybatis.entity;import lombok.Data;import javax.persistence.Column;import javax.persistence.Id;import javax.persistence.Table;/** * @Author: 98 * @Date: 2019-8-24 21:26 */@Data@Table(name=\"tb_user\")public class User &#123; @Id @Column(name = \"id\") private Integer id; @Column(name = \"username\") private String username;&#125; Mapper 和 Mapper.xml123456789101112131415161718package com.ronin.springbootmybatis.mapper;import com.ronin.springbootmybatis.entity.User;import org.apache.ibatis.annotations.Mapper;import org.springframework.stereotype.Repository;import java.util.List;/** * @Author: 98 * @Date: 2019-8-24 21:29 */@Repositorypublic interface UserMapper &#123; List&lt;User&gt; selectUsers();&#125; 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.ronin.springbootmybatis.mapper.UserMapper\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.ronin.springbootmybatis.entity.User\"&gt; &lt;result column=\"id\" jdbcType=\"INTEGER\" property=\"id\" /&gt; &lt;result column=\"userName\" jdbcType=\"VARCHAR\" property=\"username\" /&gt; &lt;/resultMap&gt; &lt;select id=\"selectUsers\" resultType=\"com.ronin.springbootmybatis.entity.User\"&gt; select * from tb_user &lt;/select&gt;&lt;/mapper&gt; Controller 和 Service123456789101112131415161718192021222324252627package com.ronin.springbootmybatis.controller;import com.ronin.springbootmybatis.entity.User;import com.ronin.springbootmybatis.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;/** * @Author: 98 * @Date: 2019-8-24 21:35 */@RestControllerpublic class UserController &#123; @Autowired private UserService userService; @GetMapping(\"users\") public String getUsers()&#123; List&lt;User&gt; userList = userService.selectUsers(); return userList.toString(); &#125;&#125; 12345678910111213141516171819202122232425package com.ronin.springbootmybatis.service.impl;import com.ronin.springbootmybatis.entity.User;import com.ronin.springbootmybatis.mapper.UserMapper;import com.ronin.springbootmybatis.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * @Author: 98 * @Date: 2019-8-24 21:33 */@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserMapper userMapper; @Override public List&lt;User&gt; selectUsers() &#123; return userMapper.selectUsers(); &#125;&#125; 测试我们通过请求 Restful API，通过返回值观察是否成功 请求返回值为数据库表中数据，整合 MyBatis 成功！！！！","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"Spring Boot整合Spring Data JPA","slug":"SpringBoot整合Spring Data JPA","date":"2019-08-27T01:39:06.512Z","updated":"2019-09-03T08:46:02.367Z","comments":true,"path":"2019/08/27/SpringBoot整合Spring Data JPA/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringBoot整合Spring Data JPA/","excerpt":"","text":"JPAJPA是Java Persistence API的简称，中文名Java持久层API，是SUN公司在JDK 5.0后提出的Java持久化规范，通过注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。 JPA的总体思想和现有Hibernate、TopLink、JDO等ORM框架大体一致。总的来说，JPA包括以下3方面的技术： ORM映射元数据 JPA支持XML和JDK5.0注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中 API 用来操作实体对象，执行CRUD操作，框架在后台替代我们完成所有的事情，开发者从繁琐的JDBC和SQL代码中解脱出来。 查询语言 这是持久化操作中很重要的一个方面，通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。 Spring Data JPA是Spring Data家族的一部分，可以轻松实现基于JPA的存储库。 此模块处理对基于JPA的数据访问层的增强支持。 Spring Data JPA提供的核心接口： Repository 接口 CrudRepository 接口 pagingAndSortingRepository 接口 JpaRepository 接口 JpaSpecificationExecutor 接口 pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.ronin&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-jpa&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-jpa&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml123456789101112131415161718192021# MySqlspring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/user?useUnicode=true&amp;&amp;characterEncoding=utf-8 username: root password: 123456# Spring Data JPA jpa: hibernate: ddl-auto: update show-sql: true# Thymeleaf thymeleaf: cache: false mode: HTML encoding: UTF-8 servlet: content-type: text/html 实体类123456789101112131415161718192021222324252627package com.ronin.springbootjpa.entity;import lombok.Data;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.Id;import javax.persistence.Table;import java.io.Serializable;/** * @Author: 98 * @Date: 2019-8-22 21:59 */@Data@Entity@Table(name = \"tb_user\")public class User implements Serializable &#123; @Id @Column(name = \"id\") private Integer id; @Column(name = \"username\") private String username;&#125; Mapper123456789101112package com.ronin.springbootjpa.mapper;import com.ronin.springbootjpa.entity.User;import org.springframework.data.jpa.repository.JpaRepository;/** * @Author: 98 * @Date: 2019-8-22 22:31 * JpaRepository&lt;User 实体类 ,Integer 主键类型 &gt; */public interface UserMapper extends JpaRepository&lt;User,Integer&gt; &#123;&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"Spring Boot热部署","slug":"SpringBoot热部署","date":"2019-08-27T01:37:48.167Z","updated":"2019-09-03T06:26:37.819Z","comments":true,"path":"2019/08/27/SpringBoot热部署/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringBoot热部署/","excerpt":"","text":"目前的Springboot，当发生了任何修改之后，必须关闭后再启动Application类才能够生效，显得略微麻烦。 Springboot提供了热部署的方式，当发现任何类发生了改变，马上通过JVM类加载的方式，加载最新的类到虚拟机中。这样就能够实现项目的热部署运行，修改少量的代码不需要重启项目就能看到效果 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.ronin&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-tools&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-tools&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 热部署插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"Spring Boot整合Thymeleaf模板引擎","slug":"SpringBoot整合Thymeleaf","date":"2019-08-27T01:13:35.725Z","updated":"2019-09-03T06:27:06.294Z","comments":true,"path":"2019/08/27/SpringBoot整合Thymeleaf/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringBoot整合Thymeleaf/","excerpt":"","text":"首先要了解一下什么是 Thymeleaf ！ Thymeleaf 官网：https://www.thymeleaf.org/ Thymeleaf 是 Web 和独立环境的现代服务器端 Java 模板引擎，能够处理HTML，XML，JavaScript，CSS 甚至纯文本。 Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。 Thymeleaf 的主要目标是提供一种优雅和高度可维护的创建模板的方式，在有网络和无网络的环境下皆可运行。为了实现这一点，它建立在自然模板的概念上，将其逻辑注入到模板文件中，不会影响模板被用作设计原型。这改善了设计的沟通，弥补了设计和开发团队之间的差距。 Thymeleaf 也从一开始就设计了Web标准 - 特别是 HTML5 - 允许您创建完全验证的模板，Spring Boot 官方推荐使用 thymeleaf 而不是 JSP。 pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ronin&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-thymeleaf&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;spring-boot-thymeleaf&lt;/name&gt; &lt;description&gt;&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt; &lt;artifactId&gt;nekohtml&lt;/artifactId&gt; &lt;version&gt;1.9.22&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml12345678spring: thymeleaf: #关闭页面缓存 cache: false mode: HTML encoding: UTF-8 servlet: content-type: text/html HTML页面12345678910&lt;!DOCTYPE html SYSTEM &quot;http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-spring4-4.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Hello Thymeleaf&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"Spring Boot入门案例","slug":"SpringBoot入门案例","date":"2019-08-27T00:53:34.733Z","updated":"2019-09-03T06:26:44.136Z","comments":true,"path":"2019/08/27/SpringBoot入门案例/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringBoot入门案例/","excerpt":"","text":"SpringBoot 随着动态语言的流行，为解决 java 开发繁重的配置，低下的开发效率，复杂的部署以及第三方技术集成难度大而诞生。它使用习惯优于配置的理念能够让项目快速的运行，相较于传统的ssm、ssh项目而言，少了许多麻烦的配置文件。 SpringBoot 可以以jar包的方式独立运行，并且在其内部内嵌了 tomcat、jetty 等容器，无须以 war 包形式部署项目。提供了一系列的 starter pom 来简化 Maven 的依赖加载。 IDEA 搭建 SpringBoot 项目 File =&gt; New =&gt; Project 这里选择 Spring Initializr 填写项目有关信息 选择 SpringBoot 提供的 starter 依赖，根据项目需要勾选 项目存放路径 这样一个 SpringBoot 项目就创建成功了，默认的 SpringBoot 项目目录如下，跟 Maven 项目类似： SpringbootDemoApplicaiton ： 整个项目的启动类，通过运行其中的 main 方法快速启动项目 application.properties ：整个项目的配置文件，SpringBoot基于习惯优于配置理念，相较ssm等项目少了许多配置，除了可以使用properties格式，也可以使用 YAML 格式 templates ：项目默认的页面存放文件夹 static ：项目默认静态资源存放文件夹 默认的 pom.xml 文件12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;com.ronin&lt;/groupId&gt; &lt;artifactId&gt;springboot-demo&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; SpringBoot 项目都需要添加一个父级依赖，spring-boot-starter-parent 是一个特殊的 starter，是 spring 官方提供的，里面包含了众多第三方技术的jar包 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt; SpringBoot 的编译插件 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"SpringMVC文件上传","slug":"SpringMVC文件上传","date":"2019-08-27T00:46:26.673Z","updated":"2019-08-30T05:21:54.096Z","comments":true,"path":"2019/08/27/SpringMVC文件上传/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringMVC文件上传/","excerpt":"","text":"SpringMVC 为上传文件提供了良好的支持，SpringMVC 通过 MultipartResolver (Multipart 解析器) 处理的，它是一个接口，有两个实现类:​ CommonsMultipartResolver：依赖于 Apache 下的 jakarta Common FileUpload 项目解析 Multipart 请求，可以在 Spring 的各个版本中使用，只是它要依赖于第三方包才得以实现 StandardServletMultipartResolver：Spring 3.1 版本后的产物，它依赖于 Servlet 3.0 或者更高版本的实现，它不用依赖第三包 前台页面提交表单时，需要设置 enctype=”multipart/form-data” 多段式提交 12345678&lt;form class=\"form-horizontal form-border\" action=\"/upload\" method=\"post\" id=\"form\" enctype=\"multipart/form-data\"&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"col-sm-2\"&gt;&lt;/div&gt; &lt;div class=\"col-sm-8\"&gt; &lt;input type=\"file\" name=\"dropzFile\"/&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; SpringMVC.xml12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd\"&gt; &lt;!-- 上传文件拦截，设置最大上传文件大小 10M = 10*1024*1024(B) = 10485760 bytes --&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"maxUploadSize\" value=\"10485760\"/&gt; &lt;property name=\"defaultEncoding\" value=\"utf-8\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 后台代码12345678910111213141516171819202122232425262728293031/** * 文件上传 * @param dropzFile * @return */ @RequestMapping(value = \"upload\",method = RequestMethod.POST) public Map&lt;String,Object&gt; DropZone(MultipartFile dropzFile,HttpServletRequest request)&#123; //获取文件名 String fileName = dropzFile.getOriginalFilename(); //获取文件后缀名 String fileSuffix = fileName.substring(fileName.lastIndexOf(\".\")); //获取文件上传文件夹路径 String filePath = request.getSession().getServletContext().getRealPath(Const.UPLOAD_PATH); //判断文件夹是否存在,不存在就创建文件夹 File file = new File(filePath); if(! file.exists())&#123; file.mkdirs(); &#125; //UUID替换文件名 String filePrefix = UUID.randomUUID().toString(); file = new File(filePath,filePrefix+fileSuffix); //上传文件 try &#123; dropzFile.transferTo(file); &#125; catch (IOException e) &#123; logger.error(\"文件上传出错！！！\"); &#125; return \"index\"; &#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"SpringMVC拦截器","slug":"SpringMVC拦截器","date":"2019-08-27T00:45:35.201Z","updated":"2019-08-30T05:21:39.776Z","comments":true,"path":"2019/08/27/SpringMVC拦截器/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringMVC拦截器/","excerpt":"","text":"拦截器是 SpringMVC 中一个强大的控件，它可以在进入处理器之前做一些操作，或者在处理器完成后进行操作，甚至是在渲染视图后进行操作。我们可以自己定义一个拦截器，Spring 要求处理器的拦截器都需要实现 org.springframework.web.servlet.HandlerInterceptor 接口，我们来看看该接口的源码： 12345678910111213141516public interface HandlerInterceptor &#123; default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true; &#125; default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123; &#125; default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123; &#125;&#125; HandlerInterceptor 接口中定义了三个方法： preHandle 方法：在处理器之前执行的前置方法，SpringMVC 可以在进入处理器之前处理一些方法，方法默认返回一个 Boolean 值，true 代表放行，false 代表拦截 postHandle 方法：在处理器之后执行的后置方法，处理器的逻辑完成后运行它 afterCompletion 方法：无论是否产生异常都会在渲染视图后执行的方法 拦截器的定义SpringMVC 配置拦截器有两种方式，一种是xml配置，一种是java配置，Spring4之后推荐使用java配置 xml配置 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.5.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.5.xsd \"&gt; &lt;!--配置拦截器, 多个拦截器,顺序执行 --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- /**的意思是所有文件夹及里面的子文件夹 /*是所有文件夹，不含子文件夹 /是web项目的根目录 --&gt; &lt;mvc:mapping path=\"/**\" /&gt; &lt;!-- 需排除拦截的地址 --&gt; &lt;!-- &lt;mvc:exclude-mapping path=\"/userController/login\"/&gt; --&gt; &lt;bean id=\"ManagerInterceptor\" class=\"com.mall.Interceptor.ManagerInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/admin/details\"/&gt; &lt;bean id=\"OrderInterceptor\" class=\"com.mall.Interceptor.OrderInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/shop/personal\"/&gt; &lt;bean id=\"UserInterceptor\" class=\"com.mall.Interceptor.UserInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;&lt;/beans&gt; 这里的 xml 配置中是配置了三个拦截器，bean 节点中的 class 属性值为对应的拦截器全类包路径 java配置 定义一个拦截器实现 HandleInterceptor 接口 123456789101112131415161718192021/** * @Author: 98 * @Date: 2019-8-1 16:41 */public class WebAdminInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 创建一个java类，类上使用 @Configuration 表明这是个配置类 12345678910111213141516171819/** 1. @Author: 98 2. @Date: 2019-8-1 16:52 */@Configurationpublic class InterceptorConfig implements WebMvcConfigurer &#123; @Bean WebAdminInterceptor webAdminInterceptor()&#123; return new WebAdminInterceptor(); &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(webAdminInterceptor()) .addPathPatterns(\"/**\") .excludePathPatterns(\"/static\"); &#125;&#125; 拦截器的执行顺序拦截器的执行顺序可以分成多种情况： 单个拦截器 执行的顺序为：preHandle =&gt; postHandle =&gt; afterCompletion （前提 preHandle 方法返回true） 多个拦截器，preHandle 方法均返回 true 执行的顺序为： preHandle1preHandle2preHandle3 postHandle3 postHandle2 postHandle1 afterCompletion3 afterCompletion2 afterCompletion1 多个拦截器，其中一个或多个拦截器 preHandle 方法返回false，这里我们设置三个拦截器，将第二个拦截器的前置方法返回false preHandle1preHandle2afterCompletion1 当其中的一个 preHandle 方法返回为false后，按照配置的顺序，后面的 preHandle 方法都不会运行，而控制器和所有的后置方法 postHandle 也不会再运行。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"SpringMVC执行流程","slug":"SpringMVC执行流程","date":"2019-08-27T00:43:17.470Z","updated":"2019-08-30T05:22:00.971Z","comments":true,"path":"2019/08/27/SpringMVC执行流程/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringMVC执行流程/","excerpt":"","text":"SpringMVC请求流程SpringMVC中处理请求最为重要的组件就是：DispatcherServlet，在处理用户请求时，SpringMVC底层的请求流程如下图： 用户端发起请求到后台服务器，请求被前端控制器（DispatcherServlet）拦截 前端控制器拦截到请求后，将请求信息交给处理器映射器（HandlerMapping）查找Handler 处理器映射器向前端控制器返回处理器（Handler） 前端控制器得到处理器后调用处理器适配器（HandlerAdapter）执行Handler 处理器适配器执行Handler Handler根据路径找到对应的Controller方法执行完成后给适配器返回模型和视图对象（ModelAndView） 处理器适配器向前端控制器返回ModelAndView 前端控制器请求视图解析器（ViewResolver）进行视图解析 视图解析器向前端控制器返回view 前端控制器进行视图渲染 前端控制器向用户响应结果 组件说明每一次用户端请求SpringMVC都会执行一遍这样的流程，在这一流程中存在几个SpringMVC中重要的组件： DispatcherServlet （前端控制器） 用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。 HandlerMapping （处理器映射器） HandlerMapping负责根据用户请求url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 HandlerAdapter （处理器适配器） 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 ViewResolver （视图解析器） View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"SpringMVC入门案例","slug":"SpringMVC入门案例","date":"2019-08-27T00:42:09.463Z","updated":"2019-08-30T05:21:45.058Z","comments":true,"path":"2019/08/27/SpringMVC入门案例/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringMVC入门案例/","excerpt":"","text":"web.xml配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app version=\"3.0\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"&gt; &lt;!-- Spring配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/spring/spring-config*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Spring监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 字符集过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;Encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;Encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 配置系统变量 contextConfigLocation，SpringMVC会根据配置的路径加载配置文件 ContextLoaderListener 实现了接口 ServletContextListener，监听项目启动，用于Spring IoC容器初始化 配置 DispatcherServlet 我们给了一个 contextConfigLocation，SpringMVC会到这个路径下读取配置文件，如果不配置这个属性，SpringMVC会默认读取 /WEB-INF/dispatcher-servlet.xml 文件，没读取到会抛出异常 DispatcherServlet 拦截请求的后缀有多种方式：1. *.do 2. *.action 3. / 4. / * springmvc.xml12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.5.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.5.xsd\"&gt; &lt;!-- 扫描注解 --&gt; &lt;context:component-scan base-package=\"com.ronin.blog.controller\"/&gt; &lt;!-- 配置注解驱动 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 静态资源放行 --&gt; &lt;mvc:resources mapping=\"/static/**\" location=\"/static/\" /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 视图解析器中配置返回视图的前缀和后缀，SpringMVC根据返回的值拼接后到对应的路径下查找 Controller完成了配置文件的书写，在 /WEB-INF/jsp/ 路径下创建一个 index.jsp 页面 12345678910111213141516@Controllerpublic class ArticleController &#123; /** * 页面跳转 * @return */ @RequestMapping(value = \"index\",method = RequestMethod.GET) public ModelAndView index()&#123; //创建模型视图对象 ModelAndView mav = new ModelAndView(); //添加视图 mav.setViewName(\"index\"); //返回模型和视图 return mav; &#125;&#125; 启动项目，访问对应的请求路径，实现页面跳转！","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"SpringMVC","slug":"SpringMVC","date":"2019-08-27T00:40:35.905Z","updated":"2019-08-30T05:21:31.818Z","comments":true,"path":"2019/08/27/SpringMVC/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringMVC/","excerpt":"","text":"Spring Web MVC是基于Servlet API构建的原始Web框架，从一开始就包含在Spring Framework中。正式名称“Spring Web MVC”来自其源模块（spring-webmvc）的名称，但它通常被称为“Spring MVC”。 与Spring Web MVC并行，Spring Framework 5.0引入了一个反应堆栈Web框架，其名称“Spring WebFlux”也基于其源模块（spring-webflux）。 MVC设计概述MVC 设计不仅限于 Java Web 应用，设计的根本原因在于解耦各个模块，早期的 Java Web 开发中，主要是 JSP+Java Bean 模式，我们称之为 Model1 时代。可以很容易看出，Model1时代中 JSP 和 Java Bean 之间的耦合十分严重，Java 和 Html 也耦合在一起，很快 Model1 时代就被 Servlet+JSP+Java Bean 替代了。相对于 Model1 多了一个 Servlet 组件，Servlet 组件作为主要的控制器，用来处理浏览器发来的请求，这样的模式就成为 MVC 模式，Servlet 为控制层（Controller），JSP 为视图层（view），Java Bean 为模型层（Modal）。 SpringMVC 架构为解决持久层中一直未处理好的数据库事务的编程，又为了迎合 NoSQL 的强势崛起，Spring MVC 给出了方案：传统的模型层被拆分为了业务层(Service)和数据访问层（DAO,Data Access Object）。 在 Service 下可以通过 Spring 的声明式事务操作数据访问层，而在业务层上还允许我们访问 NoSQL ，这样就能够满足异军突起的 NoSQL 的使用了，它可以大大提高互联网系统的性能。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring事务","slug":"Spring事务","date":"2019-07-21T10:14:26.844Z","updated":"2019-08-30T05:22:11.856Z","comments":true,"path":"2019/07/21/Spring事务/","link":"","permalink":"http://yoursite.com/2019/07/21/Spring事务/","excerpt":"","text":"事务是指逻辑上的一组操作，这组操作要么全部成功，要么就一同失败。 事务的四大特性： 原子性：事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都失败； 隔离性：当多个用户并发访问数据库时，数据库为每一个用户开启的事务，不被其他事务的操作所干扰，多个并发事务之间要相互隔离； 一致性：事务操作前后数据必须处于一致状态； 持久性：一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便在数据库系统遇到故障的情况下也不会丢失事物的操作。 Spring事务的隔离级别事务隔离级别，就是为了解决上面几种问题而诞生的。为什么要有事务隔离级别，因为事务隔离级别越高，在并发下会产生的问题就越少，但同时付出的性能消耗也将越大，因此很多时候必须在并发性和性能之间做一个权衡。所以设立了几种事务隔离级别，以便让不同的项目可以根据自己项目的并发情况选择合适的事务隔离级别，对于在事务隔离级别之外会产生的并发问题，在代码中做补偿。 事务隔离级别有4种，但是Spring会提供给用户5种: DEFAULT 默认隔离级别，每种数据库支持的事务隔离级别不一样，如果Spring配置事务时将isolation设置为这个值的话，那么将使用底层数据库的默认事务隔离级别。顺便说一句，如果使用的MySQL，可以使用”select @@tx_isolation”来查看默认的事务隔离级别 READ_UNCOMMITTED 读未提交，即能够读取到没有被提交的数据，所以很明显这个级别的隔离机制无法解决脏读、不可重复读、幻读中的任何一种，因此很少使用 READ_COMMITED 读已提交，即能够读到那些已经提交的数据，自然能够防止脏读，但是无法限制不可重复读和幻读 REPEATABLE_READ 重复读取，即在数据读出来之后加锁，类似”select * from XXX for update”，明确数据读取出来就是为了更新用的，所以要加一把锁，防止别人修改它。REPEATABLE_READ的意思也类似，读取了一条数据，这个事务不结束，别的事务就不可以改这条记录，这样就解决了脏读、不可重复读的问题，但是幻读的问题还是无法解决 SERLALIZABLE 串行化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务，这样就解决了脏读、不可重复读和幻读的问题了 Spring事务传播行为 传播行为 含义 备注 REQUIRED 当方法调用时，如果不存在当前事务，那么就创建事务；如果当前方法已经存在事务，就沿用之前的事务 这个是Spring默认的传播行为 SUPPORTS 当方法调用时，如果不存在当前事务，那么就不启用事务；如果当前方法已经存在事务，就沿用之前的事务 - MANDATORY 方法必须在事务内运行 如果不存在当前事务，抛出异常 REQUIRES_NEW 无论是否存在当前事务，方法都会在新的事务中运行 事务管理器会打开新的事务运行该方法 NOT_SUPPORTED 不支持事务，如果不存在当前事务也不会创建事务；如果存在当前事务就挂起它，知道方法结束后才恢复当前事务 适用于不需要事务的SQL NEVER 不支持事务，只有在没有事务的环境中才能运行它 如果方法存在当前事务，抛出异常 NESTED 嵌套事务，调用方法如果抛出异常只回滚自己内部执行的SQL，而不回滚主方法的SQL 它的实现存在两种情况，如果当前数据库支持保存点，它就会在当前事务上使用保存点技术；如果发生异常则将方法内执行的SQL回滚到保存点上，不是全部回滚，否则就等同于REQUIRES_NEW创建新的事务运行方法代码 XML配置事务1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 配置数据源 --&gt;&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt;&lt;/bean&gt;&lt;!-- 配置事务 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt; &lt;!-- 配置事务通知 --&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;!-- 以方法为单位,指定方法应用什么事务属性 isolation:隔离级别 propagation:传播行为 read-only:是否只读 --&gt; &lt;tx:method name=\"save*\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\" /&gt; &lt;tx:method name=\"persist*\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\" /&gt; &lt;tx:method name=\"update*\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\" /&gt; &lt;tx:method name=\"modify*\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\" /&gt; &lt;tx:method name=\"delete*\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\" /&gt; &lt;tx:method name=\"remove*\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\" /&gt; &lt;tx:method name=\"get*\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"true\" /&gt; &lt;tx:method name=\"find*\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"true\" /&gt; &lt;tx:method name=\"transfer\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\" /&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 配置织入 --&gt;&lt;aop:config&gt; &lt;!-- 配置切点 --&gt; &lt;aop:pointcut expression=\"execution(* service.*ServiceImpl.*(..))\" id=\"txPc\"/&gt; &lt;!-- 配置切面：通知+切点 --&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPc\"/&gt;&lt;/aop:config&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring 整合 MyBatis","slug":"Spring 整合 MyBatis","date":"2019-07-21T10:12:18.183Z","updated":"2019-08-30T05:20:15.896Z","comments":true,"path":"2019/07/21/Spring 整合 MyBatis/","link":"","permalink":"http://yoursite.com/2019/07/21/Spring 整合 MyBatis/","excerpt":"","text":"Spring配置文件spring-config-druid.xml 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd\"&gt; &lt;!-- 配置文件 --&gt; &lt;context:property-placeholder location=\"classpath:config/jdbc.properties\"/&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/bean&gt;&lt;/beans&gt; spring-config-mybatis.xml 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd\"&gt; &lt;!-- SqlSessionFactory --&gt; &lt;bean id=\"SqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!-- SqlMapConfig文件 --&gt; &lt;property name=\"configLocation\" value=\"classpath:config/sqlMapConfig.xml\"/&gt; &lt;!-- 映射文件 --&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"/&gt; &lt;!-- 设置别名 --&gt; &lt;property name=\"typeAliasesPackage\" value=\" 实体类全路径包名 \"/&gt; &lt;/bean&gt; &lt;!-- 扫描Mapper --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\" Mapper映射文件全包名 \"/&gt; &lt;/bean&gt;&lt;/beans&gt; sqlMapConfig.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 全局参数 --&gt; &lt;settings&gt; &lt;!-- 打印 SQL 语句 --&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\" /&gt; &lt;!-- 使全局的映射器启用或禁用缓存。 --&gt; &lt;setting name=\"cacheEnabled\" value=\"false\"/&gt; &lt;!-- 全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载。 --&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!-- 当启用时，有延迟加载属性的对象在被调用时将会完全加载任意属性。否则，每种属性将会按需要加载。 --&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"true\"/&gt; &lt;!-- 是否允许单条 SQL 返回多个数据集 (取决于驱动的兼容性) default:true --&gt; &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt; &lt;!-- 是否可以使用列的别名 (取决于驱动的兼容性) default:true --&gt; &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt; &lt;!-- 允许 JDBC 生成主键。需要驱动器支持。如果设为了 true，这个设置将强制使用被生成的主键，有一些驱动器不兼容不过仍然可以执行。 default:false --&gt; &lt;setting name=\"useGeneratedKeys\" value=\"false\"/&gt; &lt;!-- 指定 MyBatis 如何自动映射 数据基表的列 NONE：不映射 PARTIAL：部分 FULL:全部 --&gt; &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt; &lt;!-- 这是默认的执行类型 （SIMPLE: 简单； REUSE: 执行器可能重复使用prepared statements语句；BATCH: 执行器可以重复执行语句和批量更新） --&gt; &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/&gt; &lt;!-- 使用驼峰命名法转换字段。 --&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;!-- 设置本地缓存范围 session:就会有数据的共享 statement:语句范围 (这样就不会有数据的共享 ) defalut:session --&gt; &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt; &lt;!-- 设置 JDBC 类型为空时,某些驱动程序 要指定值, default:OTHER，插入空值时不需要指定类型 --&gt; &lt;setting name=\"jdbcTypeForNull\" value=\"NULL\"/&gt; &lt;/settings&gt; &lt;/configuration&gt; web.xml 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!-- Spring配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/spring/spring-config*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Spring监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring JdbcTemplate","slug":"Spring JdbcTemplate","date":"2019-07-21T10:11:23.968Z","updated":"2019-08-30T05:19:47.678Z","comments":true,"path":"2019/07/21/Spring JdbcTemplate/","link":"","permalink":"http://yoursite.com/2019/07/21/Spring JdbcTemplate/","excerpt":"","text":"JdbcTemplate是Spring框架自带的对JDBC操作的封装，目的是提供统一的模板方法使对数据库的操作更加方便、友好，效率也不错。但是功能还是不够强大（比如不支持级联属性），在实际应用中还需要和hibernate、mybaties等框架混合使用。 传统JDBC弊端传统的 JDBC 即使是执行一条简单的 SQL 过程都不简单，先是打开数据库连接执行 SQL，组装结果，最后关闭资源，其中包含了太多的 try…catch…finally… 语句，造成代码泛滥，数据库资源的打开、关闭都是定性的，事务提交回滚等等都是比较固定的模式，导致代码的可读性和可维护性急剧降低。 JdbcTemplate配置数据库连接配置文件,db.properties 1234jdbc.username=rootjdbc.password=123456jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/test XML配置，第三方连接池使用阿里巴巴的 Druid 123456789101112131415&lt;!-- 配置文件 --&gt;&lt;context:property-placeholder location=\"classpath:config/jdbc.properties\"/&gt;&lt;!-- 数据库连接池 --&gt;&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt;&lt;/bean&gt;&lt;!-- 配置JdbcTemplate实例 --&gt;&lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt; 测试方法 1234567//启动IoC容器ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\");//获取IoC容器中JdbcTemplate实例JdbcTemplate jdbcTemplate=(JdbcTemplate) ctx.getBean(\"jdbcTemplate\");String sql=\"insert into user (name,age) values (?,?)\";int count= jdbcTemplate.update(sql, new Object[]&#123;\"tom\",3&#125;);System.out.println(count); JdbcTemplate的增删改查12345678910111213141516public static void main(String[] args)&#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //获取IoC容器中JdbcTemplate实例 JdbcTemplate jdbcTemplate=(JdbcTemplate) ctx.getBean(\"jdbcTemplate\"); JdbcTemplate test = new JdbcTemplate(); //实例化对象 User user = new User(); user.setId(1L); user.setName(\"tom\"); user.setAge(20); //执行操作 test.insertUser(jdbcTemplate,user); List&lt;User&gt; UserList = test.findUser(jdbcTemplate); test.updateUser(jdbcTemplate,user); test.deleteUser(1L);&#125; 1234567/** ** 插入方法**/public int insertUser(JdbcTemplate jdbcTemplate,User user)&#123; String sql = \"insert into t_user(id,name,age) values(?,?,?)\"; return jdbcTemplate.update(sql,user.getId(),user.getName(),user.getAge());&#125; 1234567/** ** 删除方法**/public int deletetUser(JdbcTemplate jdbcTemplate,Long id)&#123; String sql = \"delete from t_user where id = ?\"; return jdbcTemplate.update(sql,id);&#125; 1234567/** ** 更新方法**/public int updateUser(JdbcTemplate jdbcTemplate,User user)&#123; String sql = \"update t_user set name = ?,age = ? where id = ?\"; return jdbcTemplate.update(sql,user.getName(),user.getAge(),user.getId());&#125; 123456789101112/** ** 查询用户列表**/public List&lt;User&gt; findUser(JdbcTemplate jdbcTemplate,User user)&#123; String sql = \"select * from t_user\"; RowMapper&lt;User&gt; rowMapper = new BeanPropertyRowMapper&lt;User&gt;(User.class); List&lt;User&gt; list= jdbcTemplate.query(sql, rowMapper); for (User user : list) &#123; System.out.println(user); &#125; return list;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring AOP","slug":"Spring AOP","date":"2019-07-21T10:10:43.034Z","updated":"2019-08-30T05:18:43.653Z","comments":true,"path":"2019/07/21/Spring AOP/","link":"","permalink":"http://yoursite.com/2019/07/21/Spring AOP/","excerpt":"","text":"AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 AOP 技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。 AOP 使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 AOP术语 切面（Aspect） 类是对物体特征的抽象，切面就是对横切关注点的抽象，例如数据库的事务贯穿了整个代码层面，这就是一个切面，它可以定义后面需要的各类通知、切点和引入内容。 通知（Advice） 通知是切面开启后，切面的方法。它根据在代理对象真实方法调用前后的顺序和逻辑区分。 前置通知（before）：在动态代理反射原有对象方法或者执行环绕通知前执行的通知功能。 后置通知（after）：在动态代理反射原有对象方法或者执行环绕通知后执行的通知功能。不论是否抛出异常都会执行。 返回通知（afterReturning）：在动态代理反射原有对象方法或者执行环绕通知后正常返回（无异常）执行的通知功能。 异常通知（afterThrowing）：在动态代理反射原有对象方法或者执行环绕通知产生异常后执行的通知功能。 环绕通知（around）：在动态代理中，它可以取代当前被拦截对象的方法，提供回调原有被拦截对象的方法。 引入（Introduction）引入允许我们在现有的类里添加自定义的类和方法。 切点（Pointcut）这是一个告诉 Spring AOP 在什么时候启动拦截并织入对应的流程中，因为并不是所有的开发都需要启动 AOP，它往往通过切点表达式进行限定。 连接点（Join point）连接点对应的是具体需要拦截的东西，比如通过切点的切点表达式去判断哪个方法是连接点，从而织入对应的通知。 织入（Weaving）织入是一个生成代理对象并将切面内容放入到流程中的过程。实际代理的方法分为动态代理和静态代理。 XML配置开发Spring AOPSpring 提供了两种方式配置 AOP，注解配置和XML文件配置，在这我们只介绍XML文件配置方式。| AOP配置元素 | 用途 | 备注 || ——————- | ——————————– | —————————- || aop:advisor | 定义AOP的通知器 | 一种较老的方式，目前很少使用 || aop:aspect | 定义一个切面 | / || aop:before | 定义前置通知 | / || aop:after | 定义后置通知 | / || aop:around | 定义环绕方式 | / || aop:after-returning | 定义返回通知 | / || aop:after-throwing | 定义异常通知 | / || aop:config | 顶层的AOP配置元素 | AOP的配置根节点 || aop:declare-parents | 给通知引入新的额外接口，增强功能 | / || aop:pointcut | 定义切点 | / | 简单的 AOP 案例：定义接口 1234public interface PhoneService&#123; public void call(); public void send_sms();&#125; 实现类 12345678public class PhoneServiceImpl&#123; public void call()&#123; System.out.println(\"***打电话\"); &#125; public void send_sms()&#123; System.out.println(\"***发短信\"); &#125;&#125; 通知类 12345678pulbic class MyAdvice&#123; public void beforeLog()&#123; System.out.println(“准备执行移动业务======”); &#125; public void afterLog()&#123; System.out.println(\"本次业务需要10元======\"); &#125;&#125; XML配置 1234567891011&lt;bean id=\"phone\" class=\"com.etc.service.impl.PhoneServiceImpl\"&gt;&lt;/bean&gt;&lt;bean id=\"myAdvice\" class=\"com.etc.common.MyAdvice\"&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;!—配置切点，即需要将方法织入的位置--&gt; &lt;aop:pointcut id=\"pc\" expression=“execution(* com.etc.service.impl.PhoneServiceImpl.*(...))”/&gt; &lt;!—配置切面feeAdvice是Bean的id --&gt; &lt;aop:aspect ref=\"myAdvice\"&gt; &lt;aop:before method=\"beforLog\" pointcut-ref=\"pc\"/&gt; &lt;aop:after method=\"afterLog\" pointcut-ref=\"pc\"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; &lt; aop:aspect &gt;：用于定义切面类&lt; aop:before &gt;：定义前置通知&lt; aop:after &gt;：定义后置通知&lt; aop:after-throwing &gt;：定义异常通知&lt; aop:after-retruning &gt;：定义返回通知","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring 装配 Bean","slug":"Spring 装配 Bean","date":"2019-07-21T10:10:04.129Z","updated":"2019-08-30T05:20:44.570Z","comments":true,"path":"2019/07/21/Spring 装配 Bean/","link":"","permalink":"http://yoursite.com/2019/07/21/Spring 装配 Bean/","excerpt":"","text":"如何将自己开发的 Bean 装配到 Spring IOC 容器中，大部分情况下我们可以使用 ApplicationContext 的具体实现类，因为对应的 Spring IOC 容器功能强大，在 Spring 当中提供了3中方式进行配置： XML配置 Java的接口和类中实现配置 隐式Bean的发现机制和自动装配原则 XML配置Bean12345678910&lt;bean id=\"source\" class=\"com.ssm.entity.Source\"&gt; &lt;property name=\"fruit\" value=\"橙汁\"/&gt; &lt;property name=\"sugar\" value=\"少糖\"/&gt; &lt;property name=\"size\" value=\"大杯\"/&gt;&lt;/bean&gt;&lt;bean id=\"juiceMaker\" class=\"com.ssm.entity.JuiceMaker\"&gt; &lt;property name=\"beverageShop\" value=\"贡茶\"/&gt; &lt;property name=\"source\" ref=\"source\"/&gt;&lt;/bean&gt; id 属性是 Spring 找到这个 Bean 的编号，id 不是必须的属性，如果没有声明 id，Spring 会采用“全限类名#{number}”的格式生成编号。class 是一个类的全限定名。property 元素是定义类的属性，name 属性定义属性名称，value 定义值。ref 属性是引用对应的 Bean 的 id。 注解配置Bean在 Spring3.0 之后已经不再推荐使用 XML 的方式装配 Bean，更多时候推荐使用注解配置，使用注解可以大量减少 XML 的配置代码，注解既能实现 XML 的功能，也提供了自动装配的功能，满足了“约定优于配置”的开发原则。 Spring 中提供了两种方式让 Spring IOC 容器发现 Bean： 组件扫描：通过定义资源的方式，让 Spring IOC 容器扫描对应的包，从而把 Bean 装配进来。 自动装配：通过注解定义，使得一些依赖关系可以通过注解完成。 @Component12345678@Component(value=\"user\")public class User&#123; @Value(\"1\") private Long id; @Value(\"user_name\") private String userName; ................&#125; @Component 注解代表 Spring IOC 会把这个类扫描生成 Bean 实例，其中 value 属性的值等同于 XML 方式中的 id，value 值不写 Spring IOC 容器就默认首字母为小写的类名替代。@Value 代表的是值的注入。 123@ComponentScanpublic class PojoConfig&#123;&#125; 这时候需要在同一个包下创建一个 Java Config 告诉 Spring IOC 容器到哪里去扫描对象，@ComponentScan 代表进行扫描，默认是扫描当前包下的路径。它有两个配置选项，第一个是 basePackages，第二个是 basePackageClasses。 @Autowired在 Spring IOC 容器中，Spring 是先完成 Bean 的定义和生成，然后寻找需要注入的资源，当 Spring 生成所有的 Bean 后，如果发现了这个注解，它就会在 Bean 中查找对应的类型注入。 123public interface UserService&#123; public void UserInfo();&#125; 1234567@Controllerpublic class UserController&#123; @Autowired private UserService userService; ...................&#125; 这里我们定义一个 User 的接口，在 Controller 层通过 @Autowired 注解注入，Spring 在扫描到这个注解后会自动寻找对应的类型注入。 有时，IOC 容器会寻找类型失败，默认情况会抛出异常，可以通过 @Autowired(required = false) 将其设置为不一定成功注入，当 IOC 容器没有找到对应的类型时，不会抛出异常。 在少部分情况下，一个接口会有多个实现类，使用 @Autowired 自动装配时可能会出现 IOC 容器不知道使用哪个实现类装配的问题，导致注入失败，原因是 IOC 容器通过类型（by type）获取 Bean，多个实现类导致 Bean 不唯一，可以通过 @Primary（首要注入）注解和 @Qualifier（采用名称查找）注解解决这类问题。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring 依赖注入（DI）","slug":"Spring 依赖注入（DI）","date":"2019-07-21T10:09:24.955Z","updated":"2019-08-30T05:20:08.474Z","comments":true,"path":"2019/07/21/Spring 依赖注入（DI）/","link":"","permalink":"http://yoursite.com/2019/07/21/Spring 依赖注入（DI）/","excerpt":"","text":"在实际环境中实现 IOC 容器的方式主要分为两大类，一类是依赖查找，依赖查找是通过资源定位，把对应的资源查找回来；另一类是依赖注入，Spring 主要使用的是依赖注入。一般，依赖注入可以分为三种方式： 构造器注入 setter 注入 接口注入 构造器注入和 setter 注入是主要的方式，而接口注入是从别的地方注入的方式，例如web工程中配置的数据源是通过服务器配置的，可以通过 JNDI 的形式通过接口将它注入 Spring IOC 容器中。 构造器注入构造器注入依赖于构造方法实现，构造方法可以是有参数的或者是无参数的。大部分情况下我们是通过类的构造方法创建类对象，Spring 可以采用反射的方式，通过使用构造方法来完成注入，这就是构造器注入的原理。 构造器注入代码： 12345678910public class User&#123; private int id; private String name; private String note; ............................... public User(String name,String note)&#123; this.name = name; this.note = note; &#125;&#125; 1234&lt;bean id=\"user\" class=\"com.ssm.entity.User\"&gt; &lt;constructor-arg index=\"0\" value=\"总经理\"/&gt; &lt;constructor-arg index=\"1\" value=\"管理者\"/&gt;&lt;/bean&gt; constructor-arg 元素用于定义类构造方法的参数，其中 index 用于定义参数的位置，value 是设置值。 构造器注入比较简单，但是缺点也很明显，参数少时可读性比较好，当参数量较多时，构造器注入就比较复杂，代码维护难。 setter 注入setter 注入时 Spring 中最主流的注入方式，它利用 Java Bean 规范定义的 setter 方法完成注入，灵活并且代码可读性高，它消除了使用构造器注入时参数过多的麻烦，通过 setter 注入为其设置的值，其实也是通过 Java 的反射技术实现的。 1234&lt;bean id=\"user\" class=\"com.ssm.entity.User\"&gt; &lt;property name=\"name\" value=\"工程师\"/&gt; &lt;property name=\"note\" value=\"重要人员\"/&gt;&lt;/bean&gt; Spring 会通过反射调用没有参数的构造方法生成对象，同时通过反射对应的 setter 方法注入配置的值，这种方式是 Spring 最为主要的方式，应用十分广泛。 接口注入有些时候资源是来自外界，比如数据库连接资源完全可以在 Tomcat 下配置，通过 JNDI 的形式去获取它，这样数据库链接资源是属于开发工程外的资源，这时就可以使用接口注入的形式获取它。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring IOC","slug":"Spring IOC","date":"2019-07-21T10:06:22.726Z","updated":"2019-08-30T05:19:06.673Z","comments":true,"path":"2019/07/21/Spring IOC/","link":"","permalink":"http://yoursite.com/2019/07/21/Spring IOC/","excerpt":"","text":"传统编码创建对象时，我们总是通过 new 方法主动创建对象，但是在现实中，一个复杂的系统面对着成千上百的对象，如果每一个对象都通过手动创建、维护，就会十分的复杂。更多时候，我们希望通过简单方法获得想要的对象，这就是被动创建对象。 被动创建对象，不需要程序员手动一个个 new 出对象，只需要给出想要对象的描述就可以得到对象。在Spring框架中，这样的效果可以通过 IOC 实现。 Spring IOCIOC又称控制反转，就是将对象的创建权利发生反转，从之前自己手动的创建对象，现在变成由Spring容器帮助创建生成新的对象，程序员无需关注对象的创建过程，无需关注对象的生命周期。 举个例子，当你想喝水果饮料时，有两种选择，第一种是自己买水果来榨汁喝，第二种是去饮料店点一杯水果饮料。第一种解决方法就类似于手动 new 出一个对象，第二种解决方法是通过第三方直接获取对象。 这个例子包含了控制反转的思想，由自己榨饮料转换成通过第三方得到饮料，将制造饮料的过程由自己反转给第三方，这就是控制反转。而在Spring中，实现控制反转的就是 IOC 容器，其实现方法是依赖注入（Dependency Injection,DI）。 IOC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，指导如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了 IOC 容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松耦合关系，使得程序的整个体系结构变得非常灵活。 其实 IOC 对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在 IOC/DI 思想中，应用程序就变成被动的了，被动的等待 IOC 容器来创建并注入它所需要的资源了。 Spring IOC 容器Spring IOC 容器的设计主要是基于 BeanFactory 和 ApplicationContext 两个接口，其中 ApplicationContext 是 BeanFactory 的子接口之一，BeanFactory 是 Spring IOC 容器所定义的最底层接口。ApplicationContext 是对 BeanFactory 功能做了更多扩展，在大部分场景下，都是使用 ApplicationContext 作为 Spring IOC 容器。 Spring IOC 容器初始化 BeanBean 的定义和初始化在 Spring IOC 容器中是两大步骤，Bean 的定义分为3步： Resource 定位，这步是 Spring IOC 容器根据开发者的配置，进行资源定位。 BeanDefinition 的载入，这个时候只是将 Resource 定位到的信息保存到 Bean 定义（BeanDefinition）中，此时不会创建 Bean 实例。 BeanDefinition 的注册，这个过程将 BeanDefinition 的信息发布到 Spring IOC 容器中，此时仍然没有创建 Bean 的实例。 做完这3步，Bean 在 Spring IOC 容器中就被定义了，但是没有被初始化，更没有完成依赖注入，这时它还不能完全使用，对于初始化和依赖注入，Spring Bean 还有一个配置——lazy-init（是否初始化 Spring Bean）。默认值为 default，实际值为 false，也就是 Spring IOC 默认自动初始化 Bean，如果设置为 true，就只有在使用 Spring IOC 容器的 getBean 方法获取时才会被初始化，完成依赖注入。 Spring Bean 生命周期图","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring","slug":"Spring","date":"2019-07-21T10:04:31.400Z","updated":"2019-08-30T05:20:52.341Z","comments":true,"path":"2019/07/21/Spring/","link":"","permalink":"http://yoursite.com/2019/07/21/Spring/","excerpt":"","text":"什么是SpringSpring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring的核心是控制反转（IOC）和面向切面（AOP）。 简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。 Spring起源要谈Spring的历史，就要先谈J2EE。J2EE应用程序的广泛实现是在1999年和2000年开始的，它的出现带来了诸如事务管理之类的核心中间层概念的标准化，但是在实践中并没有获得绝对的成功，因为开发效率，开发难度和实际的性能都令人失望。曾经使用过EJB开发JAVA EE应用的人，一定知道，在EJB开始的学习和应用非常的艰苦，很多东西都不能一下子就很容易的理解。EJB要严格地实现各种不同类型的接口，类似的或者重复的代码大量存在。而配置也是复杂和单调，同样使用JNDI进行对象查找的代码也是单调而枯燥。虽然有一些开发工作随着xdoclet的出现，而有所缓解，但是学习EJB的高昂代价，和极低的开发效率，极高的资源消耗，都造成了EJB的使用困难。而Spring出现的初衷就是为了解决类似的这些问题。 Spring的一个最大的目的就是使JAVA EE开发更加容易。同时，Spring之所以与Struts、Hibernate等单层框架不同，是因为Spring致力于提供一个以统一的、高效的方式构造整个应用，并且可以将单层框架以最佳的组合揉和在一起建立一个连贯的体系。可以说Spring是一个提供了更完善开发环境的一个框架，可以为POJO(Plain Ordinary Java Object)对象提供企业级的服务。Spring的形成，最初来自Rod Jahnson所著的一本很有影响力的书籍《Expert One-on-One J2EE Design and Development》，就是在这本书中第一次出现了Spring的一些核心思想，该书出版于2002年。另外一本书《Expert One-on-One J2EE Development without EJB》，更进一步阐述了在不使用EJB开发JAVA EE企业级应用的一些设计思想和具体的做法。 Spring优点 容易解耦，简化开发 通过Spring提供的IoC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。有了Spring，用户不必再为单实例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。 支持AOP（面向切面编程） 通过Spring提供的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。 支持事务 在Spring中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。 程序容易调试 可以用非容器依赖的编程方式进行几乎所有的测试工作，在Spring里，测试不再是昂贵的操作，而是随手可做的事情。例如：Spring对Junit4支持，可以通过注解方便的测试Spring程序。 方便集成各种优秀框架 Spring不排斥各种优秀的开源框架，相反，Spring可以降低各种框架的使用难度，Spring提供了对各种优秀框架（如MyBatis、SpringMVC、Hibernate）等的直接支持。 降低Java EE API的使用难度 Spring对很多难用的Java EE API（如JDBC，JavaMail，远程调用等）提供了一个薄薄的封装层，通过Spring的简易封装，这些Java EE API的使用难度大为降低。 7. JavaBean提供了应用程序配置的最好方法Spring框架结构1、Spring Core（核心容器）：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 2、Spring Context（上下文）：Spring 上下文是一个配置文件，向 Spring框架提供上下文信息。Spring 上下文包括企业服务，例如JNDI、EJB、电子邮件、国际化、校验和调度功能。 3、Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。 4、Spring DAO：JDBCDAO抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 5、Spring ORM：Spring 框架插入了若干个ORM框架，从而提供了 ORM 的对象关系工具，其中包括JDO、Hibernate和iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 6、Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 7、Spring MVC 框架：MVC框架是一个全功能的构建 Web应用程序的 MVC 实现。通过策略接口，MVC框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。模型由javabean构成，存放于Map；视图是一个接口，负责显示模型；控制器表示逻辑代码，是Controller的实现。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Mybatis运行原理","slug":"MyBatis运行原理","date":"2019-06-23T15:52:40.000Z","updated":"2019-08-30T05:18:17.702Z","comments":true,"path":"2019/06/23/MyBatis运行原理/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis运行原理/","excerpt":"","text":"原理MyBatis的运行过程分为两大步： 读取配置文件缓存到Configuration对象中，用于创建SqlSessionFactory SqlSession的执行过程构建SqlSessionFactory过程 通过 org.apache.ibatis.builder.xml.XMLConfigBuilder 解析配置的XML文件，读出所配置的参数，并将读取的内容存入 org.apache.ibatis.session.Configuration 类对象中。而Configuration采用的是单例模式，几乎所有的MyBatis配置内容都会存放在这个单例对象中。 使用Configuration对象创建SqlSessionFactory。MyBatis中的SqlSessionFactory是一个接口，不是一个实现类，所以MyBatis提供了一个默认的实现类 org.apache.ibatis.session.defaults.DefaultSqlSessionFactory。在大部分的情况下没必要自己去创建SqlSessionFactory的实现类，这种创建方式就是一种Builder模式。 XMLConfigBuilder中解析XML方法源码： 12345678910111213141516171819202122232425262728public class XMLConfigBuilder extends BaseBuilder &#123; ...................... public Configuration parse() &#123; if (parsed) &#123; throw new BuilderException(\"Each XMLConfigBuilder can only be used once.\"); &#125; parsed = true; parseConfiguration(parser.evalNode(\"/configuration\")); return configuration; &#125; private void parseConfiguration(XNode root) &#123; try &#123; propertiesElement(root.evalNode(\"properties\")); //issue #117 read properties first typeAliasesElement(root.evalNode(\"typeAliases\")); pluginElement(root.evalNode(\"plugins\")); objectFactoryElement(root.evalNode(\"objectFactory\")); objectWrapperFactoryElement(root.evalNode(\"objectWrapperFactory\")); settingsElement(root.evalNode(\"settings\")); environmentsElement(root.evalNode(\"environments\")); // read it after objectFactory and objectWrapperFactory issue #631 databaseIdProviderElement(root.evalNode(\"databaseIdProvider\")); typeHandlerElement(root.evalNode(\"typeHandlers\")); mapperElement(root.evalNode(\"mappers\")); &#125; catch (Exception e) &#123; throw new BuilderException(\"Error parsing SQL Mapper Configuration. Cause: \" + e, e); &#125; &#125; ............................&#125; 我们可以看到它是通过一个一个节点的解析XML的内容得到对应的信息，最后构建出一个Configuration对象。有了Configuration对象，就可以通过SqlSessionFactoryBuilder的build方法构建SqlSessionFactory对象 12345678910111213141516171819202122public class SqlSessionFactoryBuilder &#123; ................... public SqlSessionFactory build(Reader reader, String environment, Properties properties) &#123; try &#123; XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties); return build(parser.parse()); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error building SqlSession.\", e); &#125; finally &#123; ErrorContext.instance().reset(); try &#123; reader.close(); &#125; catch (IOException e) &#123; // Intentionally ignore. Prefer previous error. &#125; &#125; &#125; public SqlSessionFactory build(Configuration config) &#123; return new DefaultSqlSessionFactory(config); &#125; .......................&#125; SqlSession执行过程有了SqlSessionFactory对象就可以轻易的获取SqlSession，SqlSession也是个接口，给出了查询、插入、更新、删除的方法。 1234567public class DefaultSqlSessionFactory implements SqlSessionFactory &#123; .................. public SqlSession openSession() &#123; return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false); &#125; ..................&#125; Mapper的动态代理SqlSession中提供了一个getMapper方法，例如： 1UserMapper userMapper = sqlSession.getMapper(UserMapper.class); 源码： 1234567public class DefaultSqlSession implements SqlSession &#123; ............................ public &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123; return configuration.&lt;T&gt;getMapper(type, this); &#125; ............................&#125; 1234567public class Configuration &#123; ................ public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123; return mapperRegistry.getMapper(type, sqlSession); &#125; .................&#125; 123456789101112131415161718192021public class MapperRegistry &#123; private Configuration config; private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt;(); public MapperRegistry(Configuration config) &#123; this.config = config; &#125; @SuppressWarnings(\"unchecked\") public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123; final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type); if (mapperProxyFactory == null) throw new BindingException(\"Type \" + type + \" is not known to the MapperRegistry.\"); try &#123; return mapperProxyFactory.newInstance(sqlSession); &#125; catch (Exception e) &#123; throw new BindingException(\"Error getting mapper instance. Cause: \" + e, e); &#125; &#125; ...........................................&#125; 可以很明显的看出，它运用到了Configuration对象的getMapper方法获取对应的接口对象，又运用了映射器的注册器Mapperregistry获取对应的接口对象。首先会判断是否注册一个Mapper，如果没有则抛出异常信息，如果有就会启用MapperProxyFactory工厂生成一个代理实例。 SqlSession的四大对象 Executor代表执行器，由它调度StatementHandler、ParameterHandler、ResultSetHandler等来执行对应的SQL，其中StatementHandler是最重要的。 StatementHandler的作用是使用数据库的Statement（PreparedStatement）执行操作，它是四大对象的核心，起到承上启下的作用，许多插件都是通过拦截它来实现的。 ParameterHandler是用来处理SQL参数的。 ResultSetHandler是进行数据集（ResultSet）的封装返回处理的，不经常使用。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis一级缓存和二级缓存","slug":"MyBatis一级缓存和二级缓存","date":"2019-06-23T15:50:40.000Z","updated":"2019-08-30T05:15:28.238Z","comments":true,"path":"2019/06/23/MyBatis一级缓存和二级缓存/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis一级缓存和二级缓存/","excerpt":"","text":"简述mybatis提供了缓存机制减轻数据库压力，提高数据库性能。 mybatis的缓存分为两级：一级缓存、二级缓存。 一级缓存一级缓存是在SqlSession上的缓存，默认情况下，MyBatis系统会开启一级缓存，也就是对于SqlSession层面的缓存，这个缓存不需要POJO对象可序列化。测试一级缓存： 123456789101112131415161718@Testpublic void testFindUser() throws IOException &#123; //读取核心配置文件 String file = \"sqlMapConfig.xml\"; InputStream in = Resources.getResourceAsStream(file); //日志 Logger logger = Logger.getLogger(MybatisFirstTest.class); //创建sqlsessionfactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); //创建sqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User u = userMapper.getUser(1L); logger.info(\"再获取一次POJO....\"); User u1 = userMapper.getUser(1L); sqlSession.close(); &#125; 这段代码对同一对象进行两次获取，但是在日志中显示只有一条SQL语句被执行，原因是使用了同一个SqlSession对象获取数据，当一个SqlSession第一次通过SQL和参数获取对象后会将其缓存起来，如果下一次SQL和参数没有发生变化，并且缓存没有超时或者需要刷新时，它就会从缓存中直接取数据。 二级缓存二级缓存是在SqlSessionFactory上的缓存，默认情况下，MyBatis系统不会开启二级缓存，需要手动开启，开启二级缓存只需要在映射文件上添加代码： 1&lt;cache/&gt; 这个时候MyBatis会序列化和反序列化对应的POJO对象，也就要求POJO需要实现序列化接口。如果实体类没有实现序列化接口，MyBatis会抛出异常。 1234public class User implements Serializable&#123; public static final long serialVersionUID = 598736524547906734L; .........................&#125; 这个时候从日志上就可以看到不同的SqlSession在获取同一条记录时，都是只发送过一次SQL获取数据，MyBatis将其保存在SqlSessionFactory层面，提供给各个SqlSession使用。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis映射器","slug":"MyBatis映射器","date":"2019-06-23T15:50:40.000Z","updated":"2019-08-30T05:16:26.046Z","comments":true,"path":"2019/06/23/MyBatis映射器/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis映射器/","excerpt":"","text":"简述映射器是MyBatis最复杂且最重要的组件，它由一个接口加上XML文件（或者注解）组成。在映射器中可以配置参数、各类SQL语句、存储过程、缓存、级联等复杂内容，并且通过建议的映射规则映射到指定的POJO或者其他对象上，映射器能有效消除JDBC底层的代码。| 元素名称 | 描述 | 备注 || —————- | ———————————————————- | ————————————————— || select | 查询语句，最常用、最复杂的元素之一 | 可以自定义参数，返回结果集等 || insert | 插入语句 | 执行后返回一个整数，代表插入的条数 || update | 更新语句 | 执行后返回一个整数，代表更新的条数 || delete | 删除语句 | 执行后返回一个整数，代表删除的条数 || parameterMap | 定义参数映射关系 | 即将被删除的元素，不建议大家使用 || sql | 定义一部分SQL，在各个地方引用它 | 例如，一张表列名，一次定义，可以在多个SQL语句中使用 || resultMap | 用来描述从数据库结果集中加载对象，它是最复杂、最强大的元素 | 提供映射规则 || cache | 给定命名空间的缓存配置 | || cache-ref | 其他命名空间缓存配置的引用 | | select元素先来看看select元素的几个重要配置：| 元素 | 说明 | 备注 || —————- | ———————————————————— | ———————————————————- || id | 它和Mapper的命名空间组合起来是唯一的，供MyBatis调用 | 如果命名空间和id结合起来不唯一，MyBatis会抛出异常 || parameterType | 类的全命名，也可以是别名，但是别名必须是MyBatis内部定义的 | 可以选择JavaBean、Map等简单参数类型传递给SQL || parameterMap | 即将废弃的元素 | || resultType | 定义类的全路径，结果集将通过JavaBean的规范映射或者定义成int、double等参数，也可以使用别名 | 常用的参数之一 || resultMap | 它是映射集的引用，执行强大的映射功能，resultMap能提供自定义的映射规则 | MyBatis最复杂的元素，可以配置映射规则、级联、typeHandler等 || useCache | 启动二级缓存的开关，是否要求MyBatis将此次结果缓存 | 取值为布尔值，默认值为true | 简单的select例子： 123&lt;select id=\"findArticleById\" parameterType=\"integer\" resultMap=\"BaseResultMap\"&gt; SELECT * FROM article WHERE id = #&#123;id&#125;&lt;/select&gt; id配合Mapper的全限定名，成为一个唯一的标识，标识这条SQL parameterType为入参的类型 resultMap为SQL语句返回的结果集的映射 自动映射和驼峰映射MyBatis提供了自动映射功能，默认情况下自动映射是开启的，使用自动映射功能可以大量减少映射配置，在setting元素中有两个配置的选项 autoMappingBehavior 和 mapUnderscoreToCamelCase，它们是控制自动映射和驼峰映射的开关。 配置自动映射的 autoMappingBehavior 选项取值范围是： NONE 不进行自动映射 PARTIAL 默认值，只对没有嵌套结果集进行自动映射 FULL 对所有结果集进行自动映射，包括嵌套结果集 传参问题在上面的例子中，只有一个参数传递，现实需求可能需要多个参数，MyBatis提供了多种方法来解决多参传入的问题。 使用map接口传递参数 接口定义 1public List&lt;User&gt; findUserByMap(Map&lt;String,Object&gt;parameterMap); 映射器 123&lt;select id=\"findUserByMap\" parameterType=\"map\" resultType=\"user\"&gt; SELECT * FROM user WHERE id = #&#123;id&#125; and name = #&#123;name&#125;&lt;/select&gt; 注意，参数id和name，要求的是map的键！ 使用注解传递多个参数 @Param 使用map传递参数有个弊端–代码可读性差，MyBatis提供了一个注解@Param，可以通过它去定义映射器的参数名称。 接口定义 1public List&lt;User&gt; findUserByMap(@Param(\"id\")Integer id,@Param(\"name\")String name); 映射器 123&lt;select id=\"findUserByMap\" resultType=\"user\"&gt; SELECT * FROM user WHERE id = #&#123;id&#125; and name = #&#123;name&#125;&lt;/select&gt; 注意，这里使用了@Param注解就不需要给出parameterType属性，MyBatis可以自动探索。 通过JavaBean传递多个参数 定义POJO 12345public class UserSelect&#123; private Integer id; private String name; ................&#125; 接口定义 1public List&lt;User&gt; findUserByMap(UserSelect userSelect); 映射器 123&lt;select id=\"findUserByMap\" parameterType=\"com.ssm.vo.UserSelect\" resultType=\"user\"&gt; SELECT * FROM user WHERE id = #&#123;userSelect.id&#125; and name = #&#123;userSelect.name&#125;&lt;/select&gt; insert、update、delete元素由于insert、update、delete这三个元素使用方法类似，这里就将三种元素放在一起。 MyBatis在执行完insert、update、delete语句之后，会返回一个整数来表示其影响的数据库记录数。 insert 123456789101112&lt;insert id=\"insert\" parameterType=\"com.ronin.blog.entity.Article\" &gt; insert into article (article_user_id, article_title, article_summary, article_view_count, article_comment_count, article_like_count, article_is_comment, article_status, article_update_time, article_create_time, article_html, article_content) values ( #&#123;articleUserId,jdbcType=INTEGER&#125;, #&#123;articleTitle,jdbcType=VARCHAR&#125;, #&#123;articleViewCount,jdbcType=INTEGER&#125;, #&#123;articleCommentCount,jdbcType=INTEGER&#125;, #&#123;articleLikeCount,jdbcType=INTEGER&#125;, #&#123;articleIsComment,jdbcType=INTEGER&#125;, #&#123;articleStatus,jdbcType=INTEGER&#125;, #&#123;articleUpdateTime,jdbcType=TIMESTAMP&#125;, #&#123;articleCreateTime,jdbcType=TIMESTAMP&#125;, #&#123;articleHtml,jdbcType=LONGVARCHAR&#125;, #&#123;articleContent,jdbcType=LONGVARCHAR&#125;)&lt;/insert&gt; 主键回填可以看出上面这条语句没有插入id列，因为MySql中表格采用了主键自增，MySql数据库会自动生成主键，我们也可以在MyBatis插入数据时获取到数据库生成的主键值。在insert语句中有个开关属性 useGeneratedKeys，用来控制是否打开这个功能，默认值是false。打开时要配置其属性 keyProperty 或 keyColumn，告诉系统把生成的主键放入哪个属性,如果存在多个主键，用逗号（，）隔开。 update 12345678910111213141516&lt;update id=\"updateByPrimaryKey\" parameterType=\"com.ronin.blog.entity.Article\" &gt; update article set article_user_id = #&#123;articleUserId,jdbcType=INTEGER&#125;, article_title = #&#123;articleTitle,jdbcType=VARCHAR&#125;, article_summary = #&#123;articleSummary,jdbcType=VARCHAR&#125;, article_view_count = #&#123;articleViewCount,jdbcType=INTEGER&#125;, article_comment_count = #&#123;articleCommentCount,jdbcType=INTEGER&#125;, article_like_count = #&#123;articleLikeCount,jdbcType=INTEGER&#125;, article_is_comment = #&#123;articleIsComment,jdbcType=INTEGER&#125;, article_status = #&#123;articleStatus,jdbcType=INTEGER&#125;, article_update_time = #&#123;articleUpdateTime,jdbcType=TIMESTAMP&#125;, article_create_time = #&#123;articleCreateTime,jdbcType=TIMESTAMP&#125;, article_html = #&#123;articleHtml,jdbcType=LONGVARCHAR&#125;, article_content = #&#123;articleContent,jdbcType=LONGVARCHAR&#125; where article_id = #&#123;articleId,jdbcType=INTEGER&#125; &lt;/update&gt; delete 1234&lt;delete id=\"deleteByPrimaryKey\" parameterType=\"java.lang.Integer\" &gt; delete from article where article_id = #&#123;articleId,jdbcType=INTEGER&#125;&lt;/delete&gt; sql元素sql元素的作用在于可以定义一条SQL的一部分，方便后面的SQL引用它，把重复的SQL语句抽取出来，降低耦合性。 定义 123&lt;sql id=\"articleAndTagLine\"&gt; a.* , t.tag_id , t.tag_description , t.tag_name , u.user_id , u.user_name&lt;/sql&gt; 引用 123&lt;select id=\"selectTopArticle\" resultMap=\"BaseResultMap\"&gt; select &lt;include refid=\"articleLine\"/&gt; from article&lt;/select&gt; resultMap元素resultMap的作用是定义映射规则、级联的更新、定制类型转化器等。resultMap定义的主要是一个结果集的映射关系，就是SQL到JavaBean的映射关系定义，它也支持级联等特性。 12345678910&lt;resultMap id=\"BaseResultMap\" type=\"com.ronin.blog.entity.Article\" &gt; &lt;id column=\"id\" property=\"id\" jdbcType=\"INTEGER\" /&gt; &lt;result column=\"title\" property=\"title\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"keywords\" property=\"keywords\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"desci\" property=\"desci\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"pic\" property=\"pic\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"click\" property=\"click\" jdbcType=\"INTEGER\" /&gt; &lt;result column=\"time\" property=\"time\" jdbcType=\"TIMESTAMP\" /&gt; &lt;result column=\"catalog_id\" property=\"catalogId\" jdbcType=\"INTEGER\" /&gt; &lt;/resultMap&gt;","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis核心组件的生命周期","slug":"MyBatis核心组件的生命周期","date":"2019-06-23T15:50:40.000Z","updated":"2019-08-30T05:11:00.782Z","comments":true,"path":"2019/06/23/MyBatis核心组件的生命周期/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis核心组件的生命周期/","excerpt":"","text":"简述MyBatis的四大核心组件已经基本掌握，本篇文章就来谈谈四大核心组件的生命周期。首先，什么是生命周期？所谓的生命周期就是每一个对象存活的时间，例如一个对象一次用完后就要关闭，被Java虚拟机（JVM）销毁，以免继续占用资源，所以我们可以根据每个组件的作用来确定其生命周期。 SqlSessionFactoryBuilderSqlSessionFactoryBuilder的作用在于创建SqlSessionFactory，创建成功之后，SqlSessionFactoryBuilder就失去作用，所以它只能存在于创建SqlSessionFactory的方法中。 SqlSessionFactorySqlSessionFactory可以将其当作JDBC中的数据库连接池，它的作用是创建SqlSession接口对象，所以SqlSessionFactory的生命周期存在于整个MyBatis应用当中，可以认为SqlSessionFactory的生命周期等同于MyBatis的生命周期。 SqlSessionSqlSession也可以将其当作JDBC中的数据库连接对象（Connection），在一个事务中，通过SqlSession的commit和rollback方法提交或者回滚事务，所以SqlSession存活在一个业务请求中，处理完整个业务请求之后就应该关闭SqlSession，释放资源，所以SqlSession经常被作为单例使用。 MapperMapper是一个接口，它是通过SqlSession创建出来的，所以它的生命周期最多也是和SqlSession相同，当SqlSession被关闭释放后，Mapper也会消失，所以它的生命周期是小于等于SqlSession的生命周期的。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis级联","slug":"MyBatis级联","date":"2019-06-23T15:50:40.000Z","updated":"2019-08-30T05:15:05.295Z","comments":true,"path":"2019/06/23/MyBatis级联/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis级联/","excerpt":"","text":"简述级联是一个数据库实体的概念，级联不是必须的，级联的好处是获取关联数据十分方便，但是级联过多会增加系统的复杂度，同时降低系统的性能，所以当级联的层级超过3层时，就不要考虑使用级联，这样会导致多个对象的关联，导致系统耦合度增加，难以维护。 MyBatis的级联分为3种： 鉴别器（discriminator）：它是一个根据某些条件决定采用具体实现类级联的方案。 一对一（association）：比如身份证和人就是一种一对一的级联关系。 一对多（collection）：比如班主任和学生就是一种一对多的级联关系。 注意！MyBatis中没有多对多级联关系，因为多对多级联比较复杂，使用困难，而且可以通过两个一对多级联进行替换，所以MyBatis不支持多对多级联。 下面主要讲解常用的一对一级联与一对多级联。 一对一级联JavaBean 1234567891011121314151617181920212223242526272829303132333435363738package com.ronin.blog.entity;import lombok.Data;import java.util.Date;import java.util.List;@Datapublic class Article &#123; private Integer articleId; private Integer articleUserId; private String articleTitle; private String articleSummary; private Integer articleViewCount; private Integer articleCommentCount; private Integer articleLikeCount; private Integer articleIsComment; private Integer articleStatus; private Date articleUpdateTime; private Date articleCreateTime; private String articleHtml; private String articleContent; //一对一关系 private User user;&#125; 配置文件 1234567891011121314151617181920&lt;resultMap id=\"BaseResultMap\" type=\"com.ronin.blog.entity.Article\" &gt; &lt;id column=\"article_id\" property=\"articleId\" jdbcType=\"INTEGER\" /&gt; &lt;result column=\"article_user_id\" property=\"articleUserId\" jdbcType=\"INTEGER\" /&gt; &lt;result column=\"article_title\" property=\"articleTitle\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"article_summary\" property=\"articleSummary\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"article_view_count\" property=\"articleViewCount\" jdbcType=\"INTEGER\" /&gt; &lt;result column=\"article_comment_count\" property=\"articleCommentCount\" jdbcType=\"INTEGER\" /&gt; &lt;result column=\"article_like_count\" property=\"articleLikeCount\" jdbcType=\"INTEGER\" /&gt; &lt;result column=\"article_is_comment\" property=\"articleIsComment\" jdbcType=\"INTEGER\" /&gt; &lt;result column=\"article_status\" property=\"articleStatus\" jdbcType=\"INTEGER\" /&gt; &lt;result column=\"article_update_time\" property=\"articleUpdateTime\" jdbcType=\"TIMESTAMP\" /&gt; &lt;result column=\"article_create_time\" property=\"articleCreateTime\" jdbcType=\"TIMESTAMP\" /&gt; &lt;result column=\"article_html\" property=\"articleHtml\" jdbcType=\"LONGVARCHAR\" /&gt; &lt;result column=\"article_content\" property=\"articleContent\" jdbcType=\"LONGVARCHAR\" /&gt; &lt;!-- 一对一级联 --&gt; &lt;association property=\"user\" javaType=\"User\"&gt; &lt;id column=\"user_id\" property=\"userId\"/&gt; &lt;result column=\"user_name\" property=\"userName\"/&gt; &lt;/association&gt; &lt;/resultMap&gt; 一对多级联JavaBean 1234567891011121314151617181920212223242526272829303132333435363738package com.ronin.blog.entity;import lombok.Data;import java.util.Date;import java.util.List;@Datapublic class Article &#123; private Integer articleId; private Integer articleUserId; private String articleTitle; private String articleSummary; private Integer articleViewCount; private Integer articleCommentCount; private Integer articleLikeCount; private Integer articleIsComment; private Integer articleStatus; private Date articleUpdateTime; private Date articleCreateTime; private String articleHtml; private String articleContent; //一对多关系 private List&lt;Tag&gt; tagList;&#125; 配置文件 1234567891011121314151617181920212223&lt;resultMap id=\"BaseResultMap\" type=\"com.ronin.blog.entity.Article\" &gt; &lt;id column=\"article_id\" property=\"articleId\" jdbcType=\"INTEGER\" /&gt; &lt;result column=\"article_user_id\" property=\"articleUserId\" jdbcType=\"INTEGER\" /&gt; &lt;result column=\"article_title\" property=\"articleTitle\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"article_summary\" property=\"articleSummary\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"article_view_count\" property=\"articleViewCount\" jdbcType=\"INTEGER\" /&gt; &lt;result column=\"article_comment_count\" property=\"articleCommentCount\" jdbcType=\"INTEGER\" /&gt; &lt;result column=\"article_like_count\" property=\"articleLikeCount\" jdbcType=\"INTEGER\" /&gt; &lt;result column=\"article_is_comment\" property=\"articleIsComment\" jdbcType=\"INTEGER\" /&gt; &lt;result column=\"article_status\" property=\"articleStatus\" jdbcType=\"INTEGER\" /&gt; &lt;result column=\"article_update_time\" property=\"articleUpdateTime\" jdbcType=\"TIMESTAMP\" /&gt; &lt;result column=\"article_create_time\" property=\"articleCreateTime\" jdbcType=\"TIMESTAMP\" /&gt; &lt;result column=\"article_html\" property=\"articleHtml\" jdbcType=\"LONGVARCHAR\" /&gt; &lt;result column=\"article_content\" property=\"articleContent\" jdbcType=\"LONGVARCHAR\" /&gt; &lt;!-- 一对多级联 --&gt; &lt;collection property=\"tagList\" javaType=\"list\" ofType=\"Tag\"&gt; &lt;!-- 映射主键 --&gt; &lt;id column=\"tag_id\" property=\"tagId\"/&gt; &lt;!-- 映射普通属性 --&gt; &lt;result column=\"tag_name\" property=\"tagName\"/&gt; &lt;result column=\"tag_description\" property=\"tagDescription\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt;","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis配置","slug":"MyBatis配置","date":"2019-06-23T15:50:40.000Z","updated":"2019-08-30T05:13:29.039Z","comments":true,"path":"2019/06/23/MyBatis配置/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis配置/","excerpt":"","text":"简述123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;&lt;!-- 配置 --&gt; &lt;!-- 属性 --&gt; &lt;properties&gt;&lt;/properties&gt; &lt;!-- 设置 --&gt; &lt;settings&gt;&lt;/settings&gt; &lt;!-- 设置别名 --&gt; &lt;typeAliases&gt;&lt;/typeAliases&gt; &lt;!-- 类型处理器 --&gt; &lt;typeHandlers&gt;&lt;/typeHandlers&gt; &lt;!-- 对象工厂 --&gt; &lt;objectFactory&gt;&lt;/objectFactory&gt; &lt;!-- 插件 --&gt; &lt;plugins&gt;&lt;/plugins&gt; &lt;!-- 环境配置 --&gt; &lt;environments&gt; &lt;environment&gt; &lt;!-- 事务管理器 --&gt; &lt;transactionManager&gt;&lt;/transactionManager&gt; &lt;!-- 数据源 --&gt; &lt;dataSource&gt;&lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 数据库厂商 --&gt; &lt;databaseIdProvider&gt;&lt;/databaseIdProvider&gt; &lt;!-- 映射器 --&gt; &lt;mappers&gt;&lt;/mappers&gt;&lt;/configuration&gt; 上述的代码是整个MyBatis配置文件中包含的所有重要的节点元素，要注意的是，这些节点元素的顺序不能够颠倒！ properties属性properties属性可以给系统配置运行参数，可以放在XML文件或者properties文件中，这样的好处可以方便我们进行参数的修改，不会引起代码的重新编译。MyBatis提供了三种方式使用properties： property子元素 properties文件 程序代码传递 MyBatis通过properties的属性resource来引入properties文件： 1&lt;properties resource=&quot;jdbc.properties&quot;/&gt; 在这三种方式中，最优先的是使用程序传递的方式，其次是使用properties文件的方式，最后是使用property子元素的方式，MyBatis会根据优先级来覆盖原先配置的属性值。 settings属性settings的配置项很多，但是常用的就只有几个，比如缓存的cacheEnabled，关于级联的lazyLoadingEnabled和aggressiveLazyLoading，关于自动映射的autoMappingBehavior和mapUnderscoreToCamelCase，关于执行器类型的defaultExecutorType等。 typeAliases属性该属性是用于定义类的别名，MyBatis中允许通过typeAliases属性定义一个简写来代表这个类，别名分为系统定义别名和自定义别名，在MyBatis中别名由类TypeAliasRegistry定义的，在MyBatis中别名不区分大小写。 typeHandler属性该属性为类型转换器，在JDBC中，需要在PreparedStatement对象中设置那些已经预编译过的SQL语句的参数。执行SQL后，会通过ResultSet对象获取得到数据库的数据，而这些MyBatis是根据数据的类型通过typeHandler来实现的。 typeHandler中分为javaType和jdbcType两种，其中javaType用于定义java类型，jdbcType用于定义数据库类型，typeHandler的作用就是承担javaType和jdbcType之间的转换。跟别名一样，MyBatis中也存在着系统定义的typeHandler和自定义的typeHandler，MyBatis会根据javaType和jdbcType决定采用哪个typeHandler处理转换规则。 objectFactory属性当创建结果集的时候，MyBatis会使用一个对象工厂来完成创建这个结果集的实例，默认情况下会使用其定义的对象工厂–DefaultObjectFactory来完成工作。当然，MyBatis也支持自定义的ObjectFactory，只需要实现接口org.apache.ibatis.reflection.factory.ObjectFactory,并给予配置。 environment属性该属性主要用于配置数据库环境信息，下级节点包含了：事务管理器（transactionManager）和数据源（dataSource）。 transactionManager它的主要工作就是提交（commit）、回滚（rollback）和关闭（close）数据库的事务。MyBatis为Transaction提供了两个实现类：JdbcTransaction和ManagedTransaction。 对于两种事务管理器，配置分别为： 12&lt;transactionManager type=&quot;JDBC&quot;/&gt;&lt;transactionManager type=&quot;MANAGED&quot;/&gt; JDBC使用JdbcTransactionFactory生成的JdbcTransaction对象实现，它是以JDBC的方式对数据库的提交和回滚进行操作。MANAGED使用ManagedTransactionFactory生成的ManagedTransaction对象实现，它的提交和回滚方法不用任何操作，而是把事务交给容器处理。默认情况下它会关闭连接，需要将closeConnection属性设置为false。 dataSource数据源存在三种类型： 123&lt;dataSource type=&quot;UNPOOLED&quot;/&gt;&lt;dataSource type=&quot;POOLED&quot;/&gt;&lt;dataSource type=&quot;JNDI&quot;/&gt; UNPOOLED采用非数据库池的管理方式，每次请求都会打开一个新的数据库连接，创建速度较慢，可以配置以下属性： driver url username password defaultTransactionIsolationLevel 默认的连接事务隔离级别 POOLED利用“池”的概念将JDBC的Connection对象组织起来，刚开始会有空置，但是再次请求时无须再建立和验证，省去创建新连接的时间，相比UNPOOLED的方式，它有更多于UNPOOLED属性： poolMaximumActiveConnections 任意时间存在的连接数，默认为10 poolMaximumIdleConnections 任意时间存在的空闲连接数 poolMaximumCheckoutTime 被强制返回之前，池中连接被检出的时间，默认20000毫秒 poolTimeToWait poolPingQuery poolPingEnabled 是否启用侦测查询 poolPingConnectionsNotUsedFor 配置poolPingQuery的使用频度 JNDI实现是为了能在如EJB或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个JNDI上下文引用，它需要两种属性： initial_context 用来在InitialContext中寻找上下文 data_source 引用数据源实例位置上下文的路径 mappers属性映射器定义命名空间的方法，命名空间对应的是一个接口的全路径，而不是实现类，映射器引入的方法有很多，分别为： 用文件路径引入映射器 123&lt;mappers&gt; &lt;mapper resource=\"com/etc/ssm/mapper/UserMapper.xml\"/&gt;&lt;/mappers&gt; 用包名引入映射器 123&lt;mappers&gt; &lt;mapper name=\"com.etc.ssm.mapper\"/&gt;&lt;/mappers&gt; 用类注册引入映射器 123&lt;mappers&gt; &lt;mapper class=\"com.etc.ssm.mapper.UserMapper\"/&gt;&lt;/mappers&gt;","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis核心组件之SQL Mapper","slug":"MyBatis核心组件之SQL Mapper","date":"2019-06-23T15:46:23.000Z","updated":"2019-08-30T05:13:58.924Z","comments":true,"path":"2019/06/23/MyBatis核心组件之SQL Mapper/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis核心组件之SQL Mapper/","excerpt":"","text":"简述映射器（SQL Mapper）是MyBatis中最重要、最复杂的组件，它是由一个接口和对应的XML文件组成，它可以配置以下内容： 描述映射规则 提供SQL语句，并可以配置SQL参数类型、返回类型、缓存刷新等信息 配置缓存 提供动态SQL 映射器的主要作用就是将SQL查询到的结果映射成一个POJO（Java原生对象），或者将POJO的数据插入到数据库中，并定义一些关于缓存等的重要内容。 下面提供两种方式实现映射器，首先我们先定义一个POJO对象： 1234567public class User&#123; private Long id; private String username; private String password; /** getter 和 setter 方法**/&#125; XML实现映射器用XML定义映射器分为两个部分：接口和XML。首先，定义一个映射器接口,提供一个通过id获取用户的方法。 123public interface UserMapper&#123; public User getUser(Long id);&#125; 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.etc.ssm.mapper.UserMapper\"&gt; &lt;!-- 获取用户 --&gt; &lt;select id=\"getUser\" parameterType=\"long\" resultType=\"user\"&gt; select * from tb_user where id= #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 注意：select元素节点的id属性值要与其对应的方法名相同！mapper元素节点：属性namespace所对应的是一个接口的全限定名，MyBatis上下文就可以通过它找到对应的接口。select元素节点：表明这是一条查询语句，属性id标识了这条SQL，属性parameterType=”long“说明传递给SQL的是一个long型的参数，resultType=”user”表示返回的是一个user类型的返回值，user是之前配置文件中设置过的别名。 注解实现映射器注解实现映射器相对于XML实现映射器较为简单，它只需要一个接口就可以，通过MyBatis的注解来注入SQL语句。 1234public interface UserMapper&#123; @Select(\"select * from tb_user where id= #&#123;id&#125;\"); public User getUser(Long id);&#125; 需要注意的是，当XML方式与注解方式同时定义时，XML方式会覆盖掉注解方式，所以MyBatis官方推荐使用的是XML实现映射器的方式，但是不同场景有不同的选择，在SQL语句量较少的情况下，使用注解方式会效率更高，但是与代码的耦合度较高。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis核心组件之SqlSession","slug":"MyBatis核心组件之SqlSession","date":"2019-06-23T15:46:23.000Z","updated":"2019-08-30T05:14:14.494Z","comments":true,"path":"2019/06/23/MyBatis核心组件之SqlSession/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis核心组件之SqlSession/","excerpt":"","text":"SqlSession在MyBatis中，SqlSession是其和新街口。在MyBatis中有两个实现类，DefaultSqlSession和SqlSessionManager。DefaultSqlSession是单线程使用的，而SqlSessionManager是在多线程环境下使用的。 SqlSession的作用类似于一个JDBC中的Connection对象，代表着一个连接资源的启用。具体而言，它的作用有3个： 获取Mapper接口 发送SQL给数据库 控制数据库事务 从上一篇文章中我们已经知道了怎么创建SqlSessionFactory，通过SqlSessionFactory的方法，我们可以直接创建处SqlSession对象，代码如下： 1SqlSession sqlSession = SqlSeesionFactory.openSession(); 创建出SqlSession对象，我们可以通过SqlSession对象来控制数据库的事务： 1234567891011121314151617//定义SqlSessionSqlSession sqlSession = null;try&#123; //打开SqlSession会话 sqlSession = SqlSessionFactory.openSession(); //业务逻辑代码..... // 提交事务 sqlSession.commit();&#125;catch(Exception ex)&#123; //事务回滚 sqlSession.rollback();&#125;finally&#123; //在finally语句中确保资源顺利关闭 if(sqlSession != null)&#123; sqlSession.close(); &#125;&#125; 上述代码中，使用commit方法提交事务，出错后通过rollback回滚事务，保证了代码运行时的数据的一致性。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis核心组件之SqlSessionFactory","slug":"MyBatis核心组件之SqlSessionFactory","date":"2019-06-23T15:28:20.000Z","updated":"2019-08-30T05:14:36.026Z","comments":true,"path":"2019/06/23/MyBatis核心组件之SqlSessionFactory/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis核心组件之SqlSessionFactory/","excerpt":"","text":"MyBatis的核心组件MyBatis的核心组件分为4个部分： SqlSessionFactoryBuilder（构造器）：它会根据配置或者代码来生成SqlSessionFactory，采用的是分布构建的Builder模式。 SqlSessionFactory（工厂接口）：依靠它来生成SqlSession，使用的是工厂模式。 SqlSession（会话）：一个既可以发送SQL执行返回结果，也可以获取Mapper的接口。在现有的技术中，一般我们会让其在业务逻辑代码中“消失”，而使用的是MyBatis提供的SQL Mapper接口编程技术，它能提高代码的可读性和可维护性。 SQL Mapper（映射器）：MyBatis新设计存在的组件，它由一个Java接口和XML文件（或注解）构成，需要给出对应的SQL和映射规则。它负责发送SQL去执行，并返回结果。 SqlSessionFactory使用MyBatis首先是使用配置或者代码去生产SqlSessionFactory，而MyBatis提供了构造器SqlSessionFactoryBuilder。它提供了一个类org.apache.ibatis.session.Configuration作为引导，采用的是Builder模式。 在MyBatis中，既可以通过读取配置的XML文件的形式生成SqlSessionFactory，也可以通过Java代码的形式去生成SqlSessionFactory。每个基于MyBatis的应用都是以一个SqlSessionFactory的实例为中心的，而SqlSessionFactory唯一的作用就是生产MyBatis的核心接口对象SqlSession，所以它的责任是唯一的，我们往往可以通过单例模式处理它。下面为两种方式创建SqlSessionFactory的代码。 使用XML构建SqlSessionFactory12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 设置别名 --&gt; &lt;typeAliases&gt; &lt;package name=\"com.etc.ssm.entity\"/&gt; &lt;/typeAliases&gt; &lt;!-- 加载数据库属性文件 --&gt; &lt;properties resource=\"db.properties\"&gt;&lt;/properties&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;!--使用JDBC实务管理--&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!--连接池 POOLED为连接池方式 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 引入映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=\"com.etc.ssm.mapper.UserMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; typeAliase节点：定义一个别名，代表com.etc.ssm.entity包下所有的类在MyBatis上下文中可以使用别名去代替全限定名。properties节点：可以引入指定目录下的配置文件。environments节点：描述的是数据库，其中transactionManager节点是配置事务管理器，采用MyBatis中JDBC的管理器方式，采用dataSource节点配置数据库，POOLED表示采用MyBatis内部提供的连接池方式。mappers节点：引入映射器。 1234567891011@Testpublic void testXmlSqlSessionFactory() &#123; SqlSessionFactory sqlSessionFactory = null; String resource = \"sqlMapConfig.xml\"; InputStream inputStream; try &#123; inputStream = Resource.getResourceAsStream(resource); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 使用代码创建SqlSessionFactory这种方法创建SqlSessionFactory不推荐使用。 123456789101112131415161718192021//数据库连接池信息PooledDataSource dataSource=new PooledDataSource();dataSource.setDriver(\"com.mysql.jdbc.Driver\");dataSource.setUsername(\"root\");dataSource.setPassword(\"123456\");dataSource.setUrl(\"jdbc:mysql://localhost:3306/ssm\");dataSource.setDefaultAutoCommit(false);//采用MyBatis的JDBC事务方式TransactionFactory transactionFactory =new JdbcTransactionFactory();Environment environment=new Environment(\"development\",transactionFactory,dataSource);/创建 Configuration对象Configuration configuration=new Configuration(environment);//注册一个MyBatis上下文别名configuration.getTypeAliasRegistry().registerAlias(\"user\",User.class);//加入一个映射器configuration.addMapper(UserMapper.class);//使用 SqlSessionFactoryBuilder 构建SqlSessionFactorySqlSessionFactory SqlSessionFactory=new SqlSessionFactoryBuilder().,build(configuration);return SqlSessionFactory;","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis","slug":"MyBatis","date":"2019-06-22T14:40:20.000Z","updated":"2019-08-30T05:10:54.028Z","comments":true,"path":"2019/06/22/MyBatis/","link":"","permalink":"http://yoursite.com/2019/06/22/MyBatis/","excerpt":"","text":"MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。 iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAOs） 当前，最新版本是MyBatis 3.5.1 ，其发布时间是2019年4月8日。 持久层的概念和MyBatis的特点上面介绍到MyBatis是一个持久层的框架，它是对JDBC进行了简单的封装，那么我们来讲讲什么是持久层。 持久层是三层架构（控制层、业务逻辑层、持久层）中的一层，持久层可以将业务数据存储到磁盘，具备长期存储的能力，只要磁盘不损坏，在断电或者其他情况下，重新开启系统仍然可以读取到这些数据。一般执行持久任务的都是数据库系统，持久层可以使用巨大的磁盘空间，也比较廉价，它的缺点就是比较慢。当然，慢是针对内存来说的，在一般的系统中运行是不存在问题的。但是在互联网的秒杀场景下，慢是不能接受的，极有可能导致宕机，在这样的场景下考虑使用Redis处理。 MyBatis的三大特点： 不屏蔽SQL，意味着可以更为精确的定位SQL语句，可以对其进行优化和改造，这有利于互联网系统性能的提高，符合互联网需要性能优化的特点。 提供强大、灵活的映射机制，方便Java开发者使用，提供动态SQL的功能，允许我们根据不同条件组装SQL，这个功能远比其他工具或者Java编码的可读性和可维护性高的多，满足各种应用系统的同时也满足了需求经常变化的互联网应用的要求。 在MaBatis中，提供了使用Mapper的接口编程，只要一个接口和一个XML就能创建映射器，进一步简化我们的工作，使得很多框架API在MyBatis中消失，开发者能更集中于业务逻辑。 ORM这里我们介绍一下什么叫做ORM。 ORM也称对象关系映射，是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。从效果上说，它其实是创建了一个可在编程语言里使用的–“虚拟对象数据库”。 面向对象是从软件工程基本原则（如耦合、聚合、封装）的基础上发展起来的，而关系数据库则是从数学理论发展而来的，两套理论存在显著的区别。为了解决这个不匹配的现象，对象关系映射技术应运而生。 对象关系映射（ORM）提供了概念性的、易于理解的模型化数据的方法。ORM方法论基于三个核心原则： 简单：以最基本的形式建模数据。 传达性：数据库结构被任何人都能理解的语言文档化。 精确性：基于数据模型创建正确标准化的结构。 典型地，建模者通过收集来自那些熟悉应用程序但不熟练的数据建模者的人的信息开发信息模型。建模者必须能够用非技术企业专家可以理解的术语在概念层次上与数据结构进行通讯。建模者也必须能以简单的单元分析信息，对样本数据进行处理。ORM专门被设计为改进这种联系。 简单的说：ORM相当于中继数据。具体到产品上，例如ADO.NET Entity Framework。DLINQ中实体类的属性[Table]就算是一种中继数据。 MyBatis与Hibernate说到ORM框架，第一个想到的持久层框架应该就是Hibernate，Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的ORM框架，hibernate可以自动生成SQL语句，自动执行。 MyBatis严格来说是一个半ORM框架，相对于Hibernate，它并没有像Hibernate一样完全的ORM，但是正是因为它的半ORM以及简单快速的开发效率，让MyBatis成为现在互联网项目首选的持久层框架之一。 MyBatis与Hibernate两者对比 开发速度 就开发速度而言，Hibernate的真正掌握要比Mybatis来得难些。Mybatis框架相对简单很容易上手，但也相对简陋些。 比起两者的开发速度，不仅仅要考虑到两者的特性及性能，更要根据项目需求去考虑究竟哪一个更适合项目开发，比如：一个项目中用到的复杂查询基本没有，就是简单的增删改查，这样选择hibernate效率就很快了，因为基本的sql语句已经被封装好了，根本不需要你去写sql语句，这就节省了大量的时间，但是对于一个大型项目，复杂语句较多，这样再去选择hibernate就不是一个太好的选择，选择mybatis就会加快许多，而且语句的管理也比较方便。 开发工作量 Hibernate和MyBatis都有相应的代码生成工具。可以生成简单基本的DAO层方法。针对高级查询，Mybatis需要手动编写SQL语句，以及ResultMap。而Hibernate有良好的映射机制，开发者无需关心SQL的生成与结果映射，可以更专注于业务流程。 SQL优化 Hibernate的查询会将表中的所有字段查询出来，这一点会有性能消耗。Hibernate也可以自己写SQL来指定需要查询的字段，但这样就破坏了Hibernate开发的简洁性。而Mybatis的SQL是手动编写的，所以可以按需求指定查询的字段。 Hibernate HQL语句的调优需要将SQL打印出来，而Hibernate的SQL被很多人嫌弃因为太丑了。MyBatis的SQL是自己手动写的所以调整方便。但Hibernate具有自己的日志统计。Mybatis本身不带日志统计，使用Log4j进行日志记录。 对象管理的对比 Hibernate 是完整的对象/关系映射解决方案，它提供了对象状态管理（state management）的功能，使开发者不再需要理会底层数据库系统的细节。也就是说，相对于常见的 JDBC/SQL 持久层方案中需要管理 SQL 语句，Hibernate采用了更自然的面向对象的视角来持久化 Java 应用中的数据。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]}]}