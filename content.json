{"meta":{"title":"Yellow","subtitle":null,"description":null,"author":"Yellow","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2019-06-22T12:11:10.000Z","updated":"2019-08-27T09:17:39.082Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Ronin 一名即将成为程序员的软件工程学生"},{"title":"categories","date":"2019-06-22T12:12:22.000Z","updated":"2019-08-27T09:16:51.762Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"gallery","date":"2019-08-27T09:17:57.000Z","updated":"2019-08-27T09:18:16.257Z","comments":true,"path":"gallery/index.html","permalink":"http://yoursite.com/gallery/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-22T12:12:13.000Z","updated":"2019-08-27T09:17:09.616Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring Boot整合tk.MyBatis","slug":"SpringBoot整合tk.MyBatis","date":"2019-08-28T04:15:15.316Z","updated":"2019-08-28T04:18:15.205Z","comments":true,"path":"2019/08/28/SpringBoot整合tk.MyBatis/","link":"","permalink":"http://yoursite.com/2019/08/28/SpringBoot整合tk.MyBatis/","excerpt":"","text":"tk.mybaits 是基于Mybatis框架开发的一个工具，相较于 mybatis，tk.mybaits 可以不用书写 sql 语句，通过调用它提供的方法实现对单表的数据操作，极大地提高了项目开发效率。 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;com.ronin&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-tk-mybatis&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-tk-mybatis&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- tk.mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;javax.persistence-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- lombok插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml12345678910111213# server portserver: port: 8888# mybatismybatis: type-aliases-package: com.ronin.springboottkmybatis.entity mapper-locations: classpath:mapper/*.xmlspring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;&amp;characterEncoding=utf-8 username: root password: 123456 自定义Mapper接口使用 tk.mybaits 需要自定义一个 Mapper 接口，这个接口不能够被 SpringBootApplication 扫描到，否则会报错，需要创建一个平级的包存放。结构如下： 123456789101112package tk.mybatis.mapper;import tk.mybatis.mapper.common.Mapper;import tk.mybatis.mapper.common.MySqlMapper;/** * 该接口不能被扫描到，否则会出错 * @author 98 * @date 2019/8/26 15:24 */public interface MyMapper&lt;T&gt; extends Mapper&lt;T&gt;, MySqlMapper&lt;T&gt; &#123;&#125; Mapper和Mapper.xmlmapper 只需要继承我们自定义的接口就可以了，不需要写什么方法，tk.mybatis 默认提供了许多方法满足大部分开发需求 1234567891011121314package com.ronin.springboottkmybatis.mapper;import com.ronin.springboottkmybatis.entity.User;import org.springframework.stereotype.Repository;import tk.mybatis.mapper.MyMapper;/** * @author 98 * @date 2019/8/26 15:24 */@Repositorypublic interface UserMapper extends MyMapper&lt;User&gt; &#123;&#125; mapper.xml 也不需要写任何sql语句 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.ronin.springboottkmybatis.mapper.UserMapper\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.ronin.springboottkmybatis.entity.User\"&gt; &lt;result column=\"id\" jdbcType=\"INTEGER\" property=\"id\" /&gt; &lt;result column=\"userName\" jdbcType=\"VARCHAR\" property=\"username\" /&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 测试Resultful API 测试 123456789101112131415161718192021222324252627package com.ronin.springboottkmybatis.controller;import com.ronin.springboottkmybatis.entity.User;import com.ronin.springboottkmybatis.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;/** * @author 98 * @date 2019/8/26 15:24 */@RestControllerpublic class UserController &#123; @Autowired private UserService userService; @GetMapping(\"users\") public String getUsers()&#123; List&lt;User&gt; userList = userService.selectUsers(); return userList.toString(); &#125;&#125; 成功返回数据","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring Boot整合MyBatis","slug":"SpringBoot整合MyBatis","date":"2019-08-27T01:42:36.667Z","updated":"2019-08-28T01:22:46.188Z","comments":true,"path":"2019/08/27/SpringBoot整合MyBatis/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringBoot整合MyBatis/","excerpt":"","text":"SpringBoot 提供了整合 MyBatis 的功能，通过简单的配置就能完成。 pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.ronin&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-mybatis&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-mybatis&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;javax.persistence-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置文件1234567891011121314151617181920server: port: 8080spring: datasource: username: root password: 123456 url: jdbc:mysql://localhost:3306/user?useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Drivermybatis: mapper-locations: classpath:mapper/*Mapper.xml type-aliases-package: com.ronin.springbootmybatis.entity#showSqllogging: level: com: example: mapper : debug 实体类123456789101112131415161718192021222324package com.ronin.springbootmybatis.entity;import lombok.Data;import javax.persistence.Column;import javax.persistence.Id;import javax.persistence.Table;/** * @Author: 98 * @Date: 2019-8-24 21:26 */@Data@Table(name=\"tb_user\")public class User &#123; @Id @Column(name = \"id\") private Integer id; @Column(name = \"username\") private String username;&#125; Mapper 和 Mapper.xml123456789101112131415161718package com.ronin.springbootmybatis.mapper;import com.ronin.springbootmybatis.entity.User;import org.apache.ibatis.annotations.Mapper;import org.springframework.stereotype.Repository;import java.util.List;/** * @Author: 98 * @Date: 2019-8-24 21:29 */@Repositorypublic interface UserMapper &#123; List&lt;User&gt; selectUsers();&#125; 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.ronin.springbootmybatis.mapper.UserMapper\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.ronin.springbootmybatis.entity.User\"&gt; &lt;result column=\"id\" jdbcType=\"INTEGER\" property=\"id\" /&gt; &lt;result column=\"userName\" jdbcType=\"VARCHAR\" property=\"username\" /&gt; &lt;/resultMap&gt; &lt;select id=\"selectUsers\" resultType=\"com.ronin.springbootmybatis.entity.User\"&gt; select * from tb_user &lt;/select&gt;&lt;/mapper&gt; Controller 和 Service123456789101112131415161718192021222324252627package com.ronin.springbootmybatis.controller;import com.ronin.springbootmybatis.entity.User;import com.ronin.springbootmybatis.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;/** * @Author: 98 * @Date: 2019-8-24 21:35 */@RestControllerpublic class UserController &#123; @Autowired private UserService userService; @GetMapping(\"users\") public String getUsers()&#123; List&lt;User&gt; userList = userService.selectUsers(); return userList.toString(); &#125;&#125; 12345678910111213141516171819202122232425package com.ronin.springbootmybatis.service.impl;import com.ronin.springbootmybatis.entity.User;import com.ronin.springbootmybatis.mapper.UserMapper;import com.ronin.springbootmybatis.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * @Author: 98 * @Date: 2019-8-24 21:33 */@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserMapper userMapper; @Override public List&lt;User&gt; selectUsers() &#123; return userMapper.selectUsers(); &#125;&#125; 测试我们通过请求 Restful API，通过返回值观察是否成功 请求返回值为数据库表中数据，整合 MyBatis 成功！！！！","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring Boot整合Spring Data JPA","slug":"SpringBoot整合Spring Data JPA","date":"2019-08-27T01:39:06.512Z","updated":"2019-08-28T01:38:42.186Z","comments":true,"path":"2019/08/27/SpringBoot整合Spring Data JPA/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringBoot整合Spring Data JPA/","excerpt":"","text":"JPAJPA是Java Persistence API的简称，中文名Java持久层API，是SUN公司在JDK 5.0后提出的Java持久化规范，通过注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。 JPA的总体思想和现有Hibernate、TopLink、JDO等ORM框架大体一致。总的来说，JPA包括以下3方面的技术： ORM映射元数据 JPA支持XML和JDK5.0注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中 API 用来操作实体对象，执行CRUD操作，框架在后台替代我们完成所有的事情，开发者从繁琐的JDBC和SQL代码中解脱出来。 查询语言 这是持久化操作中很重要的一个方面，通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。 Spring Data JPA是Spring Data家族的一部分，可以轻松实现基于JPA的存储库。 此模块处理对基于JPA的数据访问层的增强支持。 Spring Data JPA提供的核心接口： Repository 接口 CrudRepository 接口 pagingAndSortingRepository 接口 JpaRepository 接口 JpaSpecificationExecutor 接口 pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.ronin&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-jpa&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-jpa&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml123456789101112131415161718192021# MySqlspring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/user?useUnicode=true&amp;&amp;characterEncoding=utf-8 username: root password: 123456# Spring Data JPA jpa: hibernate: ddl-auto: update show-sql: true# Thymeleaf thymeleaf: cache: false mode: HTML encoding: UTF-8 servlet: content-type: text/html 实体类123456789101112131415161718192021222324252627package com.ronin.springbootjpa.entity;import lombok.Data;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.Id;import javax.persistence.Table;import java.io.Serializable;/** * @Author: 98 * @Date: 2019-8-22 21:59 */@Data@Entity@Table(name = \"tb_user\")public class User implements Serializable &#123; @Id @Column(name = \"id\") private Integer id; @Column(name = \"username\") private String username;&#125; Mapper123456789101112package com.ronin.springbootjpa.mapper;import com.ronin.springbootjpa.entity.User;import org.springframework.data.jpa.repository.JpaRepository;/** * @Author: 98 * @Date: 2019-8-22 22:31 * JpaRepository&lt;User 实体类 ,Integer 主键类型 &gt; */public interface UserMapper extends JpaRepository&lt;User,Integer&gt; &#123;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring Boot热部署","slug":"SpringBoot热部署","date":"2019-08-27T01:37:48.167Z","updated":"2019-08-28T01:35:58.365Z","comments":true,"path":"2019/08/27/SpringBoot热部署/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringBoot热部署/","excerpt":"","text":"目前的Springboot，当发生了任何修改之后，必须关闭后再启动Application类才能够生效，显得略微麻烦。 Springboot提供了热部署的方式，当发现任何类发生了改变，马上通过JVM类加载的方式，加载最新的类到虚拟机中。这样就能够实现项目的热部署运行，修改少量的代码不需要重启项目就能看到效果 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.ronin&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-tools&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-tools&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 热部署插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring Boot整合Thymeleaf模板引擎","slug":"SpringBoot整合Thymeleaf","date":"2019-08-27T01:13:35.725Z","updated":"2019-08-28T01:38:53.689Z","comments":true,"path":"2019/08/27/SpringBoot整合Thymeleaf/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringBoot整合Thymeleaf/","excerpt":"","text":"首先要了解一下什么是 Thymeleaf ！ Thymeleaf 官网：https://www.thymeleaf.org/ Thymeleaf 是 Web 和独立环境的现代服务器端 Java 模板引擎，能够处理HTML，XML，JavaScript，CSS 甚至纯文本。 Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。 Thymeleaf 的主要目标是提供一种优雅和高度可维护的创建模板的方式，在有网络和无网络的环境下皆可运行。为了实现这一点，它建立在自然模板的概念上，将其逻辑注入到模板文件中，不会影响模板被用作设计原型。这改善了设计的沟通，弥补了设计和开发团队之间的差距。 Thymeleaf 也从一开始就设计了Web标准 - 特别是 HTML5 - 允许您创建完全验证的模板，Spring Boot 官方推荐使用 thymeleaf 而不是 JSP。 pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ronin&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-thymeleaf&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;spring-boot-thymeleaf&lt;/name&gt; &lt;description&gt;&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt; &lt;artifactId&gt;nekohtml&lt;/artifactId&gt; &lt;version&gt;1.9.22&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml12345678spring: thymeleaf: #关闭页面缓存 cache: false mode: HTML encoding: UTF-8 servlet: content-type: text/html HTML页面12345678910&lt;!DOCTYPE html SYSTEM &quot;http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-spring4-4.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Hello Thymeleaf&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring Boot入门案例","slug":"SpringBoot入门案例","date":"2019-08-27T00:53:34.733Z","updated":"2019-08-28T01:38:28.559Z","comments":true,"path":"2019/08/27/SpringBoot入门案例/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringBoot入门案例/","excerpt":"","text":"SpringBoot 随着动态语言的流行，为解决 java 开发繁重的配置，低下的开发效率，复杂的部署以及第三方技术集成难度大而诞生。它使用习惯优于配置的理念能够让项目快速的运行，相较于传统的ssm、ssh项目而言，少了许多麻烦的配置文件。 SpringBoot 可以以jar包的方式独立运行，并且在其内部内嵌了 tomcat、jetty 等容器，无须以 war 包形式部署项目。提供了一系列的 starter pom 来简化 Maven 的依赖加载。 IDEA 搭建 SpringBoot 项目 File =&gt; New =&gt; Project 这里选择 Spring Initializr 填写项目有关信息 选择 SpringBoot 提供的 starter 依赖，根据项目需要勾选 项目存放路径 这样一个 SpringBoot 项目就创建成功了，默认的 SpringBoot 项目目录如下，跟 Maven 项目类似： SpringbootDemoApplicaiton ： 整个项目的启动类，通过运行其中的 main 方法快速启动项目 application.properties ：整个项目的配置文件，SpringBoot基于习惯优于配置理念，相较ssm等项目少了许多配置，除了可以使用properties格式，也可以使用 YAML 格式 templates ：项目默认的页面存放文件夹 static ：项目默认静态资源存放文件夹 默认的 pom.xml 文件12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;com.ronin&lt;/groupId&gt; &lt;artifactId&gt;springboot-demo&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; SpringBoot 项目都需要添加一个父级依赖，spring-boot-starter-parent 是一个特殊的 starter，是 spring 官方提供的，里面包含了众多第三方技术的jar包 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt; SpringBoot 的编译插件 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"SpringMVC文件上传","slug":"SpringMVC文件上传","date":"2019-08-27T00:46:26.673Z","updated":"2019-08-28T01:40:06.572Z","comments":true,"path":"2019/08/27/SpringMVC文件上传/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringMVC文件上传/","excerpt":"","text":"SpringMVC 为上传文件提供了良好的支持，SpringMVC 通过 MultipartResolver (Multipart 解析器) 处理的，它是一个接口，有两个实现类:​ CommonsMultipartResolver：依赖于 Apache 下的 jakarta Common FileUpload 项目解析 Multipart 请求，可以在 Spring 的各个版本中使用，只是它要依赖于第三方包才得以实现 StandardServletMultipartResolver：Spring 3.1 版本后的产物，它依赖于 Servlet 3.0 或者更高版本的实现，它不用依赖第三包 前台页面提交表单时，需要设置 enctype=”multipart/form-data” 多段式提交 12345678&lt;form class=\"form-horizontal form-border\" action=\"/upload\" method=\"post\" id=\"form\" enctype=\"multipart/form-data\"&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"col-sm-2\"&gt;&lt;/div&gt; &lt;div class=\"col-sm-8\"&gt; &lt;input type=\"file\" name=\"dropzFile\"/&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; SpringMVC.xml12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd\"&gt; &lt;!-- 上传文件拦截，设置最大上传文件大小 10M = 10*1024*1024(B) = 10485760 bytes --&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"maxUploadSize\" value=\"10485760\"/&gt; &lt;property name=\"defaultEncoding\" value=\"utf-8\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 后台代码12345678910111213141516171819202122232425262728293031/** * 文件上传 * @param dropzFile * @return */ @RequestMapping(value = \"upload\",method = RequestMethod.POST) public Map&lt;String,Object&gt; DropZone(MultipartFile dropzFile,HttpServletRequest request)&#123; //获取文件名 String fileName = dropzFile.getOriginalFilename(); //获取文件后缀名 String fileSuffix = fileName.substring(fileName.lastIndexOf(\".\")); //获取文件上传文件夹路径 String filePath = request.getSession().getServletContext().getRealPath(Const.UPLOAD_PATH); //判断文件夹是否存在,不存在就创建文件夹 File file = new File(filePath); if(! file.exists())&#123; file.mkdirs(); &#125; //UUID替换文件名 String filePrefix = UUID.randomUUID().toString(); file = new File(filePath,filePrefix+fileSuffix); //上传文件 try &#123; dropzFile.transferTo(file); &#125; catch (IOException e) &#123; logger.error(\"文件上传出错！！！\"); &#125; return \"index\"; &#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"SpringMVC拦截器","slug":"SpringMVC拦截器","date":"2019-08-27T00:45:35.201Z","updated":"2019-08-28T01:39:09.127Z","comments":true,"path":"2019/08/27/SpringMVC拦截器/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringMVC拦截器/","excerpt":"","text":"拦截器是 SpringMVC 中一个强大的控件，它可以在进入处理器之前做一些操作，或者在处理器完成后进行操作，甚至是在渲染视图后进行操作。我们可以自己定义一个拦截器，Spring 要求处理器的拦截器都需要实现 org.springframework.web.servlet.HandlerInterceptor 接口，我们来看看该接口的源码： 12345678910111213141516public interface HandlerInterceptor &#123; default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true; &#125; default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123; &#125; default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123; &#125;&#125; HandlerInterceptor 接口中定义了三个方法： preHandle 方法：在处理器之前执行的前置方法，SpringMVC 可以在进入处理器之前处理一些方法，方法默认返回一个 Boolean 值，true 代表放行，false 代表拦截 postHandle 方法：在处理器之后执行的后置方法，处理器的逻辑完成后运行它 afterCompletion 方法：无论是否产生异常都会在渲染视图后执行的方法 拦截器的定义SpringMVC 配置拦截器有两种方式，一种是xml配置，一种是java配置，Spring4之后推荐使用java配置 xml配置 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.5.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.5.xsd \"&gt; &lt;!--配置拦截器, 多个拦截器,顺序执行 --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- /**的意思是所有文件夹及里面的子文件夹 /*是所有文件夹，不含子文件夹 /是web项目的根目录 --&gt; &lt;mvc:mapping path=\"/**\" /&gt; &lt;!-- 需排除拦截的地址 --&gt; &lt;!-- &lt;mvc:exclude-mapping path=\"/userController/login\"/&gt; --&gt; &lt;bean id=\"ManagerInterceptor\" class=\"com.mall.Interceptor.ManagerInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/admin/details\"/&gt; &lt;bean id=\"OrderInterceptor\" class=\"com.mall.Interceptor.OrderInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/shop/personal\"/&gt; &lt;bean id=\"UserInterceptor\" class=\"com.mall.Interceptor.UserInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;&lt;/beans&gt; 这里的 xml 配置中是配置了三个拦截器，bean 节点中的 class 属性值为对应的拦截器全类包路径 java配置 定义一个拦截器实现 HandleInterceptor 接口 123456789101112131415161718192021/** * @Author: 98 * @Date: 2019-8-1 16:41 */public class WebAdminInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 创建一个java类，类上使用 @Configuration 表明这是个配置类 12345678910111213141516171819/** 1. @Author: 98 2. @Date: 2019-8-1 16:52 */@Configurationpublic class InterceptorConfig implements WebMvcConfigurer &#123; @Bean WebAdminInterceptor webAdminInterceptor()&#123; return new WebAdminInterceptor(); &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(webAdminInterceptor()) .addPathPatterns(\"/**\") .excludePathPatterns(\"/static\"); &#125;&#125; 拦截器的执行顺序拦截器的执行顺序可以分成多种情况： 单个拦截器 执行的顺序为：preHandle =&gt; postHandle =&gt; afterCompletion （前提 preHandle 方法返回true） 多个拦截器，preHandle 方法均返回 true 执行的顺序为： preHandle1preHandle2preHandle3 postHandle3 postHandle2 postHandle1 afterCompletion3 afterCompletion2 afterCompletion1 多个拦截器，其中一个或多个拦截器 preHandle 方法返回false，这里我们设置三个拦截器，将第二个拦截器的前置方法返回false preHandle1preHandle2afterCompletion1 当其中的一个 preHandle 方法返回为false后，按照配置的顺序，后面的 preHandle 方法都不会运行，而控制器和所有的后置方法 postHandle 也不会再运行。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"SpringMVC执行流程","slug":"SpringMVC执行流程","date":"2019-08-27T00:43:17.470Z","updated":"2019-08-28T01:40:16.065Z","comments":true,"path":"2019/08/27/SpringMVC执行流程/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringMVC执行流程/","excerpt":"","text":"SpringMVC请求流程SpringMVC中处理请求最为重要的组件就是：DispatcherServlet，在处理用户请求时，SpringMVC底层的请求流程如下图： 用户端发起请求到后台服务器，请求被前端控制器（DispatcherServlet）拦截 前端控制器拦截到请求后，将请求信息交给处理器映射器（HandlerMapping）查找Handler 处理器映射器向前端控制器返回处理器（Handler） 前端控制器得到处理器后调用处理器适配器（HandlerAdapter）执行Handler 处理器适配器执行Handler Handler根据路径找到对应的Controller方法执行完成后给适配器返回模型和视图对象（ModelAndView） 处理器适配器向前端控制器返回ModelAndView 前端控制器请求视图解析器（ViewResolver）进行视图解析 视图解析器向前端控制器返回view 前端控制器进行视图渲染 前端控制器向用户响应结果 组件说明每一次用户端请求SpringMVC都会执行一遍这样的流程，在这一流程中存在几个SpringMVC中重要的组件： DispatcherServlet （前端控制器） 用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。 HandlerMapping （处理器映射器） HandlerMapping负责根据用户请求url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 HandlerAdapter （处理器适配器） 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 ViewResolver （视图解析器） View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"SpringMVC入门案例","slug":"SpringMVC入门案例","date":"2019-08-27T00:42:09.463Z","updated":"2019-08-28T01:39:52.169Z","comments":true,"path":"2019/08/27/SpringMVC入门案例/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringMVC入门案例/","excerpt":"","text":"web.xml配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app version=\"3.0\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"&gt; &lt;!-- Spring配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/spring/spring-config*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Spring监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 字符集过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;Encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;Encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 配置系统变量 contextConfigLocation，SpringMVC会根据配置的路径加载配置文件 ContextLoaderListener 实现了接口 ServletContextListener，监听项目启动，用于Spring IoC容器初始化 配置 DispatcherServlet 我们给了一个 contextConfigLocation，SpringMVC会到这个路径下读取配置文件，如果不配置这个属性，SpringMVC会默认读取 /WEB-INF/dispatcher-servlet.xml 文件，没读取到会抛出异常 DispatcherServlet 拦截请求的后缀有多种方式：1. *.do 2. *.action 3. / 4. / * springmvc.xml12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.5.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.5.xsd\"&gt; &lt;!-- 扫描注解 --&gt; &lt;context:component-scan base-package=\"com.ronin.blog.controller\"/&gt; &lt;!-- 配置注解驱动 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 静态资源放行 --&gt; &lt;mvc:resources mapping=\"/static/**\" location=\"/static/\" /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 视图解析器中配置返回视图的前缀和后缀，SpringMVC根据返回的值拼接后到对应的路径下查找 Controller完成了配置文件的书写，在 /WEB-INF/jsp/ 路径下创建一个 index.jsp 页面 12345678910111213141516@Controllerpublic class ArticleController &#123; /** * 页面跳转 * @return */ @RequestMapping(value = \"index\",method = RequestMethod.GET) public ModelAndView index()&#123; //创建模型视图对象 ModelAndView mav = new ModelAndView(); //添加视图 mav.setViewName(\"index\"); //返回模型和视图 return mav; &#125;&#125; 启动项目，访问对应的请求路径，实现页面跳转！","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"SpringMVC","slug":"SpringMVC","date":"2019-08-27T00:40:35.905Z","updated":"2019-08-28T01:39:00.555Z","comments":true,"path":"2019/08/27/SpringMVC/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringMVC/","excerpt":"","text":"Spring Web MVC是基于Servlet API构建的原始Web框架，从一开始就包含在Spring Framework中。正式名称“Spring Web MVC”来自其源模块（spring-webmvc）的名称，但它通常被称为“Spring MVC”。 与Spring Web MVC并行，Spring Framework 5.0引入了一个反应堆栈Web框架，其名称“Spring WebFlux”也基于其源模块（spring-webflux）。 MVC设计概述MVC 设计不仅限于 Java Web 应用，设计的根本原因在于解耦各个模块，早期的 Java Web 开发中，主要是 JSP+Java Bean 模式，我们称之为 Model1 时代。可以很容易看出，Model1时代中 JSP 和 Java Bean 之间的耦合十分严重，Java 和 Html 也耦合在一起，很快 Model1 时代就被 Servlet+JSP+Java Bean 替代了。相对于 Model1 多了一个 Servlet 组件，Servlet 组件作为主要的控制器，用来处理浏览器发来的请求，这样的模式就成为 MVC 模式，Servlet 为控制层（Controller），JSP 为视图层（view），Java Bean 为模型层（Modal）。 SpringMVC 架构为解决持久层中一直未处理好的数据库事务的编程，又为了迎合 NoSQL 的强势崛起，Spring MVC 给出了方案：传统的模型层被拆分为了业务层(Service)和数据访问层（DAO,Data Access Object）。 在 Service 下可以通过 Spring 的声明式事务操作数据访问层，而在业务层上还允许我们访问 NoSQL ，这样就能够满足异军突起的 NoSQL 的使用了，它可以大大提高互联网系统的性能。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring事务","slug":"Spring事务","date":"2019-07-21T10:14:26.844Z","updated":"2019-08-28T01:40:29.918Z","comments":true,"path":"2019/07/21/Spring事务/","link":"","permalink":"http://yoursite.com/2019/07/21/Spring事务/","excerpt":"","text":"事务是指逻辑上的一组操作，这组操作要么全部成功，要么就一同失败。 事务的四大特性： 原子性：事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都失败； 隔离性：当多个用户并发访问数据库时，数据库为每一个用户开启的事务，不被其他事务的操作所干扰，多个并发事务之间要相互隔离； 一致性：事务操作前后数据必须处于一致状态； 持久性：一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便在数据库系统遇到故障的情况下也不会丢失事物的操作。 Spring事务的隔离级别事务隔离级别，就是为了解决上面几种问题而诞生的。为什么要有事务隔离级别，因为事务隔离级别越高，在并发下会产生的问题就越少，但同时付出的性能消耗也将越大，因此很多时候必须在并发性和性能之间做一个权衡。所以设立了几种事务隔离级别，以便让不同的项目可以根据自己项目的并发情况选择合适的事务隔离级别，对于在事务隔离级别之外会产生的并发问题，在代码中做补偿。 事务隔离级别有4种，但是Spring会提供给用户5种: DEFAULT 默认隔离级别，每种数据库支持的事务隔离级别不一样，如果Spring配置事务时将isolation设置为这个值的话，那么将使用底层数据库的默认事务隔离级别。顺便说一句，如果使用的MySQL，可以使用”select @@tx_isolation”来查看默认的事务隔离级别 READ_UNCOMMITTED 读未提交，即能够读取到没有被提交的数据，所以很明显这个级别的隔离机制无法解决脏读、不可重复读、幻读中的任何一种，因此很少使用 READ_COMMITED 读已提交，即能够读到那些已经提交的数据，自然能够防止脏读，但是无法限制不可重复读和幻读 REPEATABLE_READ 重复读取，即在数据读出来之后加锁，类似”select * from XXX for update”，明确数据读取出来就是为了更新用的，所以要加一把锁，防止别人修改它。REPEATABLE_READ的意思也类似，读取了一条数据，这个事务不结束，别的事务就不可以改这条记录，这样就解决了脏读、不可重复读的问题，但是幻读的问题还是无法解决 SERLALIZABLE 串行化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务，这样就解决了脏读、不可重复读和幻读的问题了 Spring事务传播行为 传播行为 含义 备注 REQUIRED 当方法调用时，如果不存在当前事务，那么就创建事务；如果当前方法已经存在事务，就沿用之前的事务 这个是Spring默认的传播行为 SUPPORTS 当方法调用时，如果不存在当前事务，那么就不启用事务；如果当前方法已经存在事务，就沿用之前的事务 - MANDATORY 方法必须在事务内运行 如果不存在当前事务，抛出异常 REQUIRES_NEW 无论是否存在当前事务，方法都会在新的事务中运行 事务管理器会打开新的事务运行该方法 NOT_SUPPORTED 不支持事务，如果不存在当前事务也不会创建事务；如果存在当前事务就挂起它，知道方法结束后才恢复当前事务 适用于不需要事务的SQL NEVER 不支持事务，只有在没有事务的环境中才能运行它 如果方法存在当前事务，抛出异常 NESTED 嵌套事务，调用方法如果抛出异常只回滚自己内部执行的SQL，而不回滚主方法的SQL 它的实现存在两种情况，如果当前数据库支持保存点，它就会在当前事务上使用保存点技术；如果发生异常则将方法内执行的SQL回滚到保存点上，不是全部回滚，否则就等同于REQUIRES_NEW创建新的事务运行方法代码 XML配置事务1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 配置数据源 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;&lt;/bean&gt;&lt;!-- 配置事务 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt; &lt;!-- 配置事务通知 --&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 以方法为单位,指定方法应用什么事务属性 isolation:隔离级别 propagation:传播行为 read-only:是否只读 --&gt; &lt;tx:method name=&quot;save*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt; &lt;tx:method name=&quot;persist*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt; &lt;tx:method name=&quot;update*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt; &lt;tx:method name=&quot;modify*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt; &lt;tx:method name=&quot;delete*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt; &lt;tx:method name=&quot;remove*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt; &lt;tx:method name=&quot;get*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;find*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;transfer&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 配置织入 --&gt;&lt;aop:config&gt; &lt;!-- 配置切点 --&gt; &lt;aop:pointcut expression=&quot;execution(* service.*ServiceImpl.*(..))&quot; id=&quot;txPc&quot;/&gt; &lt;!-- 配置切面：通知+切点 --&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPc&quot;/&gt;&lt;/aop:config&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring 整合 MyBatis","slug":"Spring 整合 MyBatis","date":"2019-07-21T10:12:18.183Z","updated":"2019-08-28T01:34:17.703Z","comments":true,"path":"2019/07/21/Spring 整合 MyBatis/","link":"","permalink":"http://yoursite.com/2019/07/21/Spring 整合 MyBatis/","excerpt":"","text":"Spring配置文件spring-config-druid.xml 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd\"&gt; &lt;!-- 配置文件 --&gt; &lt;context:property-placeholder location=\"classpath:config/jdbc.properties\"/&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/bean&gt;&lt;/beans&gt; spring-config-mybatis.xml 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd\"&gt; &lt;!-- SqlSessionFactory --&gt; &lt;bean id=\"SqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!-- SqlMapConfig文件 --&gt; &lt;property name=\"configLocation\" value=\"classpath:config/sqlMapConfig.xml\"/&gt; &lt;!-- 映射文件 --&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"/&gt; &lt;!-- 设置别名 --&gt; &lt;property name=\"typeAliasesPackage\" value=\" 实体类全路径包名 \"/&gt; &lt;/bean&gt; &lt;!-- 扫描Mapper --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\" Mapper映射文件全包名 \"/&gt; &lt;/bean&gt;&lt;/beans&gt; sqlMapConfig.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 全局参数 --&gt; &lt;settings&gt; &lt;!-- 打印 SQL 语句 --&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\" /&gt; &lt;!-- 使全局的映射器启用或禁用缓存。 --&gt; &lt;setting name=\"cacheEnabled\" value=\"false\"/&gt; &lt;!-- 全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载。 --&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!-- 当启用时，有延迟加载属性的对象在被调用时将会完全加载任意属性。否则，每种属性将会按需要加载。 --&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"true\"/&gt; &lt;!-- 是否允许单条 SQL 返回多个数据集 (取决于驱动的兼容性) default:true --&gt; &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt; &lt;!-- 是否可以使用列的别名 (取决于驱动的兼容性) default:true --&gt; &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt; &lt;!-- 允许 JDBC 生成主键。需要驱动器支持。如果设为了 true，这个设置将强制使用被生成的主键，有一些驱动器不兼容不过仍然可以执行。 default:false --&gt; &lt;setting name=\"useGeneratedKeys\" value=\"false\"/&gt; &lt;!-- 指定 MyBatis 如何自动映射 数据基表的列 NONE：不映射 PARTIAL：部分 FULL:全部 --&gt; &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt; &lt;!-- 这是默认的执行类型 （SIMPLE: 简单； REUSE: 执行器可能重复使用prepared statements语句；BATCH: 执行器可以重复执行语句和批量更新） --&gt; &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/&gt; &lt;!-- 使用驼峰命名法转换字段。 --&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;!-- 设置本地缓存范围 session:就会有数据的共享 statement:语句范围 (这样就不会有数据的共享 ) defalut:session --&gt; &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt; &lt;!-- 设置 JDBC 类型为空时,某些驱动程序 要指定值, default:OTHER，插入空值时不需要指定类型 --&gt; &lt;setting name=\"jdbcTypeForNull\" value=\"NULL\"/&gt; &lt;/settings&gt; &lt;/configuration&gt; web.xml 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!-- Spring配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/spring/spring-config*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Spring监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring JdbcTemplate","slug":"Spring JdbcTemplate","date":"2019-07-21T10:11:23.968Z","updated":"2019-08-28T01:34:01.331Z","comments":true,"path":"2019/07/21/Spring JdbcTemplate/","link":"","permalink":"http://yoursite.com/2019/07/21/Spring JdbcTemplate/","excerpt":"","text":"JdbcTemplate是Spring框架自带的对JDBC操作的封装，目的是提供统一的模板方法使对数据库的操作更加方便、友好，效率也不错。但是功能还是不够强大（比如不支持级联属性），在实际应用中还需要和hibernate、mybaties等框架混合使用。 传统JDBC弊端传统的 JDBC 即使是执行一条简单的 SQL 过程都不简单，先是打开数据库连接执行 SQL，组装结果，最后关闭资源，其中包含了太多的 try…catch…finally… 语句，造成代码泛滥，数据库资源的打开、关闭都是定性的，事务提交回滚等等都是比较固定的模式，导致代码的可读性和可维护性急剧降低。 JdbcTemplate配置数据库连接配置文件,db.properties 1234jdbc.username=rootjdbc.password=123456jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/test XML配置，第三方连接池使用阿里巴巴的 Druid 123456789101112131415&lt;!-- 配置文件 --&gt;&lt;context:property-placeholder location=&quot;classpath:config/jdbc.properties&quot;/&gt;&lt;!-- 数据库连接池 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt;&lt;!-- 配置JdbcTemplate实例 --&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt; 测试方法 1234567//启动IoC容器ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);//获取IoC容器中JdbcTemplate实例JdbcTemplate jdbcTemplate=(JdbcTemplate) ctx.getBean(&quot;jdbcTemplate&quot;);String sql=&quot;insert into user (name,age) values (?,?)&quot;;int count= jdbcTemplate.update(sql, new Object[]&#123;&quot;tom&quot;,3&#125;);System.out.println(count); JdbcTemplate的增删改查12345678910111213141516public static void main(String[] args)&#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取IoC容器中JdbcTemplate实例 JdbcTemplate jdbcTemplate=(JdbcTemplate) ctx.getBean(&quot;jdbcTemplate&quot;); JdbcTemplate test = new JdbcTemplate(); //实例化对象 User user = new User(); user.setId(1L); user.setName(&quot;tom&quot;); user.setAge(20); //执行操作 test.insertUser(jdbcTemplate,user); List&lt;User&gt; UserList = test.findUser(jdbcTemplate); test.updateUser(jdbcTemplate,user); test.deleteUser(1L);&#125; 1234567/** ** 插入方法**/public int insertUser(JdbcTemplate jdbcTemplate,User user)&#123; String sql = &quot;insert into t_user(id,name,age) values(?,?,?)&quot;; return jdbcTemplate.update(sql,user.getId(),user.getName(),user.getAge());&#125; 1234567/** ** 删除方法**/public int deletetUser(JdbcTemplate jdbcTemplate,Long id)&#123; String sql = &quot;delete from t_user where id = ?&quot;; return jdbcTemplate.update(sql,id);&#125; 1234567/** ** 更新方法**/public int updateUser(JdbcTemplate jdbcTemplate,User user)&#123; String sql = &quot;update t_user set name = ?,age = ? where id = ?&quot;; return jdbcTemplate.update(sql,user.getName(),user.getAge(),user.getId());&#125; 123456789101112/** ** 查询用户列表**/public List&lt;User&gt; findUser(JdbcTemplate jdbcTemplate,User user)&#123; String sql = &quot;select * from t_user&quot;; RowMapper&lt;User&gt; rowMapper = new BeanPropertyRowMapper&lt;User&gt;(User.class); List&lt;User&gt; list= jdbcTemplate.query(sql, rowMapper); for (User user : list) &#123; System.out.println(user); &#125; return list;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring AOP","slug":"Spring AOP","date":"2019-07-21T10:10:43.034Z","updated":"2019-08-28T01:33:36.532Z","comments":true,"path":"2019/07/21/Spring AOP/","link":"","permalink":"http://yoursite.com/2019/07/21/Spring AOP/","excerpt":"","text":"AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 AOP 技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。 AOP 使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 AOP术语 切面（Aspect） 类是对物体特征的抽象，切面就是对横切关注点的抽象，例如数据库的事务贯穿了整个代码层面，这就是一个切面，它可以定义后面需要的各类通知、切点和引入内容。 通知（Advice） 通知是切面开启后，切面的方法。它根据在代理对象真实方法调用前后的顺序和逻辑区分。 前置通知（before）：在动态代理反射原有对象方法或者执行环绕通知前执行的通知功能。 后置通知（after）：在动态代理反射原有对象方法或者执行环绕通知后执行的通知功能。不论是否抛出异常都会执行。 返回通知（afterReturning）：在动态代理反射原有对象方法或者执行环绕通知后正常返回（无异常）执行的通知功能。 异常通知（afterThrowing）：在动态代理反射原有对象方法或者执行环绕通知产生异常后执行的通知功能。 环绕通知（around）：在动态代理中，它可以取代当前被拦截对象的方法，提供回调原有被拦截对象的方法。 引入（Introduction）引入允许我们在现有的类里添加自定义的类和方法。 切点（Pointcut）这是一个告诉 Spring AOP 在什么时候启动拦截并织入对应的流程中，因为并不是所有的开发都需要启动 AOP，它往往通过切点表达式进行限定。 连接点（Join point）连接点对应的是具体需要拦截的东西，比如通过切点的切点表达式去判断哪个方法是连接点，从而织入对应的通知。 织入（Weaving）织入是一个生成代理对象并将切面内容放入到流程中的过程。实际代理的方法分为动态代理和静态代理。 XML配置开发Spring AOPSpring 提供了两种方式配置 AOP，注解配置和XML文件配置，在这我们只介绍XML文件配置方式。| AOP配置元素 | 用途 | 备注 || ——————- | ——————————– | —————————- || aop:advisor | 定义AOP的通知器 | 一种较老的方式，目前很少使用 || aop:aspect | 定义一个切面 | / || aop:before | 定义前置通知 | / || aop:after | 定义后置通知 | / || aop:around | 定义环绕方式 | / || aop:after-returning | 定义返回通知 | / || aop:after-throwing | 定义异常通知 | / || aop:config | 顶层的AOP配置元素 | AOP的配置根节点 || aop:declare-parents | 给通知引入新的额外接口，增强功能 | / || aop:pointcut | 定义切点 | / | 简单的 AOP 案例：定义接口 1234public interface PhoneService&#123; public void call(); public void send_sms();&#125; 实现类 12345678public class PhoneServiceImpl&#123; public void call()&#123; System.out.println(&quot;***打电话&quot;); &#125; public void send_sms()&#123; System.out.println(&quot;***发短信&quot;); &#125;&#125; 通知类 12345678pulbic class MyAdvice&#123; public void beforeLog()&#123; System.out.println(“准备执行移动业务======”); &#125; public void afterLog()&#123; System.out.println(&quot;本次业务需要10元======&quot;); &#125;&#125; XML配置 1234567891011&lt;bean id=&quot;phone&quot; class=&quot;com.etc.service.impl.PhoneServiceImpl&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;myAdvice&quot; class=&quot;com.etc.common.MyAdvice&quot;&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;!—配置切点，即需要将方法织入的位置--&gt; &lt;aop:pointcut id=&quot;pc&quot; expression=“execution(* com.etc.service.impl.PhoneServiceImpl.*(...))”/&gt; &lt;!—配置切面feeAdvice是Bean的id --&gt; &lt;aop:aspect ref=&quot;myAdvice&quot;&gt; &lt;aop:before method=&quot;beforLog&quot; pointcut-ref=&quot;pc&quot;/&gt; &lt;aop:after method=&quot;afterLog&quot; pointcut-ref=&quot;pc&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; &lt; aop:aspect &gt;：用于定义切面类&lt; aop:before &gt;：定义前置通知&lt; aop:after &gt;：定义后置通知&lt; aop:after-throwing &gt;：定义异常通知&lt; aop:after-retruning &gt;：定义返回通知","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring 装配 Bean","slug":"Spring 装配 Bean","date":"2019-07-21T10:10:04.129Z","updated":"2019-08-28T01:34:26.079Z","comments":true,"path":"2019/07/21/Spring 装配 Bean/","link":"","permalink":"http://yoursite.com/2019/07/21/Spring 装配 Bean/","excerpt":"","text":"如何将自己开发的 Bean 装配到 Spring IOC 容器中，大部分情况下我们可以使用 ApplicationContext 的具体实现类，因为对应的 Spring IOC 容器功能强大，在 Spring 当中提供了3中方式进行配置： XML配置 Java的接口和类中实现配置 隐式Bean的发现机制和自动装配原则 XML配置Bean12345678910&lt;bean id=&quot;source&quot; class=&quot;com.ssm.entity.Source&quot;&gt; &lt;property name=&quot;fruit&quot; value=&quot;橙汁&quot;/&gt; &lt;property name=&quot;sugar&quot; value=&quot;少糖&quot;/&gt; &lt;property name=&quot;size&quot; value=&quot;大杯&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;juiceMaker&quot; class=&quot;com.ssm.entity.JuiceMaker&quot;&gt; &lt;property name=&quot;beverageShop&quot; value=&quot;贡茶&quot;/&gt; &lt;property name=&quot;source&quot; ref=&quot;source&quot;/&gt;&lt;/bean&gt; id 属性是 Spring 找到这个 Bean 的编号，id 不是必须的属性，如果没有声明 id，Spring 会采用“全限类名#{number}”的格式生成编号。class 是一个类的全限定名。property 元素是定义类的属性，name 属性定义属性名称，value 定义值。ref 属性是引用对应的 Bean 的 id。 注解配置Bean在 Spring3.0 之后已经不再推荐使用 XML 的方式装配 Bean，更多时候推荐使用注解配置，使用注解可以大量减少 XML 的配置代码，注解既能实现 XML 的功能，也提供了自动装配的功能，满足了“约定优于配置”的开发原则。 Spring 中提供了两种方式让 Spring IOC 容器发现 Bean： 组件扫描：通过定义资源的方式，让 Spring IOC 容器扫描对应的包，从而把 Bean 装配进来。 自动装配：通过注解定义，使得一些依赖关系可以通过注解完成。 @Component12345678@Component(value=&quot;user&quot;)public class User&#123; @Value(&quot;1&quot;) private Long id; @Value(&quot;user_name&quot;) private String userName; ................&#125; @Component 注解代表 Spring IOC 会把这个类扫描生成 Bean 实例，其中 value 属性的值等同于 XML 方式中的 id，value 值不写 Spring IOC 容器就默认首字母为小写的类名替代。@Value 代表的是值的注入。 123@ComponentScanpublic class PojoConfig&#123;&#125; 这时候需要在同一个包下创建一个 Java Config 告诉 Spring IOC 容器到哪里去扫描对象，@ComponentScan 代表进行扫描，默认是扫描当前包下的路径。它有两个配置选项，第一个是 basePackages，第二个是 basePackageClasses。 @Autowired在 Spring IOC 容器中，Spring 是先完成 Bean 的定义和生成，然后寻找需要注入的资源，当 Spring 生成所有的 Bean 后，如果发现了这个注解，它就会在 Bean 中查找对应的类型注入。 123public interface UserService&#123; public void UserInfo();&#125; 1234567@Controllerpublic class UserController&#123; @Autowired private UserService userService; ...................&#125; 这里我们定义一个 User 的接口，在 Controller 层通过 @Autowired 注解注入，Spring 在扫描到这个注解后会自动寻找对应的类型注入。 有时，IOC 容器会寻找类型失败，默认情况会抛出异常，可以通过 @Autowired(required = false) 将其设置为不一定成功注入，当 IOC 容器没有找到对应的类型时，不会抛出异常。 在少部分情况下，一个接口会有多个实现类，使用 @Autowired 自动装配时可能会出现 IOC 容器不知道使用哪个实现类装配的问题，导致注入失败，原因是 IOC 容器通过类型（by type）获取 Bean，多个实现类导致 Bean 不唯一，可以通过 @Primary（首要注入）注解和 @Qualifier（采用名称查找）注解解决这类问题。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring 依赖注入（DI）","slug":"Spring 依赖注入（DI）","date":"2019-07-21T10:09:24.955Z","updated":"2019-08-28T01:34:09.601Z","comments":true,"path":"2019/07/21/Spring 依赖注入（DI）/","link":"","permalink":"http://yoursite.com/2019/07/21/Spring 依赖注入（DI）/","excerpt":"","text":"在实际环境中实现 IOC 容器的方式主要分为两大类，一类是依赖查找，依赖查找是通过资源定位，把对应的资源查找回来；另一类是依赖注入，Spring 主要使用的是依赖注入。一般，依赖注入可以分为三种方式： 构造器注入 setter 注入 接口注入 构造器注入和 setter 注入是主要的方式，而接口注入是从别的地方注入的方式，例如web工程中配置的数据源是通过服务器配置的，可以通过 JNDI 的形式通过接口将它注入 Spring IOC 容器中。 构造器注入构造器注入依赖于构造方法实现，构造方法可以是有参数的或者是无参数的。大部分情况下我们是通过类的构造方法创建类对象，Spring 可以采用反射的方式，通过使用构造方法来完成注入，这就是构造器注入的原理。 构造器注入代码： 12345678910public class User&#123; private int id; private String name; private String note; ............................... public User(String name,String note)&#123; this.name = name; this.note = note; &#125;&#125; 1234&lt;bean id=&quot;user&quot; class=&quot;com.ssm.entity.User&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;总经理&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;管理者&quot;/&gt;&lt;/bean&gt; constructor-arg 元素用于定义类构造方法的参数，其中 index 用于定义参数的位置，value 是设置值。 构造器注入比较简单，但是缺点也很明显，参数少时可读性比较好，当参数量较多时，构造器注入就比较复杂，代码维护难。 setter 注入setter 注入时 Spring 中最主流的注入方式，它利用 Java Bean 规范定义的 setter 方法完成注入，灵活并且代码可读性高，它消除了使用构造器注入时参数过多的麻烦，通过 setter 注入为其设置的值，其实也是通过 Java 的反射技术实现的。 1234&lt;bean id=&quot;user&quot; class=&quot;com.ssm.entity.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;工程师&quot;/&gt; &lt;property name=&quot;note&quot; value=&quot;重要人员&quot;/&gt;&lt;/bean&gt; Spring 会通过反射调用没有参数的构造方法生成对象，同时通过反射对应的 setter 方法注入配置的值，这种方式是 Spring 最为主要的方式，应用十分广泛。 接口注入有些时候资源是来自外界，比如数据库连接资源完全可以在 Tomcat 下配置，通过 JNDI 的形式去获取它，这样数据库链接资源是属于开发工程外的资源，这时就可以使用接口注入的形式获取它。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring IOC","slug":"Spring IOC","date":"2019-07-21T10:06:22.726Z","updated":"2019-08-28T01:33:48.188Z","comments":true,"path":"2019/07/21/Spring IOC/","link":"","permalink":"http://yoursite.com/2019/07/21/Spring IOC/","excerpt":"","text":"传统编码创建对象时，我们总是通过 new 方法主动创建对象，但是在现实中，一个复杂的系统面对着成千上百的对象，如果每一个对象都通过手动创建、维护，就会十分的复杂。更多时候，我们希望通过简单方法获得想要的对象，这就是被动创建对象。 被动创建对象，不需要程序员手动一个个 new 出对象，只需要给出想要对象的描述就可以得到对象。在Spring框架中，这样的效果可以通过 IOC 实现。 Spring IOCIOC又称控制反转，就是将对象的创建权利发生反转，从之前自己手动的创建对象，现在变成由Spring容器帮助创建生成新的对象，程序员无需关注对象的创建过程，无需关注对象的生命周期。 举个例子，当你想喝水果饮料时，有两种选择，第一种是自己买水果来榨汁喝，第二种是去饮料店点一杯水果饮料。第一种解决方法就类似于手动 new 出一个对象，第二种解决方法是通过第三方直接获取对象。 这个例子包含了控制反转的思想，由自己榨饮料转换成通过第三方得到饮料，将制造饮料的过程由自己反转给第三方，这就是控制反转。而在Spring中，实现控制反转的就是 IOC 容器，其实现方法是依赖注入（Dependency Injection,DI）。 IOC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，指导如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了 IOC 容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松耦合关系，使得程序的整个体系结构变得非常灵活。 其实 IOC 对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在 IOC/DI 思想中，应用程序就变成被动的了，被动的等待 IOC 容器来创建并注入它所需要的资源了。 Spring IOC 容器Spring IOC 容器的设计主要是基于 BeanFactory 和 ApplicationContext 两个接口，其中 ApplicationContext 是 BeanFactory 的子接口之一，BeanFactory 是 Spring IOC 容器所定义的最底层接口。ApplicationContext 是对 BeanFactory 功能做了更多扩展，在大部分场景下，都是使用 ApplicationContext 作为 Spring IOC 容器。 Spring IOC 容器初始化 BeanBean 的定义和初始化在 Spring IOC 容器中是两大步骤，Bean 的定义分为3步： Resource 定位，这步是 Spring IOC 容器根据开发者的配置，进行资源定位。 BeanDefinition 的载入，这个时候只是将 Resource 定位到的信息保存到 Bean 定义（BeanDefinition）中，此时不会创建 Bean 实例。 BeanDefinition 的注册，这个过程将 BeanDefinition 的信息发布到 Spring IOC 容器中，此时仍然没有创建 Bean 的实例。 做完这3步，Bean 在 Spring IOC 容器中就被定义了，但是没有被初始化，更没有完成依赖注入，这时它还不能完全使用，对于初始化和依赖注入，Spring Bean 还有一个配置——lazy-init（是否初始化 Spring Bean）。默认值为 default，实际值为 false，也就是 Spring IOC 默认自动初始化 Bean，如果设置为 true，就只有在使用 Spring IOC 容器的 getBean 方法获取时才会被初始化，完成依赖注入。 Spring Bean 生命周期图","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring","slug":"Spring","date":"2019-07-21T10:04:31.400Z","updated":"2019-08-28T01:34:34.099Z","comments":true,"path":"2019/07/21/Spring/","link":"","permalink":"http://yoursite.com/2019/07/21/Spring/","excerpt":"","text":"什么是SpringSpring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring的核心是控制反转（IOC）和面向切面（AOP）。 简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。 Spring起源要谈Spring的历史，就要先谈J2EE。J2EE应用程序的广泛实现是在1999年和2000年开始的，它的出现带来了诸如事务管理之类的核心中间层概念的标准化，但是在实践中并没有获得绝对的成功，因为开发效率，开发难度和实际的性能都令人失望。曾经使用过EJB开发JAVA EE应用的人，一定知道，在EJB开始的学习和应用非常的艰苦，很多东西都不能一下子就很容易的理解。EJB要严格地实现各种不同类型的接口，类似的或者重复的代码大量存在。而配置也是复杂和单调，同样使用JNDI进行对象查找的代码也是单调而枯燥。虽然有一些开发工作随着xdoclet的出现，而有所缓解，但是学习EJB的高昂代价，和极低的开发效率，极高的资源消耗，都造成了EJB的使用困难。而Spring出现的初衷就是为了解决类似的这些问题。 Spring的一个最大的目的就是使JAVA EE开发更加容易。同时，Spring之所以与Struts、Hibernate等单层框架不同，是因为Spring致力于提供一个以统一的、高效的方式构造整个应用，并且可以将单层框架以最佳的组合揉和在一起建立一个连贯的体系。可以说Spring是一个提供了更完善开发环境的一个框架，可以为POJO(Plain Ordinary Java Object)对象提供企业级的服务。Spring的形成，最初来自Rod Jahnson所著的一本很有影响力的书籍《Expert One-on-One J2EE Design and Development》，就是在这本书中第一次出现了Spring的一些核心思想，该书出版于2002年。另外一本书《Expert One-on-One J2EE Development without EJB》，更进一步阐述了在不使用EJB开发JAVA EE企业级应用的一些设计思想和具体的做法。 Spring优点 容易解耦，简化开发 通过Spring提供的IoC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。有了Spring，用户不必再为单实例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。 支持AOP（面向切面编程） 通过Spring提供的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。 支持事务 在Spring中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。 程序容易调试 可以用非容器依赖的编程方式进行几乎所有的测试工作，在Spring里，测试不再是昂贵的操作，而是随手可做的事情。例如：Spring对Junit4支持，可以通过注解方便的测试Spring程序。 方便集成各种优秀框架 Spring不排斥各种优秀的开源框架，相反，Spring可以降低各种框架的使用难度，Spring提供了对各种优秀框架（如MyBatis、SpringMVC、Hibernate）等的直接支持。 降低Java EE API的使用难度 Spring对很多难用的Java EE API（如JDBC，JavaMail，远程调用等）提供了一个薄薄的封装层，通过Spring的简易封装，这些Java EE API的使用难度大为降低。 7. JavaBean提供了应用程序配置的最好方法Spring框架结构1、Spring Core（核心容器）：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 2、Spring Context（上下文）：Spring 上下文是一个配置文件，向 Spring框架提供上下文信息。Spring 上下文包括企业服务，例如JNDI、EJB、电子邮件、国际化、校验和调度功能。 3、Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。 4、Spring DAO：JDBCDAO抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 5、Spring ORM：Spring 框架插入了若干个ORM框架，从而提供了 ORM 的对象关系工具，其中包括JDO、Hibernate和iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 6、Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 7、Spring MVC 框架：MVC框架是一个全功能的构建 Web应用程序的 MVC 实现。通过策略接口，MVC框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。模型由javabean构成，存放于Map；视图是一个接口，负责显示模型；控制器表示逻辑代码，是Controller的实现。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Mybatis运行原理","slug":"MyBatis运行原理","date":"2019-06-23T15:52:40.000Z","updated":"2019-08-28T01:33:15.587Z","comments":true,"path":"2019/06/23/MyBatis运行原理/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis运行原理/","excerpt":"","text":"原理MyBatis的运行过程分为两大步： 读取配置文件缓存到Configuration对象中，用于创建SqlSessionFactory SqlSession的执行过程构建SqlSessionFactory过程 通过 org.apache.ibatis.builder.xml.XMLConfigBuilder 解析配置的XML文件，读出所配置的参数，并将读取的内容存入 org.apache.ibatis.session.Configuration 类对象中。而Configuration采用的是单例模式，几乎所有的MyBatis配置内容都会存放在这个单例对象中。 使用Configuration对象创建SqlSessionFactory。MyBatis中的SqlSessionFactory是一个接口，不是一个实现类，所以MyBatis提供了一个默认的实现类 org.apache.ibatis.session.defaults.DefaultSqlSessionFactory。在大部分的情况下没必要自己去创建SqlSessionFactory的实现类，这种创建方式就是一种Builder模式。 XMLConfigBuilder中解析XML方法源码： 12345678910111213141516171819202122232425262728public class XMLConfigBuilder extends BaseBuilder &#123; ...................... public Configuration parse() &#123; if (parsed) &#123; throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;); &#125; parsed = true; parseConfiguration(parser.evalNode(&quot;/configuration&quot;)); return configuration; &#125; private void parseConfiguration(XNode root) &#123; try &#123; propertiesElement(root.evalNode(&quot;properties&quot;)); //issue #117 read properties first typeAliasesElement(root.evalNode(&quot;typeAliases&quot;)); pluginElement(root.evalNode(&quot;plugins&quot;)); objectFactoryElement(root.evalNode(&quot;objectFactory&quot;)); objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;)); settingsElement(root.evalNode(&quot;settings&quot;)); environmentsElement(root.evalNode(&quot;environments&quot;)); // read it after objectFactory and objectWrapperFactory issue #631 databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;)); typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;)); mapperElement(root.evalNode(&quot;mappers&quot;)); &#125; catch (Exception e) &#123; throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e); &#125; &#125; ............................&#125; 我们可以看到它是通过一个一个节点的解析XML的内容得到对应的信息，最后构建出一个Configuration对象。有了Configuration对象，就可以通过SqlSessionFactoryBuilder的build方法构建SqlSessionFactory对象 12345678910111213141516171819202122public class SqlSessionFactoryBuilder &#123; ................... public SqlSessionFactory build(Reader reader, String environment, Properties properties) &#123; try &#123; XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties); return build(parser.parse()); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e); &#125; finally &#123; ErrorContext.instance().reset(); try &#123; reader.close(); &#125; catch (IOException e) &#123; // Intentionally ignore. Prefer previous error. &#125; &#125; &#125; public SqlSessionFactory build(Configuration config) &#123; return new DefaultSqlSessionFactory(config); &#125; .......................&#125; SqlSession执行过程有了SqlSessionFactory对象就可以轻易的获取SqlSession，SqlSession也是个接口，给出了查询、插入、更新、删除的方法。 1234567public class DefaultSqlSessionFactory implements SqlSessionFactory &#123; .................. public SqlSession openSession() &#123; return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false); &#125; ..................&#125; Mapper的动态代理SqlSession中提供了一个getMapper方法，例如： 1UserMapper userMapper = sqlSession.getMapper(UserMapper.class); 源码： 1234567public class DefaultSqlSession implements SqlSession &#123; ............................ public &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123; return configuration.&lt;T&gt;getMapper(type, this); &#125; ............................&#125; 1234567public class Configuration &#123; ................ public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123; return mapperRegistry.getMapper(type, sqlSession); &#125; .................&#125; 123456789101112131415161718192021public class MapperRegistry &#123; private Configuration config; private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt;(); public MapperRegistry(Configuration config) &#123; this.config = config; &#125; @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123; final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type); if (mapperProxyFactory == null) throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;); try &#123; return mapperProxyFactory.newInstance(sqlSession); &#125; catch (Exception e) &#123; throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e); &#125; &#125; ...........................................&#125; 可以很明显的看出，它运用到了Configuration对象的getMapper方法获取对应的接口对象，又运用了映射器的注册器Mapperregistry获取对应的接口对象。首先会判断是否注册一个Mapper，如果没有则抛出异常信息，如果有就会启用MapperProxyFactory工厂生成一个代理实例。 SqlSession的四大对象 Executor代表执行器，由它调度StatementHandler、ParameterHandler、ResultSetHandler等来执行对应的SQL，其中StatementHandler是最重要的。 StatementHandler的作用是使用数据库的Statement（PreparedStatement）执行操作，它是四大对象的核心，起到承上启下的作用，许多插件都是通过拦截它来实现的。 ParameterHandler是用来处理SQL参数的。 ResultSetHandler是进行数据集（ResultSet）的封装返回处理的，不经常使用。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis级联","slug":"MyBatis级联","date":"2019-06-23T15:50:40.000Z","updated":"2019-08-28T01:32:22.332Z","comments":true,"path":"2019/06/23/MyBatis级联/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis级联/","excerpt":"","text":"简述级联是一个数据库实体的概念，级联不是必须的，级联的好处是获取关联数据十分方便，但是级联过多会增加系统的复杂度，同时降低系统的性能，所以当级联的层级超过3层时，就不要考虑使用级联，这样会导致多个对象的关联，导致系统耦合度增加，难以维护。 MyBatis的级联分为3种： 鉴别器（discriminator）：它是一个根据某些条件决定采用具体实现类级联的方案。 一对一（association）：比如身份证和人就是一种一对一的级联关系。 一对多（collection）：比如班主任和学生就是一种一对多的级联关系。 注意！MyBatis中没有多对多级联关系，因为多对多级联比较复杂，使用困难，而且可以通过两个一对多级联进行替换，所以MyBatis不支持多对多级联。 下面主要讲解常用的一对一级联与一对多级联。 一对一级联JavaBean 1234567891011121314151617181920212223242526272829303132333435363738package com.ronin.blog.entity;import lombok.Data;import java.util.Date;import java.util.List;@Datapublic class Article &#123; private Integer articleId; private Integer articleUserId; private String articleTitle; private String articleSummary; private Integer articleViewCount; private Integer articleCommentCount; private Integer articleLikeCount; private Integer articleIsComment; private Integer articleStatus; private Date articleUpdateTime; private Date articleCreateTime; private String articleHtml; private String articleContent; //一对一关系 private User user;&#125; 配置文件 1234567891011121314151617181920&lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.ronin.blog.entity.Article&quot; &gt; &lt;id column=&quot;article_id&quot; property=&quot;articleId&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_user_id&quot; property=&quot;articleUserId&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_title&quot; property=&quot;articleTitle&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;article_summary&quot; property=&quot;articleSummary&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;article_view_count&quot; property=&quot;articleViewCount&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_comment_count&quot; property=&quot;articleCommentCount&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_like_count&quot; property=&quot;articleLikeCount&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_is_comment&quot; property=&quot;articleIsComment&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_status&quot; property=&quot;articleStatus&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_update_time&quot; property=&quot;articleUpdateTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt; &lt;result column=&quot;article_create_time&quot; property=&quot;articleCreateTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt; &lt;result column=&quot;article_html&quot; property=&quot;articleHtml&quot; jdbcType=&quot;LONGVARCHAR&quot; /&gt; &lt;result column=&quot;article_content&quot; property=&quot;articleContent&quot; jdbcType=&quot;LONGVARCHAR&quot; /&gt; &lt;!-- 一对一级联 --&gt; &lt;association property=&quot;user&quot; javaType=&quot;User&quot;&gt; &lt;id column=&quot;user_id&quot; property=&quot;userId&quot;/&gt; &lt;result column=&quot;user_name&quot; property=&quot;userName&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; 一对多级联JavaBean 1234567891011121314151617181920212223242526272829303132333435363738package com.ronin.blog.entity;import lombok.Data;import java.util.Date;import java.util.List;@Datapublic class Article &#123; private Integer articleId; private Integer articleUserId; private String articleTitle; private String articleSummary; private Integer articleViewCount; private Integer articleCommentCount; private Integer articleLikeCount; private Integer articleIsComment; private Integer articleStatus; private Date articleUpdateTime; private Date articleCreateTime; private String articleHtml; private String articleContent; //一对多关系 private List&lt;Tag&gt; tagList;&#125; 配置文件 1234567891011121314151617181920212223&lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.ronin.blog.entity.Article&quot; &gt; &lt;id column=&quot;article_id&quot; property=&quot;articleId&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_user_id&quot; property=&quot;articleUserId&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_title&quot; property=&quot;articleTitle&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;article_summary&quot; property=&quot;articleSummary&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;article_view_count&quot; property=&quot;articleViewCount&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_comment_count&quot; property=&quot;articleCommentCount&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_like_count&quot; property=&quot;articleLikeCount&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_is_comment&quot; property=&quot;articleIsComment&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_status&quot; property=&quot;articleStatus&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_update_time&quot; property=&quot;articleUpdateTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt; &lt;result column=&quot;article_create_time&quot; property=&quot;articleCreateTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt; &lt;result column=&quot;article_html&quot; property=&quot;articleHtml&quot; jdbcType=&quot;LONGVARCHAR&quot; /&gt; &lt;result column=&quot;article_content&quot; property=&quot;articleContent&quot; jdbcType=&quot;LONGVARCHAR&quot; /&gt; &lt;!-- 一对多级联 --&gt; &lt;collection property=&quot;tagList&quot; javaType=&quot;list&quot; ofType=&quot;Tag&quot;&gt; &lt;!-- 映射主键 --&gt; &lt;id column=&quot;tag_id&quot; property=&quot;tagId&quot;/&gt; &lt;!-- 映射普通属性 --&gt; &lt;result column=&quot;tag_name&quot; property=&quot;tagName&quot;/&gt; &lt;result column=&quot;tag_description&quot; property=&quot;tagDescription&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt;","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis核心组件的生命周期","slug":"MyBatis核心组件的生命周期","date":"2019-06-23T15:50:40.000Z","updated":"2019-08-28T01:31:27.980Z","comments":true,"path":"2019/06/23/MyBatis核心组件的生命周期/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis核心组件的生命周期/","excerpt":"","text":"简述MyBatis的四大核心组件已经基本掌握，本篇文章就来谈谈四大核心组件的生命周期。首先，什么是生命周期？所谓的生命周期就是每一个对象存活的时间，例如一个对象一次用完后就要关闭，被Java虚拟机（JVM）销毁，以免继续占用资源，所以我们可以根据每个组件的作用来确定其生命周期。 SqlSessionFactoryBuilderSqlSessionFactoryBuilder的作用在于创建SqlSessionFactory，创建成功之后，SqlSessionFactoryBuilder就失去作用，所以它只能存在于创建SqlSessionFactory的方法中。 SqlSessionFactorySqlSessionFactory可以将其当作JDBC中的数据库连接池，它的作用是创建SqlSession接口对象，所以SqlSessionFactory的生命周期存在于整个MyBatis应用当中，可以认为SqlSessionFactory的生命周期等同于MyBatis的生命周期。 SqlSessionSqlSession也可以将其当作JDBC中的数据库连接对象（Connection），在一个事务中，通过SqlSession的commit和rollback方法提交或者回滚事务，所以SqlSession存活在一个业务请求中，处理完整个业务请求之后就应该关闭SqlSession，释放资源，所以SqlSession经常被作为单例使用。 MapperMapper是一个接口，它是通过SqlSession创建出来的，所以它的生命周期最多也是和SqlSession相同，当SqlSession被关闭释放后，Mapper也会消失，所以它的生命周期是小于等于SqlSession的生命周期的。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis配置","slug":"MyBatis配置","date":"2019-06-23T15:50:40.000Z","updated":"2019-08-28T01:32:34.112Z","comments":true,"path":"2019/06/23/MyBatis配置/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis配置/","excerpt":"","text":"简述123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;!-- 配置 --&gt; &lt;!-- 属性 --&gt; &lt;properties&gt;&lt;/properties&gt; &lt;!-- 设置 --&gt; &lt;settings&gt;&lt;/settings&gt; &lt;!-- 设置别名 --&gt; &lt;typeAliases&gt;&lt;/typeAliases&gt; &lt;!-- 类型处理器 --&gt; &lt;typeHandlers&gt;&lt;/typeHandlers&gt; &lt;!-- 对象工厂 --&gt; &lt;objectFactory&gt;&lt;/objectFactory&gt; &lt;!-- 插件 --&gt; &lt;plugins&gt;&lt;/plugins&gt; &lt;!-- 环境配置 --&gt; &lt;environments&gt; &lt;environment&gt; &lt;!-- 事务管理器 --&gt; &lt;transactionManager&gt;&lt;/transactionManager&gt; &lt;!-- 数据源 --&gt; &lt;dataSource&gt;&lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 数据库厂商 --&gt; &lt;databaseIdProvider&gt;&lt;/databaseIdProvider&gt; &lt;!-- 映射器 --&gt; &lt;mappers&gt;&lt;/mappers&gt;&lt;/configuration&gt; 上述的代码是整个MyBatis配置文件中包含的所有重要的节点元素，要注意的是，这些节点元素的顺序不能够颠倒！ properties属性properties属性可以给系统配置运行参数，可以放在XML文件或者properties文件中，这样的好处可以方便我们进行参数的修改，不会引起代码的重新编译。MyBatis提供了三种方式使用properties： property子元素 properties文件 程序代码传递 MyBatis通过properties的属性resource来引入properties文件： 1&lt;properties resource=&quot;jdbc.properties&quot;/&gt; 在这三种方式中，最优先的是使用程序传递的方式，其次是使用properties文件的方式，最后是使用property子元素的方式，MyBatis会根据优先级来覆盖原先配置的属性值。 settings属性settings的配置项很多，但是常用的就只有几个，比如缓存的cacheEnabled，关于级联的lazyLoadingEnabled和aggressiveLazyLoading，关于自动映射的autoMappingBehavior和mapUnderscoreToCamelCase，关于执行器类型的defaultExecutorType等。 typeAliases属性该属性是用于定义类的别名，MyBatis中允许通过typeAliases属性定义一个简写来代表这个类，别名分为系统定义别名和自定义别名，在MyBatis中别名由类TypeAliasRegistry定义的，在MyBatis中别名不区分大小写。 typeHandler属性该属性为类型转换器，在JDBC中，需要在PreparedStatement对象中设置那些已经预编译过的SQL语句的参数。执行SQL后，会通过ResultSet对象获取得到数据库的数据，而这些MyBatis是根据数据的类型通过typeHandler来实现的。 typeHandler中分为javaType和jdbcType两种，其中javaType用于定义java类型，jdbcType用于定义数据库类型，typeHandler的作用就是承担javaType和jdbcType之间的转换。跟别名一样，MyBatis中也存在着系统定义的typeHandler和自定义的typeHandler，MyBatis会根据javaType和jdbcType决定采用哪个typeHandler处理转换规则。 objectFactory属性当创建结果集的时候，MyBatis会使用一个对象工厂来完成创建这个结果集的实例，默认情况下会使用其定义的对象工厂–DefaultObjectFactory来完成工作。当然，MyBatis也支持自定义的ObjectFactory，只需要实现接口org.apache.ibatis.reflection.factory.ObjectFactory,并给予配置。 environment属性该属性主要用于配置数据库环境信息，下级节点包含了：事务管理器（transactionManager）和数据源（dataSource）。 transactionManager它的主要工作就是提交（commit）、回滚（rollback）和关闭（close）数据库的事务。MyBatis为Transaction提供了两个实现类：JdbcTransaction和ManagedTransaction。 对于两种事务管理器，配置分别为： 12&lt;transactionManager type=&quot;JDBC&quot;/&gt;&lt;transactionManager type=&quot;MANAGED&quot;/&gt; JDBC使用JdbcTransactionFactory生成的JdbcTransaction对象实现，它是以JDBC的方式对数据库的提交和回滚进行操作。MANAGED使用ManagedTransactionFactory生成的ManagedTransaction对象实现，它的提交和回滚方法不用任何操作，而是把事务交给容器处理。默认情况下它会关闭连接，需要将closeConnection属性设置为false。 dataSource数据源存在三种类型： 123&lt;dataSource type=&quot;UNPOOLED&quot;/&gt;&lt;dataSource type=&quot;POOLED&quot;/&gt;&lt;dataSource type=&quot;JNDI&quot;/&gt; UNPOOLED采用非数据库池的管理方式，每次请求都会打开一个新的数据库连接，创建速度较慢，可以配置以下属性： driver url username password defaultTransactionIsolationLevel 默认的连接事务隔离级别 POOLED利用“池”的概念将JDBC的Connection对象组织起来，刚开始会有空置，但是再次请求时无须再建立和验证，省去创建新连接的时间，相比UNPOOLED的方式，它有更多于UNPOOLED属性： poolMaximumActiveConnections 任意时间存在的连接数，默认为10 poolMaximumIdleConnections 任意时间存在的空闲连接数 poolMaximumCheckoutTime 被强制返回之前，池中连接被检出的时间，默认20000毫秒 poolTimeToWait poolPingQuery poolPingEnabled 是否启用侦测查询 poolPingConnectionsNotUsedFor 配置poolPingQuery的使用频度 JNDI实现是为了能在如EJB或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个JNDI上下文引用，它需要两种属性： initial_context 用来在InitialContext中寻找上下文 data_source 引用数据源实例位置上下文的路径 mappers属性映射器定义命名空间的方法，命名空间对应的是一个接口的全路径，而不是实现类，映射器引入的方法有很多，分别为： 用文件路径引入映射器 123&lt;mappers&gt; &lt;mapper resource=&quot;com/etc/ssm/mapper/UserMapper.xml&quot;/&gt;&lt;/mappers&gt; 用包名引入映射器 123&lt;mappers&gt; &lt;mapper name=&quot;com.etc.ssm.mapper&quot;/&gt;&lt;/mappers&gt; 用类注册引入映射器 123&lt;mappers&gt; &lt;mapper class=&quot;com.etc.ssm.mapper.UserMapper&quot;/&gt;&lt;/mappers&gt;","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis映射器","slug":"MyBatis映射器","date":"2019-06-23T15:50:40.000Z","updated":"2019-08-28T01:32:53.987Z","comments":true,"path":"2019/06/23/MyBatis映射器/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis映射器/","excerpt":"","text":"简述映射器是MyBatis最复杂且最重要的组件，它由一个接口加上XML文件（或者注解）组成。在映射器中可以配置参数、各类SQL语句、存储过程、缓存、级联等复杂内容，并且通过建议的映射规则映射到指定的POJO或者其他对象上，映射器能有效消除JDBC底层的代码。| 元素名称 | 描述 | 备注 || —————- | ———————————————————- | ————————————————— || select | 查询语句，最常用、最复杂的元素之一 | 可以自定义参数，返回结果集等 || insert | 插入语句 | 执行后返回一个整数，代表插入的条数 || update | 更新语句 | 执行后返回一个整数，代表更新的条数 || delete | 删除语句 | 执行后返回一个整数，代表删除的条数 || parameterMap | 定义参数映射关系 | 即将被删除的元素，不建议大家使用 || sql | 定义一部分SQL，在各个地方引用它 | 例如，一张表列名，一次定义，可以在多个SQL语句中使用 || resultMap | 用来描述从数据库结果集中加载对象，它是最复杂、最强大的元素 | 提供映射规则 || cache | 给定命名空间的缓存配置 | || cache-ref | 其他命名空间缓存配置的引用 | | select元素先来看看select元素的几个重要配置：| 元素 | 说明 | 备注 || —————- | ———————————————————— | ———————————————————- || id | 它和Mapper的命名空间组合起来是唯一的，供MyBatis调用 | 如果命名空间和id结合起来不唯一，MyBatis会抛出异常 || parameterType | 类的全命名，也可以是别名，但是别名必须是MyBatis内部定义的 | 可以选择JavaBean、Map等简单参数类型传递给SQL || parameterMap | 即将废弃的元素 | || resultType | 定义类的全路径，结果集将通过JavaBean的规范映射或者定义成int、double等参数，也可以使用别名 | 常用的参数之一 || resultMap | 它是映射集的引用，执行强大的映射功能，resultMap能提供自定义的映射规则 | MyBatis最复杂的元素，可以配置映射规则、级联、typeHandler等 || useCache | 启动二级缓存的开关，是否要求MyBatis将此次结果缓存 | 取值为布尔值，默认值为true | 简单的select例子： 123&lt;select id=&quot;findArticleById&quot; parameterType=&quot;integer&quot; resultMap=&quot;BaseResultMap&quot;&gt; SELECT * FROM article WHERE id = #&#123;id&#125;&lt;/select&gt; id配合Mapper的全限定名，成为一个唯一的标识，标识这条SQL parameterType为入参的类型 resultMap为SQL语句返回的结果集的映射 自动映射和驼峰映射MyBatis提供了自动映射功能，默认情况下自动映射是开启的，使用自动映射功能可以大量减少映射配置，在setting元素中有两个配置的选项 autoMappingBehavior 和 mapUnderscoreToCamelCase，它们是控制自动映射和驼峰映射的开关。 配置自动映射的 autoMappingBehavior 选项取值范围是： NONE 不进行自动映射 PARTIAL 默认值，只对没有嵌套结果集进行自动映射 FULL 对所有结果集进行自动映射，包括嵌套结果集 传参问题在上面的例子中，只有一个参数传递，现实需求可能需要多个参数，MyBatis提供了多种方法来解决多参传入的问题。 使用map接口传递参数 接口定义 1public List&lt;User&gt; findUserByMap(Map&lt;String,Object&gt;parameterMap); 映射器 123&lt;select id=&quot;findUserByMap&quot; parameterType=&quot;map&quot; resultType=&quot;user&quot;&gt; SELECT * FROM user WHERE id = #&#123;id&#125; and name = #&#123;name&#125;&lt;/select&gt; 注意，参数id和name，要求的是map的键！ 使用注解传递多个参数 @Param 使用map传递参数有个弊端–代码可读性差，MyBatis提供了一个注解@Param，可以通过它去定义映射器的参数名称。 接口定义 1public List&lt;User&gt; findUserByMap(@Param(&quot;id&quot;)Integer id,@Param(&quot;name&quot;)String name); 映射器 123&lt;select id=&quot;findUserByMap&quot; resultType=&quot;user&quot;&gt; SELECT * FROM user WHERE id = #&#123;id&#125; and name = #&#123;name&#125;&lt;/select&gt; 注意，这里使用了@Param注解就不需要给出parameterType属性，MyBatis可以自动探索。 通过JavaBean传递多个参数 定义POJO 12345public class UserSelect&#123; private Integer id; private String name; ................&#125; 接口定义 1public List&lt;User&gt; findUserByMap(UserSelect userSelect); 映射器 123&lt;select id=&quot;findUserByMap&quot; parameterType=&quot;com.ssm.vo.UserSelect&quot; resultType=&quot;user&quot;&gt; SELECT * FROM user WHERE id = #&#123;userSelect.id&#125; and name = #&#123;userSelect.name&#125;&lt;/select&gt; insert、update、delete元素由于insert、update、delete这三个元素使用方法类似，这里就将三种元素放在一起。 MyBatis在执行完insert、update、delete语句之后，会返回一个整数来表示其影响的数据库记录数。 insert 123456789101112&lt;insert id=&quot;insert&quot; parameterType=&quot;com.ronin.blog.entity.Article&quot; &gt; insert into article (article_user_id, article_title, article_summary, article_view_count, article_comment_count, article_like_count, article_is_comment, article_status, article_update_time, article_create_time, article_html, article_content) values ( #&#123;articleUserId,jdbcType=INTEGER&#125;, #&#123;articleTitle,jdbcType=VARCHAR&#125;, #&#123;articleViewCount,jdbcType=INTEGER&#125;, #&#123;articleCommentCount,jdbcType=INTEGER&#125;, #&#123;articleLikeCount,jdbcType=INTEGER&#125;, #&#123;articleIsComment,jdbcType=INTEGER&#125;, #&#123;articleStatus,jdbcType=INTEGER&#125;, #&#123;articleUpdateTime,jdbcType=TIMESTAMP&#125;, #&#123;articleCreateTime,jdbcType=TIMESTAMP&#125;, #&#123;articleHtml,jdbcType=LONGVARCHAR&#125;, #&#123;articleContent,jdbcType=LONGVARCHAR&#125;)&lt;/insert&gt; 主键回填可以看出上面这条语句没有插入id列，因为MySql中表格采用了主键自增，MySql数据库会自动生成主键，我们也可以在MyBatis插入数据时获取到数据库生成的主键值。在insert语句中有个开关属性 useGeneratedKeys，用来控制是否打开这个功能，默认值是false。打开时要配置其属性 keyProperty 或 keyColumn，告诉系统把生成的主键放入哪个属性,如果存在多个主键，用逗号（，）隔开。 update 12345678910111213141516&lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;com.ronin.blog.entity.Article&quot; &gt; update article set article_user_id = #&#123;articleUserId,jdbcType=INTEGER&#125;, article_title = #&#123;articleTitle,jdbcType=VARCHAR&#125;, article_summary = #&#123;articleSummary,jdbcType=VARCHAR&#125;, article_view_count = #&#123;articleViewCount,jdbcType=INTEGER&#125;, article_comment_count = #&#123;articleCommentCount,jdbcType=INTEGER&#125;, article_like_count = #&#123;articleLikeCount,jdbcType=INTEGER&#125;, article_is_comment = #&#123;articleIsComment,jdbcType=INTEGER&#125;, article_status = #&#123;articleStatus,jdbcType=INTEGER&#125;, article_update_time = #&#123;articleUpdateTime,jdbcType=TIMESTAMP&#125;, article_create_time = #&#123;articleCreateTime,jdbcType=TIMESTAMP&#125;, article_html = #&#123;articleHtml,jdbcType=LONGVARCHAR&#125;, article_content = #&#123;articleContent,jdbcType=LONGVARCHAR&#125; where article_id = #&#123;articleId,jdbcType=INTEGER&#125; &lt;/update&gt; delete 1234&lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot; &gt; delete from article where article_id = #&#123;articleId,jdbcType=INTEGER&#125;&lt;/delete&gt; sql元素sql元素的作用在于可以定义一条SQL的一部分，方便后面的SQL引用它，把重复的SQL语句抽取出来，降低耦合性。 定义 123&lt;sql id=&quot;articleAndTagLine&quot;&gt; a.* , t.tag_id , t.tag_description , t.tag_name , u.user_id , u.user_name&lt;/sql&gt; 引用 123&lt;select id=&quot;selectTopArticle&quot; resultMap=&quot;BaseResultMap&quot;&gt; select &lt;include refid=&quot;articleLine&quot;/&gt; from article&lt;/select&gt; resultMap元素resultMap的作用是定义映射规则、级联的更新、定制类型转化器等。resultMap定义的主要是一个结果集的映射关系，就是SQL到JavaBean的映射关系定义，它也支持级联等特性。 12345678910&lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.ronin.blog.entity.Article&quot; &gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;title&quot; property=&quot;title&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;keywords&quot; property=&quot;keywords&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;desci&quot; property=&quot;desci&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;pic&quot; property=&quot;pic&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;click&quot; property=&quot;click&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;time&quot; property=&quot;time&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt; &lt;result column=&quot;catalog_id&quot; property=&quot;catalogId&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;/resultMap&gt;","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis一级缓存和二级缓存","slug":"MyBatis一级缓存和二级缓存","date":"2019-06-23T15:50:40.000Z","updated":"2019-08-28T01:32:42.679Z","comments":true,"path":"2019/06/23/MyBatis一级缓存和二级缓存/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis一级缓存和二级缓存/","excerpt":"","text":"简述mybatis提供了缓存机制减轻数据库压力，提高数据库性能。 mybatis的缓存分为两级：一级缓存、二级缓存。 一级缓存一级缓存是在SqlSession上的缓存，默认情况下，MyBatis系统会开启一级缓存，也就是对于SqlSession层面的缓存，这个缓存不需要POJO对象可序列化。测试一级缓存： 123456789101112131415161718@Testpublic void testFindUser() throws IOException &#123; //读取核心配置文件 String file = &quot;sqlMapConfig.xml&quot;; InputStream in = Resources.getResourceAsStream(file); //日志 Logger logger = Logger.getLogger(MybatisFirstTest.class); //创建sqlsessionfactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); //创建sqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User u = userMapper.getUser(1L); logger.info(&quot;再获取一次POJO....&quot;); User u1 = userMapper.getUser(1L); sqlSession.close(); &#125; 这段代码对同一对象进行两次获取，但是在日志中显示只有一条SQL语句被执行，原因是使用了同一个SqlSession对象获取数据，当一个SqlSession第一次通过SQL和参数获取对象后会将其缓存起来，如果下一次SQL和参数没有发生变化，并且缓存没有超时或者需要刷新时，它就会从缓存中直接取数据。 二级缓存二级缓存是在SqlSessionFactory上的缓存，默认情况下，MyBatis系统不会开启二级缓存，需要手动开启，开启二级缓存只需要在映射文件上添加代码： 1&lt;cache/&gt; 这个时候MyBatis会序列化和反序列化对应的POJO对象，也就要求POJO需要实现序列化接口。如果实体类没有实现序列化接口，MyBatis会抛出异常。 1234public class User implements Serializable&#123; public static final long serialVersionUID = 598736524547906734L; .........................&#125; 这个时候从日志上就可以看到不同的SqlSession在获取同一条记录时，都是只发送过一次SQL获取数据，MyBatis将其保存在SqlSessionFactory层面，提供给各个SqlSession使用。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis核心组件之SQL Mapper","slug":"MyBatis核心组件之SQL Mapper","date":"2019-06-23T15:46:23.000Z","updated":"2019-08-28T01:31:37.269Z","comments":true,"path":"2019/06/23/MyBatis核心组件之SQL Mapper/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis核心组件之SQL Mapper/","excerpt":"","text":"简述映射器（SQL Mapper）是MyBatis中最重要、最复杂的组件，它是由一个接口和对应的XML文件组成，它可以配置以下内容： 描述映射规则 提供SQL语句，并可以配置SQL参数类型、返回类型、缓存刷新等信息 配置缓存 提供动态SQL 映射器的主要作用就是将SQL查询到的结果映射成一个POJO（Java原生对象），或者将POJO的数据插入到数据库中，并定义一些关于缓存等的重要内容。 下面提供两种方式实现映射器，首先我们先定义一个POJO对象： 1234567public class User&#123; private Long id; private String username; private String password; /** getter 和 setter 方法**/&#125; XML实现映射器用XML定义映射器分为两个部分：接口和XML。首先，定义一个映射器接口,提供一个通过id获取用户的方法。 123public interface UserMapper&#123; public User getUser(Long id);&#125; 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.etc.ssm.mapper.UserMapper&quot;&gt; &lt;!-- 获取用户 --&gt; &lt;select id=&quot;getUser&quot; parameterType=&quot;long&quot; resultType=&quot;user&quot;&gt; select * from tb_user where id= #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 注意：select元素节点的id属性值要与其对应的方法名相同！mapper元素节点：属性namespace所对应的是一个接口的全限定名，MyBatis上下文就可以通过它找到对应的接口。select元素节点：表明这是一条查询语句，属性id标识了这条SQL，属性parameterType=”long“说明传递给SQL的是一个long型的参数，resultType=”user”表示返回的是一个user类型的返回值，user是之前配置文件中设置过的别名。 注解实现映射器注解实现映射器相对于XML实现映射器较为简单，它只需要一个接口就可以，通过MyBatis的注解来注入SQL语句。 1234public interface UserMapper&#123; @Select(&quot;select * from tb_user where id= #&#123;id&#125;&quot;); public User getUser(Long id);&#125; 需要注意的是，当XML方式与注解方式同时定义时，XML方式会覆盖掉注解方式，所以MyBatis官方推荐使用的是XML实现映射器的方式，但是不同场景有不同的选择，在SQL语句量较少的情况下，使用注解方式会效率更高，但是与代码的耦合度较高。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis核心组件之SqlSession","slug":"MyBatis核心组件之SqlSession","date":"2019-06-23T15:46:23.000Z","updated":"2019-08-28T01:31:47.621Z","comments":true,"path":"2019/06/23/MyBatis核心组件之SqlSession/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis核心组件之SqlSession/","excerpt":"","text":"SqlSession在MyBatis中，SqlSession是其和新街口。在MyBatis中有两个实现类，DefaultSqlSession和SqlSessionManager。DefaultSqlSession是单线程使用的，而SqlSessionManager是在多线程环境下使用的。 SqlSession的作用类似于一个JDBC中的Connection对象，代表着一个连接资源的启用。具体而言，它的作用有3个： 获取Mapper接口 发送SQL给数据库 控制数据库事务 从上一篇文章中我们已经知道了怎么创建SqlSessionFactory，通过SqlSessionFactory的方法，我们可以直接创建处SqlSession对象，代码如下： 1SqlSession sqlSession = SqlSeesionFactory.openSession(); 创建出SqlSession对象，我们可以通过SqlSession对象来控制数据库的事务： 1234567891011121314151617//定义SqlSessionSqlSession sqlSession = null;try&#123; //打开SqlSession会话 sqlSession = SqlSessionFactory.openSession(); //业务逻辑代码..... // 提交事务 sqlSession.commit();&#125;catch(Exception ex)&#123; //事务回滚 sqlSession.rollback();&#125;finally&#123; //在finally语句中确保资源顺利关闭 if(sqlSession != null)&#123; sqlSession.close(); &#125;&#125; 上述代码中，使用commit方法提交事务，出错后通过rollback回滚事务，保证了代码运行时的数据的一致性。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis核心组件之SqlSessionFactory","slug":"MyBatis核心组件之SqlSessionFactory","date":"2019-06-23T15:28:20.000Z","updated":"2019-08-28T01:32:09.937Z","comments":true,"path":"2019/06/23/MyBatis核心组件之SqlSessionFactory/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis核心组件之SqlSessionFactory/","excerpt":"","text":"MyBatis的核心组件MyBatis的核心组件分为4个部分： SqlSessionFactoryBuilder（构造器）：它会根据配置或者代码来生成SqlSessionFactory，采用的是分布构建的Builder模式。 SqlSessionFactory（工厂接口）：依靠它来生成SqlSession，使用的是工厂模式。 SqlSession（会话）：一个既可以发送SQL执行返回结果，也可以获取Mapper的接口。在现有的技术中，一般我们会让其在业务逻辑代码中“消失”，而使用的是MyBatis提供的SQL Mapper接口编程技术，它能提高代码的可读性和可维护性。 SQL Mapper（映射器）：MyBatis新设计存在的组件，它由一个Java接口和XML文件（或注解）构成，需要给出对应的SQL和映射规则。它负责发送SQL去执行，并返回结果。 SqlSessionFactory使用MyBatis首先是使用配置或者代码去生产SqlSessionFactory，而MyBatis提供了构造器SqlSessionFactoryBuilder。它提供了一个类org.apache.ibatis.session.Configuration作为引导，采用的是Builder模式。 在MyBatis中，既可以通过读取配置的XML文件的形式生成SqlSessionFactory，也可以通过Java代码的形式去生成SqlSessionFactory。每个基于MyBatis的应用都是以一个SqlSessionFactory的实例为中心的，而SqlSessionFactory唯一的作用就是生产MyBatis的核心接口对象SqlSession，所以它的责任是唯一的，我们往往可以通过单例模式处理它。下面为两种方式创建SqlSessionFactory的代码。 使用XML构建SqlSessionFactory12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 设置别名 --&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.etc.ssm.entity&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- 加载数据库属性文件 --&gt; &lt;properties resource=&quot;db.properties&quot;&gt;&lt;/properties&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!--使用JDBC实务管理--&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!--连接池 POOLED为连接池方式 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 引入映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com.etc.ssm.mapper.UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; typeAliase节点：定义一个别名，代表com.etc.ssm.entity包下所有的类在MyBatis上下文中可以使用别名去代替全限定名。properties节点：可以引入指定目录下的配置文件。environments节点：描述的是数据库，其中transactionManager节点是配置事务管理器，采用MyBatis中JDBC的管理器方式，采用dataSource节点配置数据库，POOLED表示采用MyBatis内部提供的连接池方式。mappers节点：引入映射器。 1234567891011@Testpublic void testXmlSqlSessionFactory() &#123; SqlSessionFactory sqlSessionFactory = null; String resource = &quot;sqlMapConfig.xml&quot;; InputStream inputStream; try &#123; inputStream = Resource.getResourceAsStream(resource); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 使用代码创建SqlSessionFactory这种方法创建SqlSessionFactory不推荐使用。 123456789101112131415161718192021//数据库连接池信息PooledDataSource dataSource=new PooledDataSource();dataSource.setDriver(&quot;com.mysql.jdbc.Driver&quot;);dataSource.setUsername(&quot;root&quot;);dataSource.setPassword(&quot;123456&quot;);dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/ssm&quot;);dataSource.setDefaultAutoCommit(false);//采用MyBatis的JDBC事务方式TransactionFactory transactionFactory =new JdbcTransactionFactory();Environment environment=new Environment(&quot;development&quot;,transactionFactory,dataSource);/创建 Configuration对象Configuration configuration=new Configuration(environment);//注册一个MyBatis上下文别名configuration.getTypeAliasRegistry().registerAlias(&quot;user&quot;,User.class);//加入一个映射器configuration.addMapper(UserMapper.class);//使用 SqlSessionFactoryBuilder 构建SqlSessionFactorySqlSessionFactory SqlSessionFactory=new SqlSessionFactoryBuilder().,build(configuration);return SqlSessionFactory;","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis","slug":"MyBatis","date":"2019-06-22T14:40:20.000Z","updated":"2019-08-28T01:31:08.219Z","comments":true,"path":"2019/06/22/MyBatis/","link":"","permalink":"http://yoursite.com/2019/06/22/MyBatis/","excerpt":"","text":"MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。 iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAOs） 当前，最新版本是MyBatis 3.5.1 ，其发布时间是2019年4月8日。 持久层的概念和MyBatis的特点上面介绍到MyBatis是一个持久层的框架，它是对JDBC进行了简单的封装，那么我们来讲讲什么是持久层。 持久层是三层架构（控制层、业务逻辑层、持久层）中的一层，持久层可以将业务数据存储到磁盘，具备长期存储的能力，只要磁盘不损坏，在断电或者其他情况下，重新开启系统仍然可以读取到这些数据。一般执行持久任务的都是数据库系统，持久层可以使用巨大的磁盘空间，也比较廉价，它的缺点就是比较慢。当然，慢是针对内存来说的，在一般的系统中运行是不存在问题的。但是在互联网的秒杀场景下，慢是不能接受的，极有可能导致宕机，在这样的场景下考虑使用Redis处理。 MyBatis的三大特点： 不屏蔽SQL，意味着可以更为精确的定位SQL语句，可以对其进行优化和改造，这有利于互联网系统性能的提高，符合互联网需要性能优化的特点。 提供强大、灵活的映射机制，方便Java开发者使用，提供动态SQL的功能，允许我们根据不同条件组装SQL，这个功能远比其他工具或者Java编码的可读性和可维护性高的多，满足各种应用系统的同时也满足了需求经常变化的互联网应用的要求。 在MaBatis中，提供了使用Mapper的接口编程，只要一个接口和一个XML就能创建映射器，进一步简化我们的工作，使得很多框架API在MyBatis中消失，开发者能更集中于业务逻辑。 ORM这里我们介绍一下什么叫做ORM。 ORM也称对象关系映射，是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。从效果上说，它其实是创建了一个可在编程语言里使用的–“虚拟对象数据库”。 面向对象是从软件工程基本原则（如耦合、聚合、封装）的基础上发展起来的，而关系数据库则是从数学理论发展而来的，两套理论存在显著的区别。为了解决这个不匹配的现象，对象关系映射技术应运而生。 对象关系映射（ORM）提供了概念性的、易于理解的模型化数据的方法。ORM方法论基于三个核心原则： 简单：以最基本的形式建模数据。 传达性：数据库结构被任何人都能理解的语言文档化。 精确性：基于数据模型创建正确标准化的结构。 典型地，建模者通过收集来自那些熟悉应用程序但不熟练的数据建模者的人的信息开发信息模型。建模者必须能够用非技术企业专家可以理解的术语在概念层次上与数据结构进行通讯。建模者也必须能以简单的单元分析信息，对样本数据进行处理。ORM专门被设计为改进这种联系。 简单的说：ORM相当于中继数据。具体到产品上，例如ADO.NET Entity Framework。DLINQ中实体类的属性[Table]就算是一种中继数据。 MyBatis与Hibernate说到ORM框架，第一个想到的持久层框架应该就是Hibernate，Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的ORM框架，hibernate可以自动生成SQL语句，自动执行。 MyBatis严格来说是一个半ORM框架，相对于Hibernate，它并没有像Hibernate一样完全的ORM，但是正是因为它的半ORM以及简单快速的开发效率，让MyBatis成为现在互联网项目首选的持久层框架之一。 MyBatis与Hibernate两者对比 开发速度 就开发速度而言，Hibernate的真正掌握要比Mybatis来得难些。Mybatis框架相对简单很容易上手，但也相对简陋些。 比起两者的开发速度，不仅仅要考虑到两者的特性及性能，更要根据项目需求去考虑究竟哪一个更适合项目开发，比如：一个项目中用到的复杂查询基本没有，就是简单的增删改查，这样选择hibernate效率就很快了，因为基本的sql语句已经被封装好了，根本不需要你去写sql语句，这就节省了大量的时间，但是对于一个大型项目，复杂语句较多，这样再去选择hibernate就不是一个太好的选择，选择mybatis就会加快许多，而且语句的管理也比较方便。 开发工作量 Hibernate和MyBatis都有相应的代码生成工具。可以生成简单基本的DAO层方法。针对高级查询，Mybatis需要手动编写SQL语句，以及ResultMap。而Hibernate有良好的映射机制，开发者无需关心SQL的生成与结果映射，可以更专注于业务流程。 SQL优化 Hibernate的查询会将表中的所有字段查询出来，这一点会有性能消耗。Hibernate也可以自己写SQL来指定需要查询的字段，但这样就破坏了Hibernate开发的简洁性。而Mybatis的SQL是手动编写的，所以可以按需求指定查询的字段。 Hibernate HQL语句的调优需要将SQL打印出来，而Hibernate的SQL被很多人嫌弃因为太丑了。MyBatis的SQL是自己手动写的所以调整方便。但Hibernate具有自己的日志统计。Mybatis本身不带日志统计，使用Log4j进行日志记录。 对象管理的对比 Hibernate 是完整的对象/关系映射解决方案，它提供了对象状态管理（state management）的功能，使开发者不再需要理会底层数据库系统的细节。也就是说，相对于常见的 JDBC/SQL 持久层方案中需要管理 SQL 语句，Hibernate采用了更自然的面向对象的视角来持久化 Java 应用中的数据。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]}]}