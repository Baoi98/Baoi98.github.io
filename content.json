{"meta":{"title":"Ronin Blog","subtitle":null,"description":null,"author":"RoninTottoo","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-06-22T12:12:22.000Z","updated":"2019-06-22T12:52:09.838Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-06-22T12:11:10.000Z","updated":"2019-06-22T13:45:35.927Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Ronin 一名即将成为程序员的软件工程学生"},{"title":"tags","date":"2019-06-22T12:12:13.000Z","updated":"2019-06-22T12:53:52.327Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Mybatis运行原理","slug":"MyBatis运行原理","date":"2019-06-23T15:52:40.000Z","updated":"2019-06-23T15:58:42.205Z","comments":true,"path":"2019/06/23/MyBatis运行原理/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis运行原理/","excerpt":"","text":"原理MyBatis的运行过程分为两大步： 读取配置文件缓存到Configuration对象中，用于创建SqlSessionFactory SqlSession的执行过程构建SqlSessionFactory过程 通过 org.apache.ibatis.builder.xml.XMLConfigBuilder 解析配置的XML文件，读出所配置的参数，并将读取的内容存入 org.apache.ibatis.session.Configuration 类对象中。而Configuration采用的是单例模式，几乎所有的MyBatis配置内容都会存放在这个单例对象中。 使用Configuration对象创建SqlSessionFactory。MyBatis中的SqlSessionFactory是一个接口，不是一个实现类，所以MyBatis提供了一个默认的实现类 org.apache.ibatis.session.defaults.DefaultSqlSessionFactory。在大部分的情况下没必要自己去创建SqlSessionFactory的实现类，这种创建方式就是一种Builder模式。 XMLConfigBuilder中解析XML方法源码： 12345678910111213141516171819202122232425262728public class XMLConfigBuilder extends BaseBuilder &#123; ...................... public Configuration parse() &#123; if (parsed) &#123; throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;); &#125; parsed = true; parseConfiguration(parser.evalNode(&quot;/configuration&quot;)); return configuration; &#125; private void parseConfiguration(XNode root) &#123; try &#123; propertiesElement(root.evalNode(&quot;properties&quot;)); //issue #117 read properties first typeAliasesElement(root.evalNode(&quot;typeAliases&quot;)); pluginElement(root.evalNode(&quot;plugins&quot;)); objectFactoryElement(root.evalNode(&quot;objectFactory&quot;)); objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;)); settingsElement(root.evalNode(&quot;settings&quot;)); environmentsElement(root.evalNode(&quot;environments&quot;)); // read it after objectFactory and objectWrapperFactory issue #631 databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;)); typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;)); mapperElement(root.evalNode(&quot;mappers&quot;)); &#125; catch (Exception e) &#123; throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e); &#125; &#125; ............................&#125; 我们可以看到它是通过一个一个节点的解析XML的内容得到对应的信息，最后构建出一个Configuration对象。有了Configuration对象，就可以通过SqlSessionFactoryBuilder的build方法构建SqlSessionFactory对象 12345678910111213141516171819202122public class SqlSessionFactoryBuilder &#123; ................... public SqlSessionFactory build(Reader reader, String environment, Properties properties) &#123; try &#123; XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties); return build(parser.parse()); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e); &#125; finally &#123; ErrorContext.instance().reset(); try &#123; reader.close(); &#125; catch (IOException e) &#123; // Intentionally ignore. Prefer previous error. &#125; &#125; &#125; public SqlSessionFactory build(Configuration config) &#123; return new DefaultSqlSessionFactory(config); &#125; .......................&#125; SqlSession执行过程有了SqlSessionFactory对象就可以轻易的获取SqlSession，SqlSession也是个接口，给出了查询、插入、更新、删除的方法。 1234567public class DefaultSqlSessionFactory implements SqlSessionFactory &#123; .................. public SqlSession openSession() &#123; return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false); &#125; ..................&#125; Mapper的动态代理SqlSession中提供了一个getMapper方法，例如： 1UserMapper userMapper = sqlSession.getMapper(UserMapper.class); 源码： 1234567public class DefaultSqlSession implements SqlSession &#123; ............................ public &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123; return configuration.&lt;T&gt;getMapper(type, this); &#125; ............................&#125; 1234567public class Configuration &#123; ................ public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123; return mapperRegistry.getMapper(type, sqlSession); &#125; .................&#125; 123456789101112131415161718192021public class MapperRegistry &#123; private Configuration config; private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt;(); public MapperRegistry(Configuration config) &#123; this.config = config; &#125; @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123; final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type); if (mapperProxyFactory == null) throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;); try &#123; return mapperProxyFactory.newInstance(sqlSession); &#125; catch (Exception e) &#123; throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e); &#125; &#125; ...........................................&#125; 可以很明显的看出，它运用到了Configuration对象的getMapper方法获取对应的接口对象，又运用了映射器的注册器Mapperregistry获取对应的接口对象。首先会判断是否注册一个Mapper，如果没有则抛出异常信息，如果有就会启用MapperProxyFactory工厂生成一个代理实例。 SqlSession的四大对象 Executor代表执行器，由它调度StatementHandler、ParameterHandler、ResultSetHandler等来执行对应的SQL，其中StatementHandler是最重要的。 StatementHandler的作用是使用数据库的Statement（PreparedStatement）执行操作，它是四大对象的核心，起到承上启下的作用，许多插件都是通过拦截它来实现的。 ParameterHandler是用来处理SQL参数的。 ResultSetHandler是进行数据集（ResultSet）的封装返回处理的，不经常使用。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis一级缓存和二级缓存","slug":"MyBatis一级缓存和二级缓存","date":"2019-06-23T15:50:40.000Z","updated":"2019-06-23T15:51:02.806Z","comments":true,"path":"2019/06/23/MyBatis一级缓存和二级缓存/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis一级缓存和二级缓存/","excerpt":"","text":"简述mybatis提供了缓存机制减轻数据库压力，提高数据库性能。 mybatis的缓存分为两级：一级缓存、二级缓存。 一级缓存一级缓存是在SqlSession上的缓存，默认情况下，MyBatis系统会开启一级缓存，也就是对于SqlSession层面的缓存，这个缓存不需要POJO对象可序列化。测试一级缓存： 123456789101112131415161718@Testpublic void testFindUser() throws IOException &#123; //读取核心配置文件 String file = &quot;sqlMapConfig.xml&quot;; InputStream in = Resources.getResourceAsStream(file); //日志 Logger logger = Logger.getLogger(MybatisFirstTest.class); //创建sqlsessionfactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); //创建sqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User u = userMapper.getUser(1L); logger.info(&quot;再获取一次POJO....&quot;); User u1 = userMapper.getUser(1L); sqlSession.close(); &#125; 这段代码对同一对象进行两次获取，但是在日志中显示只有一条SQL语句被执行，原因是使用了同一个SqlSession对象获取数据，当一个SqlSession第一次通过SQL和参数获取对象后会将其缓存起来，如果下一次SQL和参数没有发生变化，并且缓存没有超时或者需要刷新时，它就会从缓存中直接取数据。 二级缓存二级缓存是在SqlSessionFactory上的缓存，默认情况下，MyBatis系统不会开启二级缓存，需要手动开启，开启二级缓存只需要在映射文件上添加代码： 1&lt;cache/&gt; 这个时候MyBatis会序列化和反序列化对应的POJO对象，也就要求POJO需要实现序列化接口。如果实体类没有实现序列化接口，MyBatis会抛出异常。 1234public class User implements Serializable&#123; public static final long serialVersionUID = 598736524547906734L; .........................&#125; 这个时候从日志上就可以看到不同的SqlSession在获取同一条记录时，都是只发送过一次SQL获取数据，MyBatis将其保存在SqlSessionFactory层面，提供给各个SqlSession使用。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis级联","slug":"MyBatis级联","date":"2019-06-23T15:50:40.000Z","updated":"2019-06-23T15:50:24.800Z","comments":true,"path":"2019/06/23/MyBatis级联/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis级联/","excerpt":"","text":"简述级联是一个数据库实体的概念，级联不是必须的，级联的好处是获取关联数据十分方便，但是级联过多会增加系统的复杂度，同时降低系统的性能，所以当级联的层级超过3层时，就不要考虑使用级联，这样会导致多个对象的关联，导致系统耦合度增加，难以维护。 MyBatis的级联分为3种： 鉴别器（discriminator）：它是一个根据某些条件决定采用具体实现类级联的方案。 一对一（association）：比如身份证和人就是一种一对一的级联关系。 一对多（collection）：比如班主任和学生就是一种一对多的级联关系。 注意！MyBatis中没有多对多级联关系，因为多对多级联比较复杂，使用困难，而且可以通过两个一对多级联进行替换，所以MyBatis不支持多对多级联。 下面主要讲解常用的一对一级联与一对多级联。 一对一级联JavaBean 1234567891011121314151617181920212223242526272829303132333435363738package com.ronin.blog.entity;import lombok.Data;import java.util.Date;import java.util.List;@Datapublic class Article &#123; private Integer articleId; private Integer articleUserId; private String articleTitle; private String articleSummary; private Integer articleViewCount; private Integer articleCommentCount; private Integer articleLikeCount; private Integer articleIsComment; private Integer articleStatus; private Date articleUpdateTime; private Date articleCreateTime; private String articleHtml; private String articleContent; //一对一关系 private User user;&#125; 配置文件 1234567891011121314151617181920&lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.ronin.blog.entity.Article&quot; &gt; &lt;id column=&quot;article_id&quot; property=&quot;articleId&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_user_id&quot; property=&quot;articleUserId&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_title&quot; property=&quot;articleTitle&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;article_summary&quot; property=&quot;articleSummary&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;article_view_count&quot; property=&quot;articleViewCount&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_comment_count&quot; property=&quot;articleCommentCount&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_like_count&quot; property=&quot;articleLikeCount&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_is_comment&quot; property=&quot;articleIsComment&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_status&quot; property=&quot;articleStatus&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_update_time&quot; property=&quot;articleUpdateTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt; &lt;result column=&quot;article_create_time&quot; property=&quot;articleCreateTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt; &lt;result column=&quot;article_html&quot; property=&quot;articleHtml&quot; jdbcType=&quot;LONGVARCHAR&quot; /&gt; &lt;result column=&quot;article_content&quot; property=&quot;articleContent&quot; jdbcType=&quot;LONGVARCHAR&quot; /&gt; &lt;!-- 一对一级联 --&gt; &lt;association property=&quot;user&quot; javaType=&quot;User&quot;&gt; &lt;id column=&quot;user_id&quot; property=&quot;userId&quot;/&gt; &lt;result column=&quot;user_name&quot; property=&quot;userName&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; 一对多级联JavaBean 1234567891011121314151617181920212223242526272829303132333435363738package com.ronin.blog.entity;import lombok.Data;import java.util.Date;import java.util.List;@Datapublic class Article &#123; private Integer articleId; private Integer articleUserId; private String articleTitle; private String articleSummary; private Integer articleViewCount; private Integer articleCommentCount; private Integer articleLikeCount; private Integer articleIsComment; private Integer articleStatus; private Date articleUpdateTime; private Date articleCreateTime; private String articleHtml; private String articleContent; //一对多关系 private List&lt;Tag&gt; tagList;&#125; 配置文件 1234567891011121314151617181920212223&lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.ronin.blog.entity.Article&quot; &gt; &lt;id column=&quot;article_id&quot; property=&quot;articleId&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_user_id&quot; property=&quot;articleUserId&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_title&quot; property=&quot;articleTitle&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;article_summary&quot; property=&quot;articleSummary&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;article_view_count&quot; property=&quot;articleViewCount&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_comment_count&quot; property=&quot;articleCommentCount&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_like_count&quot; property=&quot;articleLikeCount&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_is_comment&quot; property=&quot;articleIsComment&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_status&quot; property=&quot;articleStatus&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;article_update_time&quot; property=&quot;articleUpdateTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt; &lt;result column=&quot;article_create_time&quot; property=&quot;articleCreateTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt; &lt;result column=&quot;article_html&quot; property=&quot;articleHtml&quot; jdbcType=&quot;LONGVARCHAR&quot; /&gt; &lt;result column=&quot;article_content&quot; property=&quot;articleContent&quot; jdbcType=&quot;LONGVARCHAR&quot; /&gt; &lt;!-- 一对多级联 --&gt; &lt;collection property=&quot;tagList&quot; javaType=&quot;list&quot; ofType=&quot;Tag&quot;&gt; &lt;!-- 映射主键 --&gt; &lt;id column=&quot;tag_id&quot; property=&quot;tagId&quot;/&gt; &lt;!-- 映射普通属性 --&gt; &lt;result column=&quot;tag_name&quot; property=&quot;tagName&quot;/&gt; &lt;result column=&quot;tag_description&quot; property=&quot;tagDescription&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt;","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis核心组件的生命周期","slug":"MyBatis核心组件的生命周期","date":"2019-06-23T15:50:40.000Z","updated":"2019-06-23T15:48:03.380Z","comments":true,"path":"2019/06/23/MyBatis核心组件的生命周期/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis核心组件的生命周期/","excerpt":"","text":"简述MyBatis的四大核心组件已经基本掌握，本篇文章就来谈谈四大核心组件的生命周期。首先，什么是生命周期？所谓的生命周期就是每一个对象存活的时间，例如一个对象一次用完后就要关闭，被Java虚拟机（JVM）销毁，以免继续占用资源，所以我们可以根据每个组件的作用来确定其生命周期。 SqlSessionFactoryBuilderSqlSessionFactoryBuilder的作用在于创建SqlSessionFactory，创建成功之后，SqlSessionFactoryBuilder就失去作用，所以它只能存在于创建SqlSessionFactory的方法中。 SqlSessionFactorySqlSessionFactory可以将其当作JDBC中的数据库连接池，它的作用是创建SqlSession接口对象，所以SqlSessionFactory的生命周期存在于整个MyBatis应用当中，可以认为SqlSessionFactory的生命周期等同于MyBatis的生命周期。 SqlSessionSqlSession也可以将其当作JDBC中的数据库连接对象（Connection），在一个事务中，通过SqlSession的commit和rollback方法提交或者回滚事务，所以SqlSession存活在一个业务请求中，处理完整个业务请求之后就应该关闭SqlSession，释放资源，所以SqlSession经常被作为单例使用。 MapperMapper是一个接口，它是通过SqlSession创建出来的，所以它的生命周期最多也是和SqlSession相同，当SqlSession被关闭释放后，Mapper也会消失，所以它的生命周期是小于等于SqlSession的生命周期的。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis配置","slug":"MyBatis配置","date":"2019-06-23T15:50:40.000Z","updated":"2019-06-23T15:48:43.740Z","comments":true,"path":"2019/06/23/MyBatis配置/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis配置/","excerpt":"","text":"简述123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;!-- 配置 --&gt; &lt;!-- 属性 --&gt; &lt;properties&gt;&lt;/properties&gt; &lt;!-- 设置 --&gt; &lt;settings&gt;&lt;/settings&gt; &lt;!-- 设置别名 --&gt; &lt;typeAliases&gt;&lt;/typeAliases&gt; &lt;!-- 类型处理器 --&gt; &lt;typeHandlers&gt;&lt;/typeHandlers&gt; &lt;!-- 对象工厂 --&gt; &lt;objectFactory&gt;&lt;/objectFactory&gt; &lt;!-- 插件 --&gt; &lt;plugins&gt;&lt;/plugins&gt; &lt;!-- 环境配置 --&gt; &lt;environments&gt; &lt;environment&gt; &lt;!-- 事务管理器 --&gt; &lt;transactionManager&gt;&lt;/transactionManager&gt; &lt;!-- 数据源 --&gt; &lt;dataSource&gt;&lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 数据库厂商 --&gt; &lt;databaseIdProvider&gt;&lt;/databaseIdProvider&gt; &lt;!-- 映射器 --&gt; &lt;mappers&gt;&lt;/mappers&gt;&lt;/configuration&gt; 上述的代码是整个MyBatis配置文件中包含的所有重要的节点元素，要注意的是，这些节点元素的顺序不能够颠倒！ properties属性properties属性可以给系统配置运行参数，可以放在XML文件或者properties文件中，这样的好处可以方便我们进行参数的修改，不会引起代码的重新编译。MyBatis提供了三种方式使用properties： property子元素 properties文件 程序代码传递 MyBatis通过properties的属性resource来引入properties文件： 1&lt;properties resource=&quot;jdbc.properties&quot;/&gt; 在这三种方式中，最优先的是使用程序传递的方式，其次是使用properties文件的方式，最后是使用property子元素的方式，MyBatis会根据优先级来覆盖原先配置的属性值。 settings属性settings的配置项很多，但是常用的就只有几个，比如缓存的cacheEnabled，关于级联的lazyLoadingEnabled和aggressiveLazyLoading，关于自动映射的autoMappingBehavior和mapUnderscoreToCamelCase，关于执行器类型的defaultExecutorType等。 typeAliases属性该属性是用于定义类的别名，MyBatis中允许通过typeAliases属性定义一个简写来代表这个类，别名分为系统定义别名和自定义别名，在MyBatis中别名由类TypeAliasRegistry定义的，在MyBatis中别名不区分大小写。 typeHandler属性该属性为类型转换器，在JDBC中，需要在PreparedStatement对象中设置那些已经预编译过的SQL语句的参数。执行SQL后，会通过ResultSet对象获取得到数据库的数据，而这些MyBatis是根据数据的类型通过typeHandler来实现的。 typeHandler中分为javaType和jdbcType两种，其中javaType用于定义java类型，jdbcType用于定义数据库类型，typeHandler的作用就是承担javaType和jdbcType之间的转换。跟别名一样，MyBatis中也存在着系统定义的typeHandler和自定义的typeHandler，MyBatis会根据javaType和jdbcType决定采用哪个typeHandler处理转换规则。 objectFactory属性当创建结果集的时候，MyBatis会使用一个对象工厂来完成创建这个结果集的实例，默认情况下会使用其定义的对象工厂–DefaultObjectFactory来完成工作。当然，MyBatis也支持自定义的ObjectFactory，只需要实现接口org.apache.ibatis.reflection.factory.ObjectFactory,并给予配置。 environment属性该属性主要用于配置数据库环境信息，下级节点包含了：事务管理器（transactionManager）和数据源（dataSource）。 transactionManager它的主要工作就是提交（commit）、回滚（rollback）和关闭（close）数据库的事务。MyBatis为Transaction提供了两个实现类：JdbcTransaction和ManagedTransaction。 对于两种事务管理器，配置分别为： 12&lt;transactionManager type=&quot;JDBC&quot;/&gt;&lt;transactionManager type=&quot;MANAGED&quot;/&gt; JDBC使用JdbcTransactionFactory生成的JdbcTransaction对象实现，它是以JDBC的方式对数据库的提交和回滚进行操作。MANAGED使用ManagedTransactionFactory生成的ManagedTransaction对象实现，它的提交和回滚方法不用任何操作，而是把事务交给容器处理。默认情况下它会关闭连接，需要将closeConnection属性设置为false。 dataSource数据源存在三种类型： 123&lt;dataSource type=&quot;UNPOOLED&quot;/&gt;&lt;dataSource type=&quot;POOLED&quot;/&gt;&lt;dataSource type=&quot;JNDI&quot;/&gt; UNPOOLED采用非数据库池的管理方式，每次请求都会打开一个新的数据库连接，创建速度较慢，可以配置以下属性： driver url username password defaultTransactionIsolationLevel 默认的连接事务隔离级别 POOLED利用“池”的概念将JDBC的Connection对象组织起来，刚开始会有空置，但是再次请求时无须再建立和验证，省去创建新连接的时间，相比UNPOOLED的方式，它有更多于UNPOOLED属性： poolMaximumActiveConnections 任意时间存在的连接数，默认为10 poolMaximumIdleConnections 任意时间存在的空闲连接数 poolMaximumCheckoutTime 被强制返回之前，池中连接被检出的时间，默认20000毫秒 poolTimeToWait poolPingQuery poolPingEnabled 是否启用侦测查询 poolPingConnectionsNotUsedFor 配置poolPingQuery的使用频度 JNDI实现是为了能在如EJB或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个JNDI上下文引用，它需要两种属性： initial_context 用来在InitialContext中寻找上下文 data_source 引用数据源实例位置上下文的路径 mappers属性映射器定义命名空间的方法，命名空间对应的是一个接口的全路径，而不是实现类，映射器引入的方法有很多，分别为： 用文件路径引入映射器 123&lt;mappers&gt; &lt;mapper resource=&quot;com/etc/ssm/mapper/UserMapper.xml&quot;/&gt;&lt;/mappers&gt; 用包名引入映射器 123&lt;mappers&gt; &lt;mapper name=&quot;com.etc.ssm.mapper&quot;/&gt;&lt;/mappers&gt; 用类注册引入映射器 123&lt;mappers&gt; &lt;mapper class=&quot;com.etc.ssm.mapper.UserMapper&quot;/&gt;&lt;/mappers&gt;","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis映射器","slug":"MyBatis映射器","date":"2019-06-23T15:50:40.000Z","updated":"2019-06-23T15:49:28.984Z","comments":true,"path":"2019/06/23/MyBatis映射器/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis映射器/","excerpt":"","text":"简述映射器是MyBatis最复杂且最重要的组件，它由一个接口加上XML文件（或者注解）组成。在映射器中可以配置参数、各类SQL语句、存储过程、缓存、级联等复杂内容，并且通过建议的映射规则映射到指定的POJO或者其他对象上，映射器能有效消除JDBC底层的代码。| 元素名称 | 描述 | 备注 || —————- | ———————————————————- | ————————————————— || select | 查询语句，最常用、最复杂的元素之一 | 可以自定义参数，返回结果集等 || insert | 插入语句 | 执行后返回一个整数，代表插入的条数 || update | 更新语句 | 执行后返回一个整数，代表更新的条数 || delete | 删除语句 | 执行后返回一个整数，代表删除的条数 || parameterMap | 定义参数映射关系 | 即将被删除的元素，不建议大家使用 || sql | 定义一部分SQL，在各个地方引用它 | 例如，一张表列名，一次定义，可以在多个SQL语句中使用 || resultMap | 用来描述从数据库结果集中加载对象，它是最复杂、最强大的元素 | 提供映射规则 || cache | 给定命名空间的缓存配置 | || cache-ref | 其他命名空间缓存配置的引用 | | select元素先来看看select元素的几个重要配置：| 元素 | 说明 | 备注 || —————- | ———————————————————— | ———————————————————- || id | 它和Mapper的命名空间组合起来是唯一的，供MyBatis调用 | 如果命名空间和id结合起来不唯一，MyBatis会抛出异常 || parameterType | 类的全命名，也可以是别名，但是别名必须是MyBatis内部定义的 | 可以选择JavaBean、Map等简单参数类型传递给SQL || parameterMap | 即将废弃的元素 | || resultType | 定义类的全路径，结果集将通过JavaBean的规范映射或者定义成int、double等参数，也可以使用别名 | 常用的参数之一 || resultMap | 它是映射集的引用，执行强大的映射功能，resultMap能提供自定义的映射规则 | MyBatis最复杂的元素，可以配置映射规则、级联、typeHandler等 || useCache | 启动二级缓存的开关，是否要求MyBatis将此次结果缓存 | 取值为布尔值，默认值为true | 简单的select例子： 123&lt;select id=&quot;findArticleById&quot; parameterType=&quot;integer&quot; resultMap=&quot;BaseResultMap&quot;&gt; SELECT * FROM article WHERE id = #&#123;id&#125;&lt;/select&gt; id配合Mapper的全限定名，成为一个唯一的标识，标识这条SQL parameterType为入参的类型 resultMap为SQL语句返回的结果集的映射 自动映射和驼峰映射MyBatis提供了自动映射功能，默认情况下自动映射是开启的，使用自动映射功能可以大量减少映射配置，在setting元素中有两个配置的选项 autoMappingBehavior 和 mapUnderscoreToCamelCase，它们是控制自动映射和驼峰映射的开关。 配置自动映射的 autoMappingBehavior 选项取值范围是： NONE 不进行自动映射 PARTIAL 默认值，只对没有嵌套结果集进行自动映射 FULL 对所有结果集进行自动映射，包括嵌套结果集 传参问题在上面的例子中，只有一个参数传递，现实需求可能需要多个参数，MyBatis提供了多种方法来解决多参传入的问题。 使用map接口传递参数 接口定义 1public List&lt;User&gt; findUserByMap(Map&lt;String,Object&gt;parameterMap); 映射器 123&lt;select id=&quot;findUserByMap&quot; parameterType=&quot;map&quot; resultType=&quot;user&quot;&gt; SELECT * FROM user WHERE id = #&#123;id&#125; and name = #&#123;name&#125;&lt;/select&gt; 注意，参数id和name，要求的是map的键！ 使用注解传递多个参数 @Param 使用map传递参数有个弊端–代码可读性差，MyBatis提供了一个注解@Param，可以通过它去定义映射器的参数名称。 接口定义 1public List&lt;User&gt; findUserByMap(@Param(&quot;id&quot;)Integer id,@Param(&quot;name&quot;)String name); 映射器 123&lt;select id=&quot;findUserByMap&quot; resultType=&quot;user&quot;&gt; SELECT * FROM user WHERE id = #&#123;id&#125; and name = #&#123;name&#125;&lt;/select&gt; 注意，这里使用了@Param注解就不需要给出parameterType属性，MyBatis可以自动探索。 通过JavaBean传递多个参数 定义POJO 12345public class UserSelect&#123; private Integer id; private String name; ................&#125; 接口定义 1public List&lt;User&gt; findUserByMap(UserSelect userSelect); 映射器 123&lt;select id=&quot;findUserByMap&quot; parameterType=&quot;com.ssm.vo.UserSelect&quot; resultType=&quot;user&quot;&gt; SELECT * FROM user WHERE id = #&#123;userSelect.id&#125; and name = #&#123;userSelect.name&#125;&lt;/select&gt; insert、update、delete元素由于insert、update、delete这三个元素使用方法类似，这里就将三种元素放在一起。 MyBatis在执行完insert、update、delete语句之后，会返回一个整数来表示其影响的数据库记录数。 insert 123456789101112&lt;insert id=&quot;insert&quot; parameterType=&quot;com.ronin.blog.entity.Article&quot; &gt; insert into article (article_user_id, article_title, article_summary, article_view_count, article_comment_count, article_like_count, article_is_comment, article_status, article_update_time, article_create_time, article_html, article_content) values ( #&#123;articleUserId,jdbcType=INTEGER&#125;, #&#123;articleTitle,jdbcType=VARCHAR&#125;, #&#123;articleViewCount,jdbcType=INTEGER&#125;, #&#123;articleCommentCount,jdbcType=INTEGER&#125;, #&#123;articleLikeCount,jdbcType=INTEGER&#125;, #&#123;articleIsComment,jdbcType=INTEGER&#125;, #&#123;articleStatus,jdbcType=INTEGER&#125;, #&#123;articleUpdateTime,jdbcType=TIMESTAMP&#125;, #&#123;articleCreateTime,jdbcType=TIMESTAMP&#125;, #&#123;articleHtml,jdbcType=LONGVARCHAR&#125;, #&#123;articleContent,jdbcType=LONGVARCHAR&#125;)&lt;/insert&gt; 主键回填可以看出上面这条语句没有插入id列，因为MySql中表格采用了主键自增，MySql数据库会自动生成主键，我们也可以在MyBatis插入数据时获取到数据库生成的主键值。在insert语句中有个开关属性 useGeneratedKeys，用来控制是否打开这个功能，默认值是false。打开时要配置其属性 keyProperty 或 keyColumn，告诉系统把生成的主键放入哪个属性,如果存在多个主键，用逗号（，）隔开。 update 12345678910111213141516&lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;com.ronin.blog.entity.Article&quot; &gt; update article set article_user_id = #&#123;articleUserId,jdbcType=INTEGER&#125;, article_title = #&#123;articleTitle,jdbcType=VARCHAR&#125;, article_summary = #&#123;articleSummary,jdbcType=VARCHAR&#125;, article_view_count = #&#123;articleViewCount,jdbcType=INTEGER&#125;, article_comment_count = #&#123;articleCommentCount,jdbcType=INTEGER&#125;, article_like_count = #&#123;articleLikeCount,jdbcType=INTEGER&#125;, article_is_comment = #&#123;articleIsComment,jdbcType=INTEGER&#125;, article_status = #&#123;articleStatus,jdbcType=INTEGER&#125;, article_update_time = #&#123;articleUpdateTime,jdbcType=TIMESTAMP&#125;, article_create_time = #&#123;articleCreateTime,jdbcType=TIMESTAMP&#125;, article_html = #&#123;articleHtml,jdbcType=LONGVARCHAR&#125;, article_content = #&#123;articleContent,jdbcType=LONGVARCHAR&#125; where article_id = #&#123;articleId,jdbcType=INTEGER&#125; &lt;/update&gt; delete 1234&lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot; &gt; delete from article where article_id = #&#123;articleId,jdbcType=INTEGER&#125;&lt;/delete&gt; sql元素sql元素的作用在于可以定义一条SQL的一部分，方便后面的SQL引用它，把重复的SQL语句抽取出来，降低耦合性。 定义 123&lt;sql id=&quot;articleAndTagLine&quot;&gt; a.* , t.tag_id , t.tag_description , t.tag_name , u.user_id , u.user_name&lt;/sql&gt; 引用 123&lt;select id=&quot;selectTopArticle&quot; resultMap=&quot;BaseResultMap&quot;&gt; select &lt;include refid=&quot;articleLine&quot;/&gt; from article&lt;/select&gt; resultMap元素resultMap的作用是定义映射规则、级联的更新、定制类型转化器等。resultMap定义的主要是一个结果集的映射关系，就是SQL到JavaBean的映射关系定义，它也支持级联等特性。 12345678910&lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.ronin.blog.entity.Article&quot; &gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;title&quot; property=&quot;title&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;keywords&quot; property=&quot;keywords&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;desci&quot; property=&quot;desci&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;pic&quot; property=&quot;pic&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;click&quot; property=&quot;click&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;time&quot; property=&quot;time&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt; &lt;result column=&quot;catalog_id&quot; property=&quot;catalogId&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;/resultMap&gt;","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis核心组件之SQL Mapper","slug":"MyBatis核心组件之SQL Mapper","date":"2019-06-23T15:46:23.000Z","updated":"2019-06-23T15:47:23.468Z","comments":true,"path":"2019/06/23/MyBatis核心组件之SQL Mapper/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis核心组件之SQL Mapper/","excerpt":"","text":"简述映射器（SQL Mapper）是MyBatis中最重要、最复杂的组件，它是由一个接口和对应的XML文件组成，它可以配置以下内容： 描述映射规则 提供SQL语句，并可以配置SQL参数类型、返回类型、缓存刷新等信息 配置缓存 提供动态SQL 映射器的主要作用就是将SQL查询到的结果映射成一个POJO（Java原生对象），或者将POJO的数据插入到数据库中，并定义一些关于缓存等的重要内容。 下面提供两种方式实现映射器，首先我们先定义一个POJO对象： 1234567public class User&#123; private Long id; private String username; private String password; /** getter 和 setter 方法**/&#125; XML实现映射器用XML定义映射器分为两个部分：接口和XML。首先，定义一个映射器接口,提供一个通过id获取用户的方法。 123public interface UserMapper&#123; public User getUser(Long id);&#125; 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.etc.ssm.mapper.UserMapper&quot;&gt; &lt;!-- 获取用户 --&gt; &lt;select id=&quot;getUser&quot; parameterType=&quot;long&quot; resultType=&quot;user&quot;&gt; select * from tb_user where id= #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 注意：select元素节点的id属性值要与其对应的方法名相同！mapper元素节点：属性namespace所对应的是一个接口的全限定名，MyBatis上下文就可以通过它找到对应的接口。select元素节点：表明这是一条查询语句，属性id标识了这条SQL，属性parameterType=”long“说明传递给SQL的是一个long型的参数，resultType=”user”表示返回的是一个user类型的返回值，user是之前配置文件中设置过的别名。 注解实现映射器注解实现映射器相对于XML实现映射器较为简单，它只需要一个接口就可以，通过MyBatis的注解来注入SQL语句。 1234public interface UserMapper&#123; @Select(&quot;select * from tb_user where id= #&#123;id&#125;&quot;); public User getUser(Long id);&#125; 需要注意的是，当XML方式与注解方式同时定义时，XML方式会覆盖掉注解方式，所以MyBatis官方推荐使用的是XML实现映射器的方式，但是不同场景有不同的选择，在SQL语句量较少的情况下，使用注解方式会效率更高，但是与代码的耦合度较高。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis核心组件之SqlSession","slug":"MyBatis核心组件之SqlSession","date":"2019-06-23T15:46:23.000Z","updated":"2019-06-23T15:46:40.035Z","comments":true,"path":"2019/06/23/MyBatis核心组件之SqlSession/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis核心组件之SqlSession/","excerpt":"","text":"SqlSession在MyBatis中，SqlSession是其和新街口。在MyBatis中有两个实现类，DefaultSqlSession和SqlSessionManager。DefaultSqlSession是单线程使用的，而SqlSessionManager是在多线程环境下使用的。 SqlSession的作用类似于一个JDBC中的Connection对象，代表着一个连接资源的启用。具体而言，它的作用有3个： 获取Mapper接口 发送SQL给数据库 控制数据库事务 从上一篇文章中我们已经知道了怎么创建SqlSessionFactory，通过SqlSessionFactory的方法，我们可以直接创建处SqlSession对象，代码如下： 1SqlSession sqlSession = SqlSeesionFactory.openSession(); 创建出SqlSession对象，我们可以通过SqlSession对象来控制数据库的事务： 1234567891011121314151617//定义SqlSessionSqlSession sqlSession = null;try&#123; //打开SqlSession会话 sqlSession = SqlSessionFactory.openSession(); //业务逻辑代码..... // 提交事务 sqlSession.commit();&#125;catch(Exception ex)&#123; //事务回滚 sqlSession.rollback();&#125;finally&#123; //在finally语句中确保资源顺利关闭 if(sqlSession != null)&#123; sqlSession.close(); &#125;&#125; 上述代码中，使用commit方法提交事务，出错后通过rollback回滚事务，保证了代码运行时的数据的一致性。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis核心组件之SqlSessionFactory","slug":"MyBatis核心组件之SqlSessionFactory","date":"2019-06-23T15:28:20.000Z","updated":"2019-06-23T15:29:07.531Z","comments":true,"path":"2019/06/23/MyBatis核心组件之SqlSessionFactory/","link":"","permalink":"http://yoursite.com/2019/06/23/MyBatis核心组件之SqlSessionFactory/","excerpt":"","text":"MyBatis的核心组件MyBatis的核心组件分为4个部分： SqlSessionFactoryBuilder（构造器）：它会根据配置或者代码来生成SqlSessionFactory，采用的是分布构建的Builder模式。 SqlSessionFactory（工厂接口）：依靠它来生成SqlSession，使用的是工厂模式。 SqlSession（会话）：一个既可以发送SQL执行返回结果，也可以获取Mapper的接口。在现有的技术中，一般我们会让其在业务逻辑代码中“消失”，而使用的是MyBatis提供的SQL Mapper接口编程技术，它能提高代码的可读性和可维护性。 SQL Mapper（映射器）：MyBatis新设计存在的组件，它由一个Java接口和XML文件（或注解）构成，需要给出对应的SQL和映射规则。它负责发送SQL去执行，并返回结果。 SqlSessionFactory使用MyBatis首先是使用配置或者代码去生产SqlSessionFactory，而MyBatis提供了构造器SqlSessionFactoryBuilder。它提供了一个类org.apache.ibatis.session.Configuration作为引导，采用的是Builder模式。 在MyBatis中，既可以通过读取配置的XML文件的形式生成SqlSessionFactory，也可以通过Java代码的形式去生成SqlSessionFactory。每个基于MyBatis的应用都是以一个SqlSessionFactory的实例为中心的，而SqlSessionFactory唯一的作用就是生产MyBatis的核心接口对象SqlSession，所以它的责任是唯一的，我们往往可以通过单例模式处理它。下面为两种方式创建SqlSessionFactory的代码。 使用XML构建SqlSessionFactory12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 设置别名 --&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.etc.ssm.entity&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- 加载数据库属性文件 --&gt; &lt;properties resource=&quot;db.properties&quot;&gt;&lt;/properties&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!--使用JDBC实务管理--&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!--连接池 POOLED为连接池方式 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 引入映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com.etc.ssm.mapper.UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; typeAliase节点：定义一个别名，代表com.etc.ssm.entity包下所有的类在MyBatis上下文中可以使用别名去代替全限定名。properties节点：可以引入指定目录下的配置文件。environments节点：描述的是数据库，其中transactionManager节点是配置事务管理器，采用MyBatis中JDBC的管理器方式，采用dataSource节点配置数据库，POOLED表示采用MyBatis内部提供的连接池方式。mappers节点：引入映射器。 1234567891011@Testpublic void testXmlSqlSessionFactory() &#123; SqlSessionFactory sqlSessionFactory = null; String resource = &quot;sqlMapConfig.xml&quot;; InputStream inputStream; try &#123; inputStream = Resource.getResourceAsStream(resource); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 使用代码创建SqlSessionFactory这种方法创建SqlSessionFactory不推荐使用。 123456789101112131415161718192021//数据库连接池信息PooledDataSource dataSource=new PooledDataSource();dataSource.setDriver(&quot;com.mysql.jdbc.Driver&quot;);dataSource.setUsername(&quot;root&quot;);dataSource.setPassword(&quot;123456&quot;);dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/ssm&quot;);dataSource.setDefaultAutoCommit(false);//采用MyBatis的JDBC事务方式TransactionFactory transactionFactory =new JdbcTransactionFactory();Environment environment=new Environment(&quot;development&quot;,transactionFactory,dataSource);/创建 Configuration对象Configuration configuration=new Configuration(environment);//注册一个MyBatis上下文别名configuration.getTypeAliasRegistry().registerAlias(&quot;user&quot;,User.class);//加入一个映射器configuration.addMapper(UserMapper.class);//使用 SqlSessionFactoryBuilder 构建SqlSessionFactorySqlSessionFactory SqlSessionFactory=new SqlSessionFactoryBuilder().,build(configuration);return SqlSessionFactory;","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis","slug":"MyBatis","date":"2019-06-22T14:40:20.000Z","updated":"2019-06-22T14:41:39.005Z","comments":true,"path":"2019/06/22/MyBatis/","link":"","permalink":"http://yoursite.com/2019/06/22/MyBatis/","excerpt":"","text":"MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。 iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAOs） 当前，最新版本是MyBatis 3.5.1 ，其发布时间是2019年4月8日。 持久层的概念和MyBatis的特点上面介绍到MyBatis是一个持久层的框架，它是对JDBC进行了简单的封装，那么我们来讲讲什么是持久层。 持久层是三层架构（控制层、业务逻辑层、持久层）中的一层，持久层可以将业务数据存储到磁盘，具备长期存储的能力，只要磁盘不损坏，在断电或者其他情况下，重新开启系统仍然可以读取到这些数据。一般执行持久任务的都是数据库系统，持久层可以使用巨大的磁盘空间，也比较廉价，它的缺点就是比较慢。当然，慢是针对内存来说的，在一般的系统中运行是不存在问题的。但是在互联网的秒杀场景下，慢是不能接受的，极有可能导致宕机，在这样的场景下考虑使用Redis处理。 MyBatis的三大特点： 不屏蔽SQL，意味着可以更为精确的定位SQL语句，可以对其进行优化和改造，这有利于互联网系统性能的提高，符合互联网需要性能优化的特点。 提供强大、灵活的映射机制，方便Java开发者使用，提供动态SQL的功能，允许我们根据不同条件组装SQL，这个功能远比其他工具或者Java编码的可读性和可维护性高的多，满足各种应用系统的同时也满足了需求经常变化的互联网应用的要求。 在MaBatis中，提供了使用Mapper的接口编程，只要一个接口和一个XML就能创建映射器，进一步简化我们的工作，使得很多框架API在MyBatis中消失，开发者能更集中于业务逻辑。 ORM这里我们介绍一下什么叫做ORM。 ORM也称对象关系映射，是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。从效果上说，它其实是创建了一个可在编程语言里使用的–“虚拟对象数据库”。 面向对象是从软件工程基本原则（如耦合、聚合、封装）的基础上发展起来的，而关系数据库则是从数学理论发展而来的，两套理论存在显著的区别。为了解决这个不匹配的现象，对象关系映射技术应运而生。 对象关系映射（ORM）提供了概念性的、易于理解的模型化数据的方法。ORM方法论基于三个核心原则： 简单：以最基本的形式建模数据。 传达性：数据库结构被任何人都能理解的语言文档化。 精确性：基于数据模型创建正确标准化的结构。 典型地，建模者通过收集来自那些熟悉应用程序但不熟练的数据建模者的人的信息开发信息模型。建模者必须能够用非技术企业专家可以理解的术语在概念层次上与数据结构进行通讯。建模者也必须能以简单的单元分析信息，对样本数据进行处理。ORM专门被设计为改进这种联系。 简单的说：ORM相当于中继数据。具体到产品上，例如ADO.NET Entity Framework。DLINQ中实体类的属性[Table]就算是一种中继数据。 MyBatis与Hibernate说到ORM框架，第一个想到的持久层框架应该就是Hibernate，Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的ORM框架，hibernate可以自动生成SQL语句，自动执行。 MyBatis严格来说是一个半ORM框架，相对于Hibernate，它并没有像Hibernate一样完全的ORM，但是正是因为它的半ORM以及简单快速的开发效率，让MyBatis成为现在互联网项目首选的持久层框架之一。 MyBatis与Hibernate两者对比 开发速度 就开发速度而言，Hibernate的真正掌握要比Mybatis来得难些。Mybatis框架相对简单很容易上手，但也相对简陋些。 比起两者的开发速度，不仅仅要考虑到两者的特性及性能，更要根据项目需求去考虑究竟哪一个更适合项目开发，比如：一个项目中用到的复杂查询基本没有，就是简单的增删改查，这样选择hibernate效率就很快了，因为基本的sql语句已经被封装好了，根本不需要你去写sql语句，这就节省了大量的时间，但是对于一个大型项目，复杂语句较多，这样再去选择hibernate就不是一个太好的选择，选择mybatis就会加快许多，而且语句的管理也比较方便。 开发工作量 Hibernate和MyBatis都有相应的代码生成工具。可以生成简单基本的DAO层方法。针对高级查询，Mybatis需要手动编写SQL语句，以及ResultMap。而Hibernate有良好的映射机制，开发者无需关心SQL的生成与结果映射，可以更专注于业务流程。 SQL优化 Hibernate的查询会将表中的所有字段查询出来，这一点会有性能消耗。Hibernate也可以自己写SQL来指定需要查询的字段，但这样就破坏了Hibernate开发的简洁性。而Mybatis的SQL是手动编写的，所以可以按需求指定查询的字段。 Hibernate HQL语句的调优需要将SQL打印出来，而Hibernate的SQL被很多人嫌弃因为太丑了。MyBatis的SQL是自己手动写的所以调整方便。但Hibernate具有自己的日志统计。Mybatis本身不带日志统计，使用Log4j进行日志记录。 对象管理的对比 Hibernate 是完整的对象/关系映射解决方案，它提供了对象状态管理（state management）的功能，使开发者不再需要理会底层数据库系统的细节。也就是说，相对于常见的 JDBC/SQL 持久层方案中需要管理 SQL 语句，Hibernate采用了更自然的面向对象的视角来持久化 Java 应用中的数据。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]}]}