{"meta":{"title":"Ronin Blog","subtitle":null,"description":null,"author":"RoninTottoo","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2019-06-22T12:11:10.000Z","updated":"2019-06-22T13:45:35.927Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Ronin 一名即将成为程序员的软件工程学生"},{"title":"categories","date":"2019-06-22T12:12:22.000Z","updated":"2019-06-22T12:52:09.838Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-22T12:12:13.000Z","updated":"2019-06-22T12:53:52.327Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MyBatis","slug":"MyBatis","date":"2019-06-22T14:40:20.000Z","updated":"2019-06-22T14:41:39.005Z","comments":true,"path":"2019/06/22/MyBatis/","link":"","permalink":"http://yoursite.com/2019/06/22/MyBatis/","excerpt":"","text":"MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。 iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAOs） 当前，最新版本是MyBatis 3.5.1 ，其发布时间是2019年4月8日。 持久层的概念和MyBatis的特点上面介绍到MyBatis是一个持久层的框架，它是对JDBC进行了简单的封装，那么我们来讲讲什么是持久层。 持久层是三层架构（控制层、业务逻辑层、持久层）中的一层，持久层可以将业务数据存储到磁盘，具备长期存储的能力，只要磁盘不损坏，在断电或者其他情况下，重新开启系统仍然可以读取到这些数据。一般执行持久任务的都是数据库系统，持久层可以使用巨大的磁盘空间，也比较廉价，它的缺点就是比较慢。当然，慢是针对内存来说的，在一般的系统中运行是不存在问题的。但是在互联网的秒杀场景下，慢是不能接受的，极有可能导致宕机，在这样的场景下考虑使用Redis处理。 MyBatis的三大特点： 不屏蔽SQL，意味着可以更为精确的定位SQL语句，可以对其进行优化和改造，这有利于互联网系统性能的提高，符合互联网需要性能优化的特点。 提供强大、灵活的映射机制，方便Java开发者使用，提供动态SQL的功能，允许我们根据不同条件组装SQL，这个功能远比其他工具或者Java编码的可读性和可维护性高的多，满足各种应用系统的同时也满足了需求经常变化的互联网应用的要求。 在MaBatis中，提供了使用Mapper的接口编程，只要一个接口和一个XML就能创建映射器，进一步简化我们的工作，使得很多框架API在MyBatis中消失，开发者能更集中于业务逻辑。 ORM这里我们介绍一下什么叫做ORM。 ORM也称对象关系映射，是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。从效果上说，它其实是创建了一个可在编程语言里使用的–“虚拟对象数据库”。 面向对象是从软件工程基本原则（如耦合、聚合、封装）的基础上发展起来的，而关系数据库则是从数学理论发展而来的，两套理论存在显著的区别。为了解决这个不匹配的现象，对象关系映射技术应运而生。 对象关系映射（ORM）提供了概念性的、易于理解的模型化数据的方法。ORM方法论基于三个核心原则： 简单：以最基本的形式建模数据。 传达性：数据库结构被任何人都能理解的语言文档化。 精确性：基于数据模型创建正确标准化的结构。 典型地，建模者通过收集来自那些熟悉应用程序但不熟练的数据建模者的人的信息开发信息模型。建模者必须能够用非技术企业专家可以理解的术语在概念层次上与数据结构进行通讯。建模者也必须能以简单的单元分析信息，对样本数据进行处理。ORM专门被设计为改进这种联系。 简单的说：ORM相当于中继数据。具体到产品上，例如ADO.NET Entity Framework。DLINQ中实体类的属性[Table]就算是一种中继数据。 MyBatis与Hibernate说到ORM框架，第一个想到的持久层框架应该就是Hibernate，Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的ORM框架，hibernate可以自动生成SQL语句，自动执行。 MyBatis严格来说是一个半ORM框架，相对于Hibernate，它并没有像Hibernate一样完全的ORM，但是正是因为它的半ORM以及简单快速的开发效率，让MyBatis成为现在互联网项目首选的持久层框架之一。 MyBatis与Hibernate两者对比 开发速度 就开发速度而言，Hibernate的真正掌握要比Mybatis来得难些。Mybatis框架相对简单很容易上手，但也相对简陋些。 比起两者的开发速度，不仅仅要考虑到两者的特性及性能，更要根据项目需求去考虑究竟哪一个更适合项目开发，比如：一个项目中用到的复杂查询基本没有，就是简单的增删改查，这样选择hibernate效率就很快了，因为基本的sql语句已经被封装好了，根本不需要你去写sql语句，这就节省了大量的时间，但是对于一个大型项目，复杂语句较多，这样再去选择hibernate就不是一个太好的选择，选择mybatis就会加快许多，而且语句的管理也比较方便。 开发工作量 Hibernate和MyBatis都有相应的代码生成工具。可以生成简单基本的DAO层方法。针对高级查询，Mybatis需要手动编写SQL语句，以及ResultMap。而Hibernate有良好的映射机制，开发者无需关心SQL的生成与结果映射，可以更专注于业务流程。 SQL优化 Hibernate的查询会将表中的所有字段查询出来，这一点会有性能消耗。Hibernate也可以自己写SQL来指定需要查询的字段，但这样就破坏了Hibernate开发的简洁性。而Mybatis的SQL是手动编写的，所以可以按需求指定查询的字段。 Hibernate HQL语句的调优需要将SQL打印出来，而Hibernate的SQL被很多人嫌弃因为太丑了。MyBatis的SQL是自己手动写的所以调整方便。但Hibernate具有自己的日志统计。Mybatis本身不带日志统计，使用Log4j进行日志记录。 对象管理的对比 Hibernate 是完整的对象/关系映射解决方案，它提供了对象状态管理（state management）的功能，使开发者不再需要理会底层数据库系统的细节。也就是说，相对于常见的 JDBC/SQL 持久层方案中需要管理 SQL 语句，Hibernate采用了更自然的面向对象的视角来持久化 Java 应用中的数据。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"Spring AOP","slug":"Spring Aop","date":"2019-06-22T12:46:20.000Z","updated":"2019-06-22T12:46:10.254Z","comments":true,"path":"2019/06/22/Spring Aop/","link":"","permalink":"http://yoursite.com/2019/06/22/Spring Aop/","excerpt":"","text":"AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 AOP 技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。 AOP 使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 AOP术语 切面（Aspect）类是对物体特征的抽象，切面就是对横切关注点的抽象，例如数据库的事务贯穿了整个代码层面，这就是一个切面，它可以定义后面需要的各类通知、切点和引入内容。 通知（Advice）通知是切面开启后，切面的方法。它根据在代理对象真实方法调用前后的顺序和逻辑区分。前置通知（before）：在动态代理反射原有对象方法或者执行环绕通知前执行的通知功能。后置通知（after）：在动态代理反射原有对象方法或者执行环绕通知后执行的通知功能。不论是否抛出异常都会执行。返回通知（afterReturning）：在动态代理反射原有对象方法或者执行环绕通知后正常返回（无异常）执行的通知功能。异常通知（afterThrowing）：在动态代理反射原有对象方法或者执行环绕通知产生异常后执行的通知功能。环绕通知（around）：在动态代理中，它可以取代当前被拦截对象的方法，提供回调原有被拦截对象的方法。 引入（Introduction）引入允许我们在现有的类里添加自定义的类和方法。 切点（Pointcut）这是一个告诉 Spring AOP 在什么时候启动拦截并织入对应的流程中，因为并不是所有的开发都需要启动 AOP，它往往通过切点表达式进行限定。 连接点（Join point）连接点对应的是具体需要拦截的东西，比如通过切点的切点表达式去判断哪个方法是连接点，从而织入对应的通知。 织入（Weaving）织入是一个生成代理对象并将切面内容放入到流程中的过程。实际代理的方法分为动态代理和静态代理。 XML配置开发Spring AOPSpring 提供了两种方式配置 AOP，注解配置和XML文件配置，在这我们只介绍XML文件配置方式。| AOP配置元素 | 用途 | 备注 ||–|–|–|| aop:advisor | 定义AOP的通知器 | 一种较老的方式，目前很少使用 || aop:aspect | 定义一个切面 | / || aop:before | 定义前置通知 | / || aop:after | 定义后置通知 | / || aop:around | 定义环绕方式 | / || aop:after-returning | 定义返回通知 | / || aop:after-throwing | 定义异常通知 | / || aop:config | 顶层的AOP配置元素 | AOP的配置根节点 || aop:declare-parents | 给通知引入新的额外接口，增强功能 | /|| aop:pointcut | 定义切点 | /| 简单的 AOP 案例：定义接口 1234public interface PhoneService&#123; public void call(); public void send_sms();&#125; 实现类 12345678public class PhoneServiceImpl&#123; public void call()&#123; System.out.println(&quot;***打电话&quot;); &#125; public void send_sms()&#123; System.out.println(&quot;***发短信&quot;); &#125;&#125; 通知类 12345678pulbic class MyAdvice&#123; public void beforeLog()&#123; System.out.println(“准备执行移动业务======”); &#125; public void afterLog()&#123; System.out.println(&quot;本次业务需要10元======&quot;); &#125;&#125; XML配置 1234567891011&lt;bean id=&quot;phone&quot; class=&quot;com.etc.service.impl.PhoneServiceImpl&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;myAdvice&quot; class=&quot;com.etc.common.MyAdvice&quot;&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;!—配置切点，即需要将方法织入的位置--&gt; &lt;aop:pointcut id=&quot;pc&quot; expression=“execution(* com.etc.service.impl.PhoneServiceImpl.*(...))”/&gt; &lt;!—配置切面feeAdvice是Bean的id --&gt; &lt;aop:aspect ref=&quot;myAdvice&quot;&gt; &lt;aop:before method=&quot;beforLog&quot; pointcut-ref=&quot;pc&quot;/&gt; &lt;aop:after method=&quot;afterLog&quot; pointcut-ref=&quot;pc&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; &lt; aop:aspect &gt;：用于定义切面类&lt; aop:before &gt;：定义前置通知&lt; aop:after &gt;：定义后置通知&lt; aop:after-throwing &gt;：定义异常通知&lt; aop:after-retruning &gt;：定义返回通知","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"AOP","slug":"AOP","permalink":"http://yoursite.com/tags/AOP/"}]}]}