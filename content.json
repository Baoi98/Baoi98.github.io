{"meta":{"title":"Yellow Blog","subtitle":null,"description":null,"author":98,"url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Spring Boot整合MyBatis","slug":"SpringBoot整合MyBatis","date":"2019-08-27T01:42:36.667Z","updated":"2019-08-27T01:43:25.574Z","comments":true,"path":"2019/08/27/SpringBoot整合MyBatis/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringBoot整合MyBatis/","excerpt":"","text":"SpringBoot 提供了整合 MyBatis 的功能，通过简单的配置就能完成。 pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.ronin&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-mybatis&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-mybatis&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;javax.persistence-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置文件1234567891011121314151617181920server: port: 8080spring: datasource: username: root password: 123456 url: jdbc:mysql://localhost:3306/user?useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Drivermybatis: mapper-locations: classpath:mapper/*Mapper.xml type-aliases-package: com.ronin.springbootmybatis.entity#showSqllogging: level: com: example: mapper : debug 实体类123456789101112131415161718192021222324package com.ronin.springbootmybatis.entity;import lombok.Data;import javax.persistence.Column;import javax.persistence.Id;import javax.persistence.Table;/** * @Author: 98 * @Date: 2019-8-24 21:26 */@Data@Table(name=\"tb_user\")public class User &#123; @Id @Column(name = \"id\") private Integer id; @Column(name = \"username\") private String username;&#125; Mapper 和 Mapper.xml123456789101112131415161718package com.ronin.springbootmybatis.mapper;import com.ronin.springbootmybatis.entity.User;import org.apache.ibatis.annotations.Mapper;import org.springframework.stereotype.Repository;import java.util.List;/** * @Author: 98 * @Date: 2019-8-24 21:29 */@Repositorypublic interface UserMapper &#123; List&lt;User&gt; selectUsers();&#125; 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.ronin.springbootmybatis.mapper.UserMapper\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.ronin.springbootmybatis.entity.User\"&gt; &lt;result column=\"id\" jdbcType=\"INTEGER\" property=\"id\" /&gt; &lt;result column=\"userName\" jdbcType=\"VARCHAR\" property=\"username\" /&gt; &lt;/resultMap&gt; &lt;select id=\"selectUsers\" resultType=\"com.ronin.springbootmybatis.entity.User\"&gt; select * from tb_user &lt;/select&gt;&lt;/mapper&gt; Controller 和 Service123456789101112131415161718192021222324252627package com.ronin.springbootmybatis.controller;import com.ronin.springbootmybatis.entity.User;import com.ronin.springbootmybatis.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;/** * @Author: 98 * @Date: 2019-8-24 21:35 */@RestControllerpublic class UserController &#123; @Autowired private UserService userService; @GetMapping(\"users\") public String getUsers()&#123; List&lt;User&gt; userList = userService.selectUsers(); return userList.toString(); &#125;&#125; 12345678910111213141516171819202122232425package com.ronin.springbootmybatis.service.impl;import com.ronin.springbootmybatis.entity.User;import com.ronin.springbootmybatis.mapper.UserMapper;import com.ronin.springbootmybatis.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * @Author: 98 * @Date: 2019-8-24 21:33 */@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserMapper userMapper; @Override public List&lt;User&gt; selectUsers() &#123; return userMapper.selectUsers(); &#125;&#125; 测试我们通过请求 Restful API，通过返回值观察是否成功 请求返回值为数据库表中数据，整合 MyBatis 成功！！！！","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring Boot整合Spring Data JPA","slug":"SpringBoot整合Spring Data JPA","date":"2019-08-27T01:39:06.512Z","updated":"2019-08-27T01:41:26.009Z","comments":true,"path":"2019/08/27/SpringBoot整合Spring Data JPA/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringBoot整合Spring Data JPA/","excerpt":"","text":"JPAJPA是Java Persistence API的简称，中文名Java持久层API，是SUN公司在JDK 5.0后提出的Java持久化规范，通过注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。 JPA的总体思想和现有Hibernate、TopLink、JDO等ORM框架大体一致。总的来说，JPA包括以下3方面的技术： ORM映射元数据 JPA支持XML和JDK5.0注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中 API 用来操作实体对象，执行CRUD操作，框架在后台替代我们完成所有的事情，开发者从繁琐的JDBC和SQL代码中解脱出来。 查询语言 这是持久化操作中很重要的一个方面，通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。 Spring Data JPA是Spring Data家族的一部分，可以轻松实现基于JPA的存储库。 此模块处理对基于JPA的数据访问层的增强支持。 Spring Data JPA提供的核心接口： Repository 接口 CrudRepository 接口 pagingAndSortingRepository 接口 JpaRepository 接口 JpaSpecificationExecutor 接口 pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.ronin&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-jpa&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-jpa&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml123456789101112131415161718192021# MySqlspring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/user?useUnicode=true&amp;&amp;characterEncoding=utf-8 username: root password: 123456# Spring Data JPA jpa: hibernate: ddl-auto: update show-sql: true# Thymeleaf thymeleaf: cache: false mode: HTML encoding: UTF-8 servlet: content-type: text/html 实体类123456789101112131415161718192021222324252627package com.ronin.springbootjpa.entity;import lombok.Data;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.Id;import javax.persistence.Table;import java.io.Serializable;/** * @Author: 98 * @Date: 2019-8-22 21:59 */@Data@Entity@Table(name = \"tb_user\")public class User implements Serializable &#123; @Id @Column(name = \"id\") private Integer id; @Column(name = \"username\") private String username;&#125; Mapper123456789101112package com.ronin.springbootjpa.mapper;import com.ronin.springbootjpa.entity.User;import org.springframework.data.jpa.repository.JpaRepository;/** * @Author: 98 * @Date: 2019-8-22 22:31 * JpaRepository&lt;User 实体类 ,Integer 主键类型 &gt; */public interface UserMapper extends JpaRepository&lt;User,Integer&gt; &#123;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring Boot热部署","slug":"SpringBoot热部署","date":"2019-08-27T01:37:48.167Z","updated":"2019-08-27T01:38:54.404Z","comments":true,"path":"2019/08/27/SpringBoot热部署/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringBoot热部署/","excerpt":"","text":"目前的Springboot，当发生了任何修改之后，必须关闭后再启动Application类才能够生效，显得略微麻烦。 Springboot提供了热部署的方式，当发现任何类发生了改变，马上通过JVM类加载的方式，加载最新的类到虚拟机中。这样就能够实现项目的热部署运行，修改少量的代码不需要重启项目就能看到效果 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.ronin&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-tools&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-tools&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 热部署插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring Boot整合Thymeleaf模板引擎","slug":"SpringBoot整合Thymeleaf","date":"2019-08-27T01:13:35.725Z","updated":"2019-08-27T01:25:33.257Z","comments":true,"path":"2019/08/27/SpringBoot整合Thymeleaf/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringBoot整合Thymeleaf/","excerpt":"","text":"首先要了解一下什么是 Thymeleaf ！ Thymeleaf 官网：https://www.thymeleaf.org/ Thymeleaf 是 Web 和独立环境的现代服务器端 Java 模板引擎，能够处理HTML，XML，JavaScript，CSS 甚至纯文本。 Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。 Thymeleaf 的主要目标是提供一种优雅和高度可维护的创建模板的方式，在有网络和无网络的环境下皆可运行。为了实现这一点，它建立在自然模板的概念上，将其逻辑注入到模板文件中，不会影响模板被用作设计原型。这改善了设计的沟通，弥补了设计和开发团队之间的差距。 Thymeleaf 也从一开始就设计了Web标准 - 特别是 HTML5 - 允许您创建完全验证的模板，Spring Boot 官方推荐使用 thymeleaf 而不是 JSP。 pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ronin&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-thymeleaf&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;spring-boot-thymeleaf&lt;/name&gt; &lt;description&gt;&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt; &lt;artifactId&gt;nekohtml&lt;/artifactId&gt; &lt;version&gt;1.9.22&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml12345678spring: thymeleaf: #关闭页面缓存 cache: false mode: HTML encoding: UTF-8 servlet: content-type: text/html HTML页面12345678910&lt;!DOCTYPE html SYSTEM &quot;http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-spring4-4.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Hello Thymeleaf&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring Boot入门案例","slug":"SpringBoot入门案例","date":"2019-08-27T00:53:34.733Z","updated":"2019-08-27T01:00:22.132Z","comments":true,"path":"2019/08/27/SpringBoot入门案例/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringBoot入门案例/","excerpt":"","text":"SpringBoot 随着动态语言的流行，为解决 java 开发繁重的配置，低下的开发效率，复杂的部署以及第三方技术集成难度大而诞生。它使用习惯优于配置的理念能够让项目快速的运行，相较于传统的ssm、ssh项目而言，少了许多麻烦的配置文件。 SpringBoot 可以以jar包的方式独立运行，并且在其内部内嵌了 tomcat、jetty 等容器，无须以 war 包形式部署项目。提供了一系列的 starter pom 来简化 Maven 的依赖加载。 IDEA 搭建 SpringBoot 项目 File =&gt; New =&gt; Project 这里选择 Spring Initializr 填写项目有关信息 选择 SpringBoot 提供的 starter 依赖，根据项目需要勾选 项目存放路径 这样一个 SpringBoot 项目就创建成功了，默认的 SpringBoot 项目目录如下，跟 Maven 项目类似： SpringbootDemoApplicaiton ： 整个项目的启动类，通过运行其中的 main 方法快速启动项目 application.properties ：整个项目的配置文件，SpringBoot基于习惯优于配置理念，相较ssm等项目少了许多配置，除了可以使用properties格式，也可以使用 YAML 格式 templates ：项目默认的页面存放文件夹 static ：项目默认静态资源存放文件夹 默认的 pom.xml 文件12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;com.ronin&lt;/groupId&gt; &lt;artifactId&gt;springboot-demo&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; SpringBoot 项目都需要添加一个父级依赖，spring-boot-starter-parent 是一个特殊的 starter，是 spring 官方提供的，里面包含了众多第三方技术的jar包 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt; SpringBoot 的编译插件 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"SpringMVC文件上传","slug":"SpringMVC文件上传","date":"2019-08-27T00:46:26.673Z","updated":"2019-08-27T00:47:21.150Z","comments":true,"path":"2019/08/27/SpringMVC文件上传/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringMVC文件上传/","excerpt":"","text":"SpringMVC 为上传文件提供了良好的支持，SpringMVC 通过 MultipartResolver (Multipart 解析器) 处理的，它是一个接口，有两个实现类:​ CommonsMultipartResolver：依赖于 Apache 下的 jakarta Common FileUpload 项目解析 Multipart 请求，可以在 Spring 的各个版本中使用，只是它要依赖于第三方包才得以实现 StandardServletMultipartResolver：Spring 3.1 版本后的产物，它依赖于 Servlet 3.0 或者更高版本的实现，它不用依赖第三包 前台页面提交表单时，需要设置 enctype=”multipart/form-data” 多段式提交 12345678&lt;form class=\"form-horizontal form-border\" action=\"/upload\" method=\"post\" id=\"form\" enctype=\"multipart/form-data\"&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"col-sm-2\"&gt;&lt;/div&gt; &lt;div class=\"col-sm-8\"&gt; &lt;input type=\"file\" name=\"dropzFile\"/&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; SpringMVC.xml12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd\"&gt; &lt;!-- 上传文件拦截，设置最大上传文件大小 10M = 10*1024*1024(B) = 10485760 bytes --&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"maxUploadSize\" value=\"10485760\"/&gt; &lt;property name=\"defaultEncoding\" value=\"utf-8\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 后台代码12345678910111213141516171819202122232425262728293031/** * 文件上传 * @param dropzFile * @return */ @RequestMapping(value = \"upload\",method = RequestMethod.POST) public Map&lt;String,Object&gt; DropZone(MultipartFile dropzFile,HttpServletRequest request)&#123; //获取文件名 String fileName = dropzFile.getOriginalFilename(); //获取文件后缀名 String fileSuffix = fileName.substring(fileName.lastIndexOf(\".\")); //获取文件上传文件夹路径 String filePath = request.getSession().getServletContext().getRealPath(Const.UPLOAD_PATH); //判断文件夹是否存在,不存在就创建文件夹 File file = new File(filePath); if(! file.exists())&#123; file.mkdirs(); &#125; //UUID替换文件名 String filePrefix = UUID.randomUUID().toString(); file = new File(filePath,filePrefix+fileSuffix); //上传文件 try &#123; dropzFile.transferTo(file); &#125; catch (IOException e) &#123; logger.error(\"文件上传出错！！！\"); &#125; return \"index\"; &#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"SpringMVC拦截器","slug":"SpringMVC拦截器","date":"2019-08-27T00:45:35.201Z","updated":"2019-08-27T00:46:21.936Z","comments":true,"path":"2019/08/27/SpringMVC拦截器/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringMVC拦截器/","excerpt":"","text":"拦截器是 SpringMVC 中一个强大的控件，它可以在进入处理器之前做一些操作，或者在处理器完成后进行操作，甚至是在渲染视图后进行操作。我们可以自己定义一个拦截器，Spring 要求处理器的拦截器都需要实现 org.springframework.web.servlet.HandlerInterceptor 接口，我们来看看该接口的源码： 12345678910111213141516public interface HandlerInterceptor &#123; default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true; &#125; default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123; &#125; default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123; &#125;&#125; HandlerInterceptor 接口中定义了三个方法： preHandle 方法：在处理器之前执行的前置方法，SpringMVC 可以在进入处理器之前处理一些方法，方法默认返回一个 Boolean 值，true 代表放行，false 代表拦截 postHandle 方法：在处理器之后执行的后置方法，处理器的逻辑完成后运行它 afterCompletion 方法：无论是否产生异常都会在渲染视图后执行的方法 拦截器的定义SpringMVC 配置拦截器有两种方式，一种是xml配置，一种是java配置，Spring4之后推荐使用java配置 xml配置 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.5.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.5.xsd \"&gt; &lt;!--配置拦截器, 多个拦截器,顺序执行 --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- /**的意思是所有文件夹及里面的子文件夹 /*是所有文件夹，不含子文件夹 /是web项目的根目录 --&gt; &lt;mvc:mapping path=\"/**\" /&gt; &lt;!-- 需排除拦截的地址 --&gt; &lt;!-- &lt;mvc:exclude-mapping path=\"/userController/login\"/&gt; --&gt; &lt;bean id=\"ManagerInterceptor\" class=\"com.mall.Interceptor.ManagerInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/admin/details\"/&gt; &lt;bean id=\"OrderInterceptor\" class=\"com.mall.Interceptor.OrderInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/shop/personal\"/&gt; &lt;bean id=\"UserInterceptor\" class=\"com.mall.Interceptor.UserInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;&lt;/beans&gt; 这里的 xml 配置中是配置了三个拦截器，bean 节点中的 class 属性值为对应的拦截器全类包路径 java配置 定义一个拦截器实现 HandleInterceptor 接口 123456789101112131415161718192021/** * @Author: 98 * @Date: 2019-8-1 16:41 */public class WebAdminInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 创建一个java类，类上使用 @Configuration 表明这是个配置类 12345678910111213141516171819/** 1. @Author: 98 2. @Date: 2019-8-1 16:52 */@Configurationpublic class InterceptorConfig implements WebMvcConfigurer &#123; @Bean WebAdminInterceptor webAdminInterceptor()&#123; return new WebAdminInterceptor(); &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(webAdminInterceptor()) .addPathPatterns(\"/**\") .excludePathPatterns(\"/static\"); &#125;&#125; 拦截器的执行顺序拦截器的执行顺序可以分成多种情况： 单个拦截器 执行的顺序为：preHandle =&gt; postHandle =&gt; afterCompletion （前提 preHandle 方法返回true） 多个拦截器，preHandle 方法均返回 true 执行的顺序为： preHandle1preHandle2preHandle3 postHandle3postHandle2postHandle1 afterCompletion3afterCompletion2afterCompletion1 多个拦截器，其中一个或多个拦截器 preHandle 方法返回false，这里我们设置三个拦截器，将第二个拦截器的前置方法返回false preHandle1preHandle2afterCompletion1 当其中的一个 preHandle 方法返回为false后，按照配置的顺序，后面的 preHandle 方法都不会运行，而控制器和所有的后置方法 postHandle 也不会再运行。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"SpringMVC执行流程","slug":"SpringMVC执行流程","date":"2019-08-27T00:43:17.470Z","updated":"2019-08-27T00:45:24.850Z","comments":true,"path":"2019/08/27/SpringMVC执行流程/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringMVC执行流程/","excerpt":"","text":"SpringMVC请求流程SpringMVC中处理请求最为重要的组件就是：DispatcherServlet，在处理用户请求时，SpringMVC底层的请求流程如下图： 用户端发起请求到后台服务器，请求被前端控制器（DispatcherServlet）拦截 前端控制器拦截到请求后，将请求信息交给处理器映射器（HandlerMapping）查找Handler 处理器映射器向前端控制器返回处理器（Handler） 前端控制器得到处理器后调用处理器适配器（HandlerAdapter）执行Handler 处理器适配器执行Handler Handler根据路径找到对应的Controller方法执行完成后给适配器返回模型和视图对象（ModelAndView） 处理器适配器向前端控制器返回ModelAndView 前端控制器请求视图解析器（ViewResolver）进行视图解析 视图解析器向前端控制器返回view 前端控制器进行视图渲染 前端控制器向用户响应结果 组件说明每一次用户端请求SpringMVC都会执行一遍这样的流程，在这一流程中存在几个SpringMVC中重要的组件： DispatcherServlet （前端控制器） 用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。 HandlerMapping （处理器映射器） HandlerMapping负责根据用户请求url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 HandlerAdapter （处理器适配器） 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 ViewResolver （视图解析器） View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"SpringMVC入门案例","slug":"SpringMVC入门案例","date":"2019-08-27T00:42:09.463Z","updated":"2019-08-27T00:42:53.670Z","comments":true,"path":"2019/08/27/SpringMVC入门案例/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringMVC入门案例/","excerpt":"","text":"web.xml配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app version=\"3.0\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"&gt; &lt;!-- Spring配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/spring/spring-config*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Spring监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 字符集过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;Encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;Encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 配置系统变量 contextConfigLocation，SpringMVC会根据配置的路径加载配置文件 ContextLoaderListener 实现了接口 ServletContextListener，监听项目启动，用于Spring IoC容器初始化 配置 DispatcherServlet 我们给了一个 contextConfigLocation，SpringMVC会到这个路径下读取配置文件，如果不配置这个属性，SpringMVC会默认读取 /WEB-INF/dispatcher-servlet.xml 文件，没读取到会抛出异常 DispatcherServlet 拦截请求的后缀有多种方式：1. *.do 2. *.action 3. / 4. / * springmvc.xml12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.5.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.5.xsd\"&gt; &lt;!-- 扫描注解 --&gt; &lt;context:component-scan base-package=\"com.ronin.blog.controller\"/&gt; &lt;!-- 配置注解驱动 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 静态资源放行 --&gt; &lt;mvc:resources mapping=\"/static/**\" location=\"/static/\" /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 视图解析器中配置返回视图的前缀和后缀，SpringMVC根据返回的值拼接后到对应的路径下查找 Controller完成了配置文件的书写，在 /WEB-INF/jsp/ 路径下创建一个 index.jsp 页面 12345678910111213141516@Controllerpublic class ArticleController &#123; /** * 页面跳转 * @return */ @RequestMapping(value = \"index\",method = RequestMethod.GET) public ModelAndView index()&#123; //创建模型视图对象 ModelAndView mav = new ModelAndView(); //添加视图 mav.setViewName(\"index\"); //返回模型和视图 return mav; &#125;&#125; 启动项目，访问对应的请求路径，实现页面跳转！","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"SpringMVC","slug":"SpringMVC","date":"2019-08-27T00:40:35.905Z","updated":"2019-08-27T00:41:51.973Z","comments":true,"path":"2019/08/27/SpringMVC/","link":"","permalink":"http://yoursite.com/2019/08/27/SpringMVC/","excerpt":"","text":"Spring Web MVC是基于Servlet API构建的原始Web框架，从一开始就包含在Spring Framework中。正式名称“Spring Web MVC”来自其源模块（spring-webmvc）的名称，但它通常被称为“Spring MVC”。 与Spring Web MVC并行，Spring Framework 5.0引入了一个反应堆栈Web框架，其名称“Spring WebFlux”也基于其源模块（spring-webflux）。 MVC设计概述MVC 设计不仅限于 Java Web 应用，设计的根本原因在于解耦各个模块，早期的 Java Web 开发中，主要是 JSP+Java Bean 模式，我们称之为 Model1 时代。可以很容易看出，Model1时代中 JSP 和 Java Bean 之间的耦合十分严重，Java 和 Html 也耦合在一起，很快 Model1 时代就被 Servlet+JSP+Java Bean 替代了。相对于 Model1 多了一个 Servlet 组件，Servlet 组件作为主要的控制器，用来处理浏览器发来的请求，这样的模式就成为 MVC 模式，Servlet 为控制层（Controller），JSP 为视图层（view），Java Bean 为模型层（Modal）。 SpringMVC 架构为解决持久层中一直未处理好的数据库事务的编程，又为了迎合 NoSQL 的强势崛起，Spring MVC 给出了方案：传统的模型层被拆分为了业务层(Service)和数据访问层（DAO,Data Access Object）。 在 Service 下可以通过 Spring 的声明式事务操作数据访问层，而在业务层上还允许我们访问 NoSQL ，这样就能够满足异军突起的 NoSQL 的使用了，它可以大大提高互联网系统的性能。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring事务","slug":"Spring事务","date":"2019-07-21T10:14:26.844Z","updated":"2019-07-21T10:15:04.718Z","comments":true,"path":"2019/07/21/Spring事务/","link":"","permalink":"http://yoursite.com/2019/07/21/Spring事务/","excerpt":"","text":"事务是指逻辑上的一组操作，这组操作要么全部成功，要么就一同失败。 事务的四大特性： 原子性：事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都失败； 隔离性：当多个用户并发访问数据库时，数据库为每一个用户开启的事务，不被其他事务的操作所干扰，多个并发事务之间要相互隔离； 一致性：事务操作前后数据必须处于一致状态； 持久性：一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便在数据库系统遇到故障的情况下也不会丢失事物的操作。 Spring事务的隔离级别事务隔离级别，就是为了解决上面几种问题而诞生的。为什么要有事务隔离级别，因为事务隔离级别越高，在并发下会产生的问题就越少，但同时付出的性能消耗也将越大，因此很多时候必须在并发性和性能之间做一个权衡。所以设立了几种事务隔离级别，以便让不同的项目可以根据自己项目的并发情况选择合适的事务隔离级别，对于在事务隔离级别之外会产生的并发问题，在代码中做补偿。 事务隔离级别有4种，但是Spring会提供给用户5种: DEFAULT 默认隔离级别，每种数据库支持的事务隔离级别不一样，如果Spring配置事务时将isolation设置为这个值的话，那么将使用底层数据库的默认事务隔离级别。顺便说一句，如果使用的MySQL，可以使用”select @@tx_isolation”来查看默认的事务隔离级别 READ_UNCOMMITTED 读未提交，即能够读取到没有被提交的数据，所以很明显这个级别的隔离机制无法解决脏读、不可重复读、幻读中的任何一种，因此很少使用 READ_COMMITED 读已提交，即能够读到那些已经提交的数据，自然能够防止脏读，但是无法限制不可重复读和幻读 REPEATABLE_READ 重复读取，即在数据读出来之后加锁，类似”select * from XXX for update”，明确数据读取出来就是为了更新用的，所以要加一把锁，防止别人修改它。REPEATABLE_READ的意思也类似，读取了一条数据，这个事务不结束，别的事务就不可以改这条记录，这样就解决了脏读、不可重复读的问题，但是幻读的问题还是无法解决 SERLALIZABLE 串行化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务，这样就解决了脏读、不可重复读和幻读的问题了 Spring事务传播行为 传播行为 含义 备注 REQUIRED 当方法调用时，如果不存在当前事务，那么就创建事务；如果当前方法已经存在事务，就沿用之前的事务 这个是Spring默认的传播行为 SUPPORTS 当方法调用时，如果不存在当前事务，那么就不启用事务；如果当前方法已经存在事务，就沿用之前的事务 - MANDATORY 方法必须在事务内运行 如果不存在当前事务，抛出异常 REQUIRES_NEW 无论是否存在当前事务，方法都会在新的事务中运行 事务管理器会打开新的事务运行该方法 NOT_SUPPORTED 不支持事务，如果不存在当前事务也不会创建事务；如果存在当前事务就挂起它，知道方法结束后才恢复当前事务 适用于不需要事务的SQL NEVER 不支持事务，只有在没有事务的环境中才能运行它 如果方法存在当前事务，抛出异常 NESTED 嵌套事务，调用方法如果抛出异常只回滚自己内部执行的SQL，而不回滚主方法的SQL 它的实现存在两种情况，如果当前数据库支持保存点，它就会在当前事务上使用保存点技术；如果发生异常则将方法内执行的SQL回滚到保存点上，不是全部回滚，否则就等同于REQUIRES_NEW创建新的事务运行方法代码 XML配置事务1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 配置数据源 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;&lt;/bean&gt;&lt;!-- 配置事务 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt; &lt;!-- 配置事务通知 --&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 以方法为单位,指定方法应用什么事务属性 isolation:隔离级别 propagation:传播行为 read-only:是否只读 --&gt; &lt;tx:method name=&quot;save*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt; &lt;tx:method name=&quot;persist*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt; &lt;tx:method name=&quot;update*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt; &lt;tx:method name=&quot;modify*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt; &lt;tx:method name=&quot;delete*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt; &lt;tx:method name=&quot;remove*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt; &lt;tx:method name=&quot;get*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;find*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;transfer&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 配置织入 --&gt;&lt;aop:config&gt; &lt;!-- 配置切点 --&gt; &lt;aop:pointcut expression=&quot;execution(* service.*ServiceImpl.*(..))&quot; id=&quot;txPc&quot;/&gt; &lt;!-- 配置切面：通知+切点 --&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPc&quot;/&gt;&lt;/aop:config&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring 整合 MyBatis","slug":"Spring 整合 MyBatis","date":"2019-07-21T10:12:18.183Z","updated":"2019-07-21T10:14:17.707Z","comments":true,"path":"2019/07/21/Spring 整合 MyBatis/","link":"","permalink":"http://yoursite.com/2019/07/21/Spring 整合 MyBatis/","excerpt":"","text":"Spring配置文件spring-config-druid.xml 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd\"&gt; &lt;!-- 配置文件 --&gt; &lt;context:property-placeholder location=\"classpath:config/jdbc.properties\"/&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/bean&gt;&lt;/beans&gt; spring-config-mybatis.xml 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd\"&gt; &lt;!-- SqlSessionFactory --&gt; &lt;bean id=\"SqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!-- SqlMapConfig文件 --&gt; &lt;property name=\"configLocation\" value=\"classpath:config/sqlMapConfig.xml\"/&gt; &lt;!-- 映射文件 --&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"/&gt; &lt;!-- 设置别名 --&gt; &lt;property name=\"typeAliasesPackage\" value=\" 实体类全路径包名 \"/&gt; &lt;/bean&gt; &lt;!-- 扫描Mapper --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\" Mapper映射文件全包名 \"/&gt; &lt;/bean&gt;&lt;/beans&gt; sqlMapConfig.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 全局参数 --&gt; &lt;settings&gt; &lt;!-- 打印 SQL 语句 --&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\" /&gt; &lt;!-- 使全局的映射器启用或禁用缓存。 --&gt; &lt;setting name=\"cacheEnabled\" value=\"false\"/&gt; &lt;!-- 全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载。 --&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!-- 当启用时，有延迟加载属性的对象在被调用时将会完全加载任意属性。否则，每种属性将会按需要加载。 --&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"true\"/&gt; &lt;!-- 是否允许单条 SQL 返回多个数据集 (取决于驱动的兼容性) default:true --&gt; &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt; &lt;!-- 是否可以使用列的别名 (取决于驱动的兼容性) default:true --&gt; &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt; &lt;!-- 允许 JDBC 生成主键。需要驱动器支持。如果设为了 true，这个设置将强制使用被生成的主键，有一些驱动器不兼容不过仍然可以执行。 default:false --&gt; &lt;setting name=\"useGeneratedKeys\" value=\"false\"/&gt; &lt;!-- 指定 MyBatis 如何自动映射 数据基表的列 NONE：不映射 PARTIAL：部分 FULL:全部 --&gt; &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt; &lt;!-- 这是默认的执行类型 （SIMPLE: 简单； REUSE: 执行器可能重复使用prepared statements语句；BATCH: 执行器可以重复执行语句和批量更新） --&gt; &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/&gt; &lt;!-- 使用驼峰命名法转换字段。 --&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;!-- 设置本地缓存范围 session:就会有数据的共享 statement:语句范围 (这样就不会有数据的共享 ) defalut:session --&gt; &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt; &lt;!-- 设置 JDBC 类型为空时,某些驱动程序 要指定值, default:OTHER，插入空值时不需要指定类型 --&gt; &lt;setting name=\"jdbcTypeForNull\" value=\"NULL\"/&gt; &lt;/settings&gt; &lt;/configuration&gt; web.xml 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!-- Spring配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/spring/spring-config*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Spring监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring JdbcTemplate","slug":"Spring JdbcTemplate","date":"2019-07-21T10:11:23.968Z","updated":"2019-07-21T10:11:50.332Z","comments":true,"path":"2019/07/21/Spring JdbcTemplate/","link":"","permalink":"http://yoursite.com/2019/07/21/Spring JdbcTemplate/","excerpt":"","text":"JdbcTemplate是Spring框架自带的对JDBC操作的封装，目的是提供统一的模板方法使对数据库的操作更加方便、友好，效率也不错。但是功能还是不够强大（比如不支持级联属性），在实际应用中还需要和hibernate、mybaties等框架混合使用。 传统JDBC弊端传统的 JDBC 即使是执行一条简单的 SQL 过程都不简单，先是打开数据库连接执行 SQL，组装结果，最后关闭资源，其中包含了太多的 try…catch…finally… 语句，造成代码泛滥，数据库资源的打开、关闭都是定性的，事务提交回滚等等都是比较固定的模式，导致代码的可读性和可维护性急剧降低。 JdbcTemplate配置数据库连接配置文件,db.properties 1234jdbc.username=rootjdbc.password=123456jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/test XML配置，第三方连接池使用阿里巴巴的 Druid 123456789101112131415&lt;!-- 配置文件 --&gt;&lt;context:property-placeholder location=&quot;classpath:config/jdbc.properties&quot;/&gt;&lt;!-- 数据库连接池 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt;&lt;!-- 配置JdbcTemplate实例 --&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt; 测试方法 1234567//启动IoC容器ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);//获取IoC容器中JdbcTemplate实例JdbcTemplate jdbcTemplate=(JdbcTemplate) ctx.getBean(&quot;jdbcTemplate&quot;);String sql=&quot;insert into user (name,age) values (?,?)&quot;;int count= jdbcTemplate.update(sql, new Object[]&#123;&quot;tom&quot;,3&#125;);System.out.println(count); JdbcTemplate的增删改查12345678910111213141516public static void main(String[] args)&#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取IoC容器中JdbcTemplate实例 JdbcTemplate jdbcTemplate=(JdbcTemplate) ctx.getBean(&quot;jdbcTemplate&quot;); JdbcTemplate test = new JdbcTemplate(); //实例化对象 User user = new User(); user.setId(1L); user.setName(&quot;tom&quot;); user.setAge(20); //执行操作 test.insertUser(jdbcTemplate,user); List&lt;User&gt; UserList = test.findUser(jdbcTemplate); test.updateUser(jdbcTemplate,user); test.deleteUser(1L);&#125; 1234567/** ** 插入方法**/public int insertUser(JdbcTemplate jdbcTemplate,User user)&#123; String sql = &quot;insert into t_user(id,name,age) values(?,?,?)&quot;; return jdbcTemplate.update(sql,user.getId(),user.getName(),user.getAge());&#125; 1234567/** ** 删除方法**/public int deletetUser(JdbcTemplate jdbcTemplate,Long id)&#123; String sql = &quot;delete from t_user where id = ?&quot;; return jdbcTemplate.update(sql,id);&#125; 1234567/** ** 更新方法**/public int updateUser(JdbcTemplate jdbcTemplate,User user)&#123; String sql = &quot;update t_user set name = ?,age = ? where id = ?&quot;; return jdbcTemplate.update(sql,user.getName(),user.getAge(),user.getId());&#125; 123456789101112/** ** 查询用户列表**/public List&lt;User&gt; findUser(JdbcTemplate jdbcTemplate,User user)&#123; String sql = &quot;select * from t_user&quot;; RowMapper&lt;User&gt; rowMapper = new BeanPropertyRowMapper&lt;User&gt;(User.class); List&lt;User&gt; list= jdbcTemplate.query(sql, rowMapper); for (User user : list) &#123; System.out.println(user); &#125; return list;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring AOP","slug":"Spring AOP","date":"2019-07-21T10:10:43.034Z","updated":"2019-07-21T10:11:08.397Z","comments":true,"path":"2019/07/21/Spring AOP/","link":"","permalink":"http://yoursite.com/2019/07/21/Spring AOP/","excerpt":"","text":"AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 AOP 技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。 AOP 使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 AOP术语 切面（Aspect）类是对物体特征的抽象，切面就是对横切关注点的抽象，例如数据库的事务贯穿了整个代码层面，这就是一个切面，它可以定义后面需要的各类通知、切点和引入内容。 通知（Advice）通知是切面开启后，切面的方法。它根据在代理对象真实方法调用前后的顺序和逻辑区分。前置通知（before）：在动态代理反射原有对象方法或者执行环绕通知前执行的通知功能。后置通知（after）：在动态代理反射原有对象方法或者执行环绕通知后执行的通知功能。不论是否抛出异常都会执行。返回通知（afterReturning）：在动态代理反射原有对象方法或者执行环绕通知后正常返回（无异常）执行的通知功能。异常通知（afterThrowing）：在动态代理反射原有对象方法或者执行环绕通知产生异常后执行的通知功能。环绕通知（around）：在动态代理中，它可以取代当前被拦截对象的方法，提供回调原有被拦截对象的方法。 引入（Introduction）引入允许我们在现有的类里添加自定义的类和方法。 切点（Pointcut）这是一个告诉 Spring AOP 在什么时候启动拦截并织入对应的流程中，因为并不是所有的开发都需要启动 AOP，它往往通过切点表达式进行限定。 连接点（Join point）连接点对应的是具体需要拦截的东西，比如通过切点的切点表达式去判断哪个方法是连接点，从而织入对应的通知。 织入（Weaving）织入是一个生成代理对象并将切面内容放入到流程中的过程。实际代理的方法分为动态代理和静态代理。 XML配置开发Spring AOPSpring 提供了两种方式配置 AOP，注解配置和XML文件配置，在这我们只介绍XML文件配置方式。| AOP配置元素 | 用途 | 备注 || ——————- | ——————————– | —————————- || aop:advisor | 定义AOP的通知器 | 一种较老的方式，目前很少使用 || aop:aspect | 定义一个切面 | / || aop:before | 定义前置通知 | / || aop:after | 定义后置通知 | / || aop:around | 定义环绕方式 | / || aop:after-returning | 定义返回通知 | / || aop:after-throwing | 定义异常通知 | / || aop:config | 顶层的AOP配置元素 | AOP的配置根节点 || aop:declare-parents | 给通知引入新的额外接口，增强功能 | / || aop:pointcut | 定义切点 | / | 简单的 AOP 案例：定义接口 1234public interface PhoneService&#123; public void call(); public void send_sms();&#125; 实现类 12345678public class PhoneServiceImpl&#123; public void call()&#123; System.out.println(&quot;***打电话&quot;); &#125; public void send_sms()&#123; System.out.println(&quot;***发短信&quot;); &#125;&#125; 通知类 12345678pulbic class MyAdvice&#123; public void beforeLog()&#123; System.out.println(“准备执行移动业务======”); &#125; public void afterLog()&#123; System.out.println(&quot;本次业务需要10元======&quot;); &#125;&#125; XML配置 1234567891011&lt;bean id=&quot;phone&quot; class=&quot;com.etc.service.impl.PhoneServiceImpl&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;myAdvice&quot; class=&quot;com.etc.common.MyAdvice&quot;&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;!—配置切点，即需要将方法织入的位置--&gt; &lt;aop:pointcut id=&quot;pc&quot; expression=“execution(* com.etc.service.impl.PhoneServiceImpl.*(...))”/&gt; &lt;!—配置切面feeAdvice是Bean的id --&gt; &lt;aop:aspect ref=&quot;myAdvice&quot;&gt; &lt;aop:before method=&quot;beforLog&quot; pointcut-ref=&quot;pc&quot;/&gt; &lt;aop:after method=&quot;afterLog&quot; pointcut-ref=&quot;pc&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; &lt; aop:aspect &gt;：用于定义切面类&lt; aop:before &gt;：定义前置通知&lt; aop:after &gt;：定义后置通知&lt; aop:after-throwing &gt;：定义异常通知&lt; aop:after-retruning &gt;：定义返回通知","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring 装配 Bean","slug":"Spring 装配 Bean","date":"2019-07-21T10:10:04.129Z","updated":"2019-07-21T10:10:32.562Z","comments":true,"path":"2019/07/21/Spring 装配 Bean/","link":"","permalink":"http://yoursite.com/2019/07/21/Spring 装配 Bean/","excerpt":"","text":"如何将自己开发的 Bean 装配到 Spring IOC 容器中，大部分情况下我们可以使用 ApplicationContext 的具体实现类，因为对应的 Spring IOC 容器功能强大，在 Spring 当中提供了3中方式进行配置： XML配置 Java的接口和类中实现配置 隐式Bean的发现机制和自动装配原则 XML配置Bean12345678910&lt;bean id=&quot;source&quot; class=&quot;com.ssm.entity.Source&quot;&gt; &lt;property name=&quot;fruit&quot; value=&quot;橙汁&quot;/&gt; &lt;property name=&quot;sugar&quot; value=&quot;少糖&quot;/&gt; &lt;property name=&quot;size&quot; value=&quot;大杯&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;juiceMaker&quot; class=&quot;com.ssm.entity.JuiceMaker&quot;&gt; &lt;property name=&quot;beverageShop&quot; value=&quot;贡茶&quot;/&gt; &lt;property name=&quot;source&quot; ref=&quot;source&quot;/&gt;&lt;/bean&gt; id 属性是 Spring 找到这个 Bean 的编号，id 不是必须的属性，如果没有声明 id，Spring 会采用“全限类名#{number}”的格式生成编号。class 是一个类的全限定名。property 元素是定义类的属性，name 属性定义属性名称，value 定义值。ref 属性是引用对应的 Bean 的 id。 注解配置Bean在 Spring3.0 之后已经不再推荐使用 XML 的方式装配 Bean，更多时候推荐使用注解配置，使用注解可以大量减少 XML 的配置代码，注解既能实现 XML 的功能，也提供了自动装配的功能，满足了“约定优于配置”的开发原则。 Spring 中提供了两种方式让 Spring IOC 容器发现 Bean： 组件扫描：通过定义资源的方式，让 Spring IOC 容器扫描对应的包，从而把 Bean 装配进来。 自动装配：通过注解定义，使得一些依赖关系可以通过注解完成。 @Component12345678@Component(value=&quot;user&quot;)public class User&#123; @Value(&quot;1&quot;) private Long id; @Value(&quot;user_name&quot;) private String userName; ................&#125; @Component 注解代表 Spring IOC 会把这个类扫描生成 Bean 实例，其中 value 属性的值等同于 XML 方式中的 id，value 值不写 Spring IOC 容器就默认首字母为小写的类名替代。@Value 代表的是值的注入。 123@ComponentScanpublic class PojoConfig&#123;&#125; 这时候需要在同一个包下创建一个 Java Config 告诉 Spring IOC 容器到哪里去扫描对象，@ComponentScan 代表进行扫描，默认是扫描当前包下的路径。它有两个配置选项，第一个是 basePackages，第二个是 basePackageClasses。 @Autowired在 Spring IOC 容器中，Spring 是先完成 Bean 的定义和生成，然后寻找需要注入的资源，当 Spring 生成所有的 Bean 后，如果发现了这个注解，它就会在 Bean 中查找对应的类型注入。 123public interface UserService&#123; public void UserInfo();&#125; 1234567@Controllerpublic class UserController&#123; @Autowired private UserService userService; ...................&#125; 这里我们定义一个 User 的接口，在 Controller 层通过 @Autowired 注解注入，Spring 在扫描到这个注解后会自动寻找对应的类型注入。 有时，IOC 容器会寻找类型失败，默认情况会抛出异常，可以通过 @Autowired(required = false) 将其设置为不一定成功注入，当 IOC 容器没有找到对应的类型时，不会抛出异常。 在少部分情况下，一个接口会有多个实现类，使用 @Autowired 自动装配时可能会出现 IOC 容器不知道使用哪个实现类装配的问题，导致注入失败，原因是 IOC 容器通过类型（by type）获取 Bean，多个实现类导致 Bean 不唯一，可以通过 @Primary（首要注入）注解和 @Qualifier（采用名称查找）注解解决这类问题。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring 依赖注入（DI）","slug":"Spring 依赖注入（DI）","date":"2019-07-21T10:09:24.955Z","updated":"2019-07-21T10:09:54.535Z","comments":true,"path":"2019/07/21/Spring 依赖注入（DI）/","link":"","permalink":"http://yoursite.com/2019/07/21/Spring 依赖注入（DI）/","excerpt":"","text":"在实际环境中实现 IOC 容器的方式主要分为两大类，一类是依赖查找，依赖查找是通过资源定位，把对应的资源查找回来；另一类是依赖注入，Spring 主要使用的是依赖注入。一般，依赖注入可以分为三种方式： 构造器注入 setter 注入 接口注入 构造器注入和 setter 注入是主要的方式，而接口注入是从别的地方注入的方式，例如web工程中配置的数据源是通过服务器配置的，可以通过 JNDI 的形式通过接口将它注入 Spring IOC 容器中。 构造器注入构造器注入依赖于构造方法实现，构造方法可以是有参数的或者是无参数的。大部分情况下我们是通过类的构造方法创建类对象，Spring 可以采用反射的方式，通过使用构造方法来完成注入，这就是构造器注入的原理。 构造器注入代码： 12345678910public class User&#123; private int id; private String name; private String note; ............................... public User(String name,String note)&#123; this.name = name; this.note = note; &#125;&#125; 1234&lt;bean id=&quot;user&quot; class=&quot;com.ssm.entity.User&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;总经理&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;管理者&quot;/&gt;&lt;/bean&gt; constructor-arg 元素用于定义类构造方法的参数，其中 index 用于定义参数的位置，value 是设置值。 构造器注入比较简单，但是缺点也很明显，参数少时可读性比较好，当参数量较多时，构造器注入就比较复杂，代码维护难。 setter 注入setter 注入时 Spring 中最主流的注入方式，它利用 Java Bean 规范定义的 setter 方法完成注入，灵活并且代码可读性高，它消除了使用构造器注入时参数过多的麻烦，通过 setter 注入为其设置的值，其实也是通过 Java 的反射技术实现的。 1234&lt;bean id=&quot;user&quot; class=&quot;com.ssm.entity.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;工程师&quot;/&gt; &lt;property name=&quot;note&quot; value=&quot;重要人员&quot;/&gt;&lt;/bean&gt; Spring 会通过反射调用没有参数的构造方法生成对象，同时通过反射对应的 setter 方法注入配置的值，这种方式是 Spring 最为主要的方式，应用十分广泛。 接口注入有些时候资源是来自外界，比如数据库连接资源完全可以在 Tomcat 下配置，通过 JNDI 的形式去获取它，这样数据库链接资源是属于开发工程外的资源，这时就可以使用接口注入的形式获取它。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring IOC","slug":"Spring IOC","date":"2019-07-21T10:06:22.726Z","updated":"2019-07-21T10:09:01.507Z","comments":true,"path":"2019/07/21/Spring IOC/","link":"","permalink":"http://yoursite.com/2019/07/21/Spring IOC/","excerpt":"","text":"传统编码创建对象时，我们总是通过 new 方法主动创建对象，但是在现实中，一个复杂的系统面对着成千上百的对象，如果每一个对象都通过手动创建、维护，就会十分的复杂。更多时候，我们希望通过简单方法获得想要的对象，这就是被动创建对象。 被动创建对象，不需要程序员手动一个个 new 出对象，只需要给出想要对象的描述就可以得到对象。在Spring框架中，这样的效果可以通过 IOC 实现。 Spring IOCIOC又称控制反转，就是将对象的创建权利发生反转，从之前自己手动的创建对象，现在变成由Spring容器帮助创建生成新的对象，程序员无需关注对象的创建过程，无需关注对象的生命周期。 举个例子，当你想喝水果饮料时，有两种选择，第一种是自己买水果来榨汁喝，第二种是去饮料店点一杯水果饮料。第一种解决方法就类似于手动 new 出一个对象，第二种解决方法是通过第三方直接获取对象。 这个例子包含了控制反转的思想，由自己榨饮料转换成通过第三方得到饮料，将制造饮料的过程由自己反转给第三方，这就是控制反转。而在Spring中，实现控制反转的就是 IOC 容器，其实现方法是依赖注入（Dependency Injection,DI）。 IOC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，指导如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了 IOC 容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松耦合关系，使得程序的整个体系结构变得非常灵活。 其实 IOC 对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在 IOC/DI 思想中，应用程序就变成被动的了，被动的等待 IOC 容器来创建并注入它所需要的资源了。 Spring IOC 容器Spring IOC 容器的设计主要是基于 BeanFactory 和 ApplicationContext 两个接口，其中 ApplicationContext 是 BeanFactory 的子接口之一，BeanFactory 是 Spring IOC 容器所定义的最底层接口。ApplicationContext 是对 BeanFactory 功能做了更多扩展，在大部分场景下，都是使用 ApplicationContext 作为 Spring IOC 容器。 Spring IOC 容器初始化 BeanBean 的定义和初始化在 Spring IOC 容器中是两大步骤，Bean 的定义分为3步： Resource 定位，这步是 Spring IOC 容器根据开发者的配置，进行资源定位。 BeanDefinition 的载入，这个时候只是将 Resource 定位到的信息保存到 Bean 定义（BeanDefinition）中，此时不会创建 Bean 实例。 BeanDefinition 的注册，这个过程将 BeanDefinition 的信息发布到 Spring IOC 容器中，此时仍然没有创建 Bean 的实例。 做完这3步，Bean 在 Spring IOC 容器中就被定义了，但是没有被初始化，更没有完成依赖注入，这时它还不能完全使用，对于初始化和依赖注入，Spring Bean 还有一个配置——lazy-init（是否初始化 Spring Bean）。默认值为 default，实际值为 false，也就是 Spring IOC 默认自动初始化 Bean，如果设置为 true，就只有在使用 Spring IOC 容器的 getBean 方法获取时才会被初始化，完成依赖注入。 Spring Bean 生命周期图","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring","slug":"Spring","date":"2019-07-21T10:04:31.400Z","updated":"2019-07-21T10:15:24.364Z","comments":true,"path":"2019/07/21/Spring/","link":"","permalink":"http://yoursite.com/2019/07/21/Spring/","excerpt":"","text":"什么是SpringSpring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring的核心是控制反转（IOC）和面向切面（AOP）。 简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。 Spring起源要谈Spring的历史，就要先谈J2EE。J2EE应用程序的广泛实现是在1999年和2000年开始的，它的出现带来了诸如事务管理之类的核心中间层概念的标准化，但是在实践中并没有获得绝对的成功，因为开发效率，开发难度和实际的性能都令人失望。曾经使用过EJB开发JAVA EE应用的人，一定知道，在EJB开始的学习和应用非常的艰苦，很多东西都不能一下子就很容易的理解。EJB要严格地实现各种不同类型的接口，类似的或者重复的代码大量存在。而配置也是复杂和单调，同样使用JNDI进行对象查找的代码也是单调而枯燥。虽然有一些开发工作随着xdoclet的出现，而有所缓解，但是学习EJB的高昂代价，和极低的开发效率，极高的资源消耗，都造成了EJB的使用困难。而Spring出现的初衷就是为了解决类似的这些问题。 Spring的一个最大的目的就是使JAVA EE开发更加容易。同时，Spring之所以与Struts、Hibernate等单层框架不同，是因为Spring致力于提供一个以统一的、高效的方式构造整个应用，并且可以将单层框架以最佳的组合揉和在一起建立一个连贯的体系。可以说Spring是一个提供了更完善开发环境的一个框架，可以为POJO(Plain Ordinary Java Object)对象提供企业级的服务。Spring的形成，最初来自Rod Jahnson所著的一本很有影响力的书籍《Expert One-on-One J2EE Design and Development》，就是在这本书中第一次出现了Spring的一些核心思想，该书出版于2002年。另外一本书《Expert One-on-One J2EE Development without EJB》，更进一步阐述了在不使用EJB开发JAVA EE企业级应用的一些设计思想和具体的做法。 Spring优点 容易解耦，简化开发 通过Spring提供的IoC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。有了Spring，用户不必再为单实例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。 支持AOP（面向切面编程） 通过Spring提供的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。 支持事务 在Spring中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。 程序容易调试 可以用非容器依赖的编程方式进行几乎所有的测试工作，在Spring里，测试不再是昂贵的操作，而是随手可做的事情。例如：Spring对Junit4支持，可以通过注解方便的测试Spring程序。 方便集成各种优秀框架 Spring不排斥各种优秀的开源框架，相反，Spring可以降低各种框架的使用难度，Spring提供了对各种优秀框架（如MyBatis、SpringMVC、Hibernate）等的直接支持。 降低Java EE API的使用难度 Spring对很多难用的Java EE API（如JDBC，JavaMail，远程调用等）提供了一个薄薄的封装层，通过Spring的简易封装，这些Java EE API的使用难度大为降低。 7. JavaBean提供了应用程序配置的最好方法Spring框架结构1、Spring Core（核心容器）：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 2、Spring Context（上下文）：Spring 上下文是一个配置文件，向 Spring框架提供上下文信息。Spring 上下文包括企业服务，例如JNDI、EJB、电子邮件、国际化、校验和调度功能。 3、Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。 4、Spring DAO：JDBCDAO抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 5、Spring ORM：Spring 框架插入了若干个ORM框架，从而提供了 ORM 的对象关系工具，其中包括JDO、Hibernate和iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 6、Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 7、Spring MVC 框架：MVC框架是一个全功能的构建 Web应用程序的 MVC 实现。通过策略接口，MVC框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。模型由javabean构成，存放于Map；视图是一个接口，负责显示模型；控制器表示逻辑代码，是Controller的实现。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]}]}